<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>esp8266深入</title>
    <link href="/2023/04/08/esp8266%E6%B7%B1%E5%85%A5/"/>
    <url>/2023/04/08/esp8266%E6%B7%B1%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>这里是<a href="">esp8266初试</a>的后续，主要是使用arduino ide来向esp8266中烧写程序。<br>esp8266不仅可以作为wifi模块来使用，同时还可以看作是一个小的自带wifi模块的单片机。<br>根据AT指令进行通讯的是出厂时烧录在里面的源程序，你自己写的程序烧录进去的时候<strong>会取代原有的程序</strong>，若是还想使用AT指令，需要重新<a href="https://blog.csdn.net/qq_37936305/article/details/119205996">刷固件</a><br>这里主要是介绍esp8266的自主编程，实现与服务器连接并接收服务器指令来操控led闪烁。</p><hr><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*这篇把8266作为TCPcleint，加入手机创建的tcpServer中来控制一个继电器*/</span><br>   <br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ESP8266WiFi.h&gt;</span></span><br>   <br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> relayPin   2    <span class="hljs-comment">//继电器连接在8266的GPIO2上</span></span><br><span class="hljs-comment">//const char *ssid     = &quot;HiWiFi_cy1999&quot;;//这里是我的wifi，你使用时修改为你要连接的wifi ssid</span><br><span class="hljs-comment">//const char *password = &quot;zzuacmlab&quot;;//你要连接的wifi密码</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *ssid     = <span class="hljs-string">&quot;OnePlus Ace&quot;</span>;<span class="hljs-comment">//这里是我的wifi，你使用时修改为你要连接的wifi ssid</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *password = <span class="hljs-string">&quot;16639193852&quot;</span>;<span class="hljs-comment">//你要连接的wifi密码</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host = <span class="hljs-string">&quot;frp-bar.top&quot;</span>;<span class="hljs-comment">//修改为手机的的tcpServer服务端的IP地址，即手机在路由器上的ip</span><br><span class="hljs-built_in">WiFiClient</span> client;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> tcpPort = <span class="hljs-number">41491</span>;<span class="hljs-comment">//修改为你建立的Server服务端的端口号</span><br>   <br>   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">begin</span>(<span class="hljs-number">115200</span>);<br>    <span class="hljs-built_in">delay</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">println</span>();<br>    <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">println</span>();<br>    <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Connecting to &quot;</span>);<span class="hljs-comment">//写几句提示</span><br>    <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">println</span>(ssid);<br>    <span class="hljs-built_in">pinMode</span>(<span class="hljs-number">2</span>, <span class="hljs-literal">OUTPUT</span>);<br>    <span class="hljs-built_in">WiFi</span>.<span class="hljs-built_in">begin</span>(ssid, password);<br>   <br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">WiFi</span>.status() != WL_CONNECTED)<span class="hljs-comment">//WiFi.status() ，这个函数是wifi连接状态，返回wifi链接状态</span><br>                                         <span class="hljs-comment">//这里就不一一赘述它返回的数据了，有兴趣的到ESP8266WiFi.cpp中查看</span><br>    &#123;<br>        <span class="hljs-built_in">delay</span>(<span class="hljs-number">500</span>);<br>        <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>    &#125;<span class="hljs-comment">//如果没有连通向串口发送.....</span><br>   <br>    <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;WiFi connected&quot;</span>);<br>    <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;IP address: &quot;</span>);<br>    <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">WiFi</span>.<span class="hljs-built_in">localIP</span>());<span class="hljs-comment">//WiFi.localIP()返回8266获得的ip地址</span><br>&#125;<br>   <br>   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>((!client.<span class="hljs-built_in">connected</span>()))<br>  &#123;<br>    <span class="hljs-keyword">while</span> (!client.<span class="hljs-built_in">connected</span>())<span class="hljs-comment">//几个非连接的异常处理</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (!client.<span class="hljs-built_in">connect</span>(host, tcpPort))<br>        &#123;<br>            <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;connection....&quot;</span>);<br>            <span class="hljs-comment">//client.stop();</span><br>            <span class="hljs-built_in">delay</span>(<span class="hljs-number">500</span>);<br>        <br>        &#125;<br>    &#125;<br>    client.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;esp8266&quot;</span>);<br>  &#125;<br>    <span class="hljs-keyword">while</span> (client.<span class="hljs-built_in">available</span>())<span class="hljs-comment">//改动的就这里啦，无线读取到的数据转发到到串口</span><br>    &#123;<br>        <span class="hljs-keyword">uint8_t</span> c = client.<span class="hljs-built_in">read</span>();<br>        <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">write</span>(c);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;a&#x27;</span>) &#123; <span class="hljs-comment">//pc端发送a和b来控制</span><br>          <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">2</span>, <span class="hljs-literal">HIGH</span>);<br>          client.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;已关灯&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;b&#x27;</span>)<br>        &#123;<br>          <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">2</span>, <span class="hljs-literal">LOW</span>);<br>          client.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;已开灯&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;c&#x27;</span>)<br>        &#123;<br>          <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">2</span>, <span class="hljs-literal">LOW</span>);<br>          <span class="hljs-built_in">delay</span>(<span class="hljs-number">100</span>);<br>          <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">2</span>, <span class="hljs-literal">HIGH</span>);<br>          client.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;已脉冲1&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;d&#x27;</span>)<br>        &#123;<br>          <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">2</span>, <span class="hljs-literal">LOW</span>);<br>          <span class="hljs-built_in">delay</span>(<span class="hljs-number">200</span>);<br>          <span class="hljs-built_in">digitalWrite</span>(<span class="hljs-number">2</span>, <span class="hljs-literal">HIGH</span>);<br>          client.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;已脉冲2&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br> <br> <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">available</span>())<span class="hljs-comment">//串口读取到的转发到wifi，因为串口是一位一位的发送所以在这里缓存完再发送</span><br>    &#123;<br>        <span class="hljs-built_in">delay</span>(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">size_t</span> counti = <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">available</span>();<br>        <span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">println</span>(counti);<br>        <span class="hljs-keyword">char</span> sbuf[<span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">available</span>())<br>          sbuf[i++]=<span class="hljs-built_in">Serial</span>.<span class="hljs-built_in">read</span>();<br>        sbuf[i]=<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        client.<span class="hljs-built_in">write</span>(sbuf,counti);<br> <br>    &#125;  <br>&#125;<br><span class="hljs-comment">/*int flasher_pin = 2; // GPIO2 for ESP-01S</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">void setup() &#123;</span><br><span class="hljs-comment">  Serial.begin(115200);  // can use Serial and flash Led at the same time on ESP-01S</span><br><span class="hljs-comment">  pinMode(2, OUTPUT);</span><br><span class="hljs-comment">  for (int i = 10; i &gt; 0; i--) &#123;</span><br><span class="hljs-comment">    Serial.print(i); Serial.print(&#x27; &#x27;);</span><br><span class="hljs-comment">    delay(500);</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  Serial.println();</span><br><span class="hljs-comment">    delay(1000);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">unsigned long counter = 0;</span><br><span class="hljs-comment">void loop() &#123;</span><br><span class="hljs-comment">  </span><br><span class="hljs-comment">    delay(1000);</span><br><span class="hljs-comment">  digitalWrite(2, HIGH); </span><br><span class="hljs-comment">    delay(1000);</span><br><span class="hljs-comment">  digitalWrite(2, LOW); </span><br><span class="hljs-comment">  Serial.println(counter++);</span><br><span class="hljs-comment">&#125;*/</span><br><br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>模块</category>
      
      <category>esp8266</category>
      
      <category>arduino</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网</tag>
      
      <tag>工程</tag>
      
      <tag>esp8266</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器通信初试-视频通信</title>
    <link href="/2023/03/30/%E5%88%9D%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/03/30/%E5%88%9D%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%86%E9%A2%91%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>这里是<a href="/2023/03/22/初试服务器通信设置/">初试服务器通信</a>的后续，添加了从服务器端到客户端的视频传输，也使用了tkinter制作了客户端的ui界面。</p><hr><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>TCP无法直接传输视频文件，需要将图片进行编码，使用的是opencv的<code>cv2.imencode()</code>函数，该函数可以将图片格式转换(编码)成流数据，赋值到内存缓存中;主要用于图像数据格式的压缩，方便网络传输。<br>相对的，客户端中就需要使用<code>cv2.imdecode()</code>函数来恢复图像。<br>若客户端申请视频链接，服务端根据客户端的请求类型会构造一个新的tcp连接，只负责视频传输。这样可以让视频和客户端的其他指令能够分线程传递，互不干扰。<br>客户端在原来的基础上增加了可视化界面，便于指令发送以及显示视频，具体是使用tkinter实现可以看下面的部分。<br>服务器端在客户端连接类里增加了视频传输，摄像头获取等功能。<br>具体的图片传输逻辑为：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">服务端发送图片大小-&gt;<br>客户端收到图片大小-&gt;<br>服务端按每份1字节的信息量发送图片-&gt;<br>客户端每次接收一份1字节信息，直到获得完整的一张图片信息，随后进行展示，展示正常结束后发送继续发送指令给服务端-&gt;<br>服务端收到继续发送指令，继续发送下一张图片。<br></code></pre></td></tr></table></figure><br>这样做的有一个缺陷是服务端得在客户端接受完一张图片的全部信息并处理之后返回接收成功消息之后才能进行下一张图片的发送，这样会导致服务器端从摄像头采集过来的许多未能发出的图片在内存里面产生堆积，挤占内存空间，同时也会造成客户端视频展示卡顿率极高。<br><strong>使用了两个解决方案：</strong><br>增大每份图片拆包的字节数目，每份1024字节，这样可以大幅度降低在传输时间上的损耗，使用了之后卡顿极大程度的缓解了。<br>在服务器端等待客户端回复的时间,用于清空摄像机缓存帧，使用cv.grab()可以只取帧不解码，可以用于快速处理无用帧。<br>（实际上在双创项目的单片机部分设想中多余的帧会存到sd卡上，每秒只会向服务器发指定帧数，也就不会存在这个问题）</p><hr><p>实际上搜索了之后发现视频往往依靠udp协议传递，偶尔缺帧是可以承受的，若是之后改用udp传输，可能还需要在接收端增添缓存队列，这样也可以更加流畅。</p><h3 id="客户端tkinter可视化"><a href="#客户端tkinter可视化" class="headerlink" title="客户端tkinter可视化"></a>客户端tkinter可视化</h3><p>原本的信息发送仅仅只是做了接收框和发送框，以及绑定了个连接服务器和发送的按钮。并且确保发送和接收消息是不同线程。<br>信息传递的流程为：连接-输入框输入用户名-发送-连接成功！-自由通信。<br>关于视频传输的部分增添了个视频按钮，点击后也会和连接服务器一样创建新的连接线程（用的是创建线程执行程序，这方法还蛮好用的）。创建之后就会把接收过来的图片信息恢复成图像，然后显示到tkinter的画布上并刷新组件，达到视频效果。</p><details><summary>点击查看代码</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk<br><span class="hljs-keyword">import</span> time,socket,threading<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageTk, Image<br><br><span class="hljs-comment"># 创建线程执行程序</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">thread_it</span>(<span class="hljs-params">func, *args</span>):</span><span class="hljs-comment"># 传入函数名和参数</span><br>    <span class="hljs-comment"># 创建线程</span><br>    t = threading.Thread(target=func, args=args)<br>    <span class="hljs-comment"># 守护线程</span><br>    t.setDaemon(<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 启动</span><br>    t.start()<br>    <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatUI</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.root = tk.Tk()<br>        self.root.title(<span class="hljs-string">&quot;Chat&quot;</span>)<br>        self.root.geometry(<span class="hljs-string">&quot;400x400&quot;</span>)<br>        self.HOST = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span> <span class="hljs-comment">#填你服务器的地址</span><br>        self.PORT = <span class="hljs-number">8881</span> <br>        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>        self.vedio_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)      <br>        self.create_widgets()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_widgets</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 创建信息显示框</span><br>        self.text = tk.Text(self.root,height=<span class="hljs-number">7</span>, width=<span class="hljs-number">30</span>, bd=<span class="hljs-number">5</span>)<br>        self.text.place(x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>)<br>        <span class="hljs-comment">#self.text.pack()</span><br>        <span class="hljs-comment"># 创建信息输入框</span><br>        self.entry = tk.Entry(self.root)<br>        self.entry.place(x=<span class="hljs-number">0</span>, y=<span class="hljs-number">103</span>,width=<span class="hljs-number">225</span>)<br>        <span class="hljs-comment"># 创建连接按钮</span><br>        self.connect_button = tk.Button(self.root, text=<span class="hljs-string">&quot;连接&quot;</span>, command=<span class="hljs-keyword">lambda</span>:thread_it(self.connect_server))<br>        self.connect_button.place(x=<span class="hljs-number">225</span>, y=<span class="hljs-number">0</span>,height=<span class="hljs-number">30</span>,width=<span class="hljs-number">30</span>)<br>        <span class="hljs-comment"># 创建发送按钮</span><br>        self.send_button = tk.Button(self.root, text=<span class="hljs-string">&quot;发送&quot;</span>, command=self.send)<br>        self.send_button.place(x=<span class="hljs-number">225</span>, y=<span class="hljs-number">30</span>,height=<span class="hljs-number">30</span>,width=<span class="hljs-number">30</span>)<br>        <span class="hljs-comment"># 创建显示视频按钮</span><br>        self.vedio_button = tk.Button(self.root, text=<span class="hljs-string">&quot;视频&quot;</span>, command=<span class="hljs-keyword">lambda</span>:thread_it(self.connect_vedio))<br>        self.vedio_button.place(x=<span class="hljs-number">225</span>, y=<span class="hljs-number">60</span>,height=<span class="hljs-number">30</span>,width=<span class="hljs-number">30</span>)<br>        <span class="hljs-comment"># 创建视频页面</span><br>        self.vedio_canvas = tk.Canvas(self.root,bg = <span class="hljs-string">&#x27;white&#x27;</span> )<span class="hljs-comment">#绘制画布</span><br>        self.vedio_canvas.place(x=<span class="hljs-number">0</span>, y=<span class="hljs-number">133</span>,height=<span class="hljs-number">650</span>,width=<span class="hljs-number">700</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv</span>(<span class="hljs-params">self</span>):</span><br>        username = self.entry.get()<br>        self.sock.send(username.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>        <span class="hljs-comment"># 清空输入框</span><br>        self.entry.delete(<span class="hljs-number">0</span>, tk.END)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 接收消息并显示在信息显示框中</span><br>            data = self.sock.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                <span class="hljs-keyword">break</span><br>            self.text.insert(tk.END, data)<br>            self.text.insert(tk.END, <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self</span>):</span><br>        time.sleep(<span class="hljs-number">0.5</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            message = self.entry.get()<br>            print(message)<br>            <span class="hljs-keyword">if</span> message:<br>                <span class="hljs-comment"># 发送消息到服务器</span><br>                self.sock.send(message.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>                <span class="hljs-comment"># 清空输入框</span><br>                self.entry.delete(<span class="hljs-number">0</span>, tk.END)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect_server</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 连接服务器</span><br>        self.sock.connect_ex((self.HOST, self.PORT))<br>        data=<span class="hljs-string">&#x27;已找到空闲服务器\n请输入用户名\n&#x27;</span><br>        self.text.insert(tk.END, data)<br>        t1 = threading.Thread(target=self.recv, args=())<br>        t1.start()<br>        t1.join()<br>    <span class="hljs-comment"># 接受图片大小的信息</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv_size</span>(<span class="hljs-params">self, count</span>):</span><br>        buf = <span class="hljs-string">b&#x27;&#x27;</span><br>        <span class="hljs-keyword">while</span> count:<br>            newbuf = self.vedio_sock.recv(count)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> newbuf: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            buf += newbuf<br>            count -= <span class="hljs-built_in">len</span>(newbuf)<br>        <span class="hljs-keyword">return</span> buf<br><br>    <span class="hljs-comment"># 接收图片</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv_all</span>(<span class="hljs-params">self, count</span>):</span><br>        buf = (<span class="hljs-string">&#x27;&#x27;</span>).encode()<br>        <span class="hljs-keyword">while</span> count:<br>            <span class="hljs-comment"># 这里每次只接收一个字节的原因是增强python与C++的兼容性</span><br>            <span class="hljs-comment"># python可以发送任意的字符串，包括乱码，但C++发送的字符中不能包含&#x27;\0&#x27;，也就是字符串结束标志位</span><br>            newbuf = self.vedio_sock.recv(<span class="hljs-number">4096</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> newbuf: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            buf += newbuf<br>            count -= <span class="hljs-built_in">len</span>(newbuf)<br>        buf_str=numpy.array(buf)<br>        <span class="hljs-comment">#print(buf_str)</span><br>        <span class="hljs-keyword">return</span> buf_str<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect_vedio</span>(<span class="hljs-params">self</span>):</span><br>        self.vedio_sock.connect_ex((self.HOST,self.PORT))<br>        self.vedio_sock.send((<span class="hljs-string">&quot;Get_video&quot;</span>).encode())<br>        print(<span class="hljs-number">11111</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 接受TCP链接并返回（conn, addr），其中conn是新的套接字对象，可以用来接收和发送数据，addr是链接客户端的地址。</span><br>            length = self.recv_size(<span class="hljs-number">16</span>) <span class="hljs-comment">#首先接收来自客户端发送的大小信息</span><br>            print(length)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>(length))!=<span class="hljs-number">0</span>: <span class="hljs-comment">#若成功接收到大小信息，进一步再接收整张图片</span><br>                stringData = self.recv_all(<span class="hljs-built_in">int</span>(length))<br>                <span class="hljs-comment">#stringData = self.vedio_sock.recv((int(length)*16))</span><br>                <span class="hljs-comment">#print(stringData)</span><br>                data = numpy.fromstring(stringData, dtype=<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>                decimg=cv2.imdecode(data,cv2.IMREAD_COLOR) <span class="hljs-comment">#解码处理，返回mat图片</span><br>                img_array = numpy.array(decimg, dtype=numpy.uint8)<br>                img = Image.fromarray(img_array)<br>                img_tk = ImageTk.PhotoImage(img)<br>                <span class="hljs-comment">#print(img_tk)</span><br>                self.vedio_canvas.create_image(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,anchor = <span class="hljs-string">&#x27;nw&#x27;</span>,image = img_tk)<br>                self.root.update()<br>                self.root.after(<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">10</span>) == <span class="hljs-number">27</span>:<br>                    <span class="hljs-keyword">break</span> <br>                print(<span class="hljs-string">&#x27;Image recieved successfully!&#x27;</span>)<br>                self.vedio_sock.send((<span class="hljs-string">&quot;Server has recieved messages!&quot;</span>).encode())<br>            <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">10</span>) == <span class="hljs-number">27</span>:<br>                <span class="hljs-keyword">break</span> <br>        self.vedio_sock.close()<br>        cv2.destroyAllWindows()<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    chat_ui = ChatUI()<br>    print(<span class="hljs-string">&quot;sddddd&quot;</span>)<br>    data=<span class="hljs-string">&#x27;单击连接以连接服务器\n&#x27;</span><br>    chat_ui.text.insert(tk.END, data)<br>    chat_ui.root.mainloop()<br><br></code></pre></td></tr></table></figure></details><p>中间一些奇怪的打表请忽略（</p><h3 id="服务器代码改善"><a href="#服务器代码改善" class="headerlink" title="服务器代码改善"></a>服务器代码改善</h3><p>服务器端的代码还是以<a href="/2023/03/22/初试服务器通信设置/">服务器通信</a>这里的为蓝本改的。<br>主要是将各个部分分开，然后主逻辑增添video连接的选项，client类添加了一下视频处理的代码。<br>写的时候在处理编码的地方耗了很久，python的格式感觉真的好乱，啥时候有时间整个用c++做的</p><details><summary>main.py</summary><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br><span class="hljs-keyword">from</span> Work <span class="hljs-keyword">import</span> start_server<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    start_server(<span class="hljs-number">8881</span>)<span class="hljs-comment">#这里配一下你的端口</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;服务器已关闭&quot;</span>)<br><br></code></pre></td></tr></table></figure></details><hr><details><summary>Work.py</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> socket,threading,time<br><span class="hljs-keyword">from</span> Client <span class="hljs-keyword">import</span> client<br>clients = &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_client_work</span>(<span class="hljs-params">c,server</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        print(<span class="hljs-string">&quot;%s(%s) 尝试连接&quot;</span> %(c.addr,c.port))<br>        data = c.recv()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &gt;= <span class="hljs-number">16</span>:<br>            c.socket.send(<span class="hljs-string">&quot;用户名太长了&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        c.username = data<br>        <span class="hljs-keyword">if</span> data==<span class="hljs-string">&#x27;Get_video&#x27;</span>:<br>            c.send_video(c.username)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        print(<span class="hljs-string">&quot;用户%s %s(%s)已连接&quot;</span> %(c.username,c.addr,c.port))<br>        c.socket.send(<span class="hljs-string">&quot;已连接&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data = c.recv()<br>            <span class="hljs-keyword">if</span> data==<span class="hljs-string">&#x27;--exit--&#x27;</span>:<br>            broadcast(data,c.username)<br>            <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                print(<span class="hljs-string">&quot;用户%s %s(%s) 发送了: %s&quot;</span> % (c.username,c.addr, c.port, data))<br>                broadcast(data,c.username)<br><br>    <span class="hljs-keyword">except</span> socket.errno <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;Socket error: %s&quot;</span> % <span class="hljs-built_in">str</span>(e))<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;Other exception: %s&quot;</span> % <span class="hljs-built_in">str</span>(e))<br>    <span class="hljs-keyword">finally</span>:<br>        print(<span class="hljs-string">&quot;%s(%s) 断开连接&quot;</span> % (c.addr, c.port))<br>        c.close()<br>        clients.pop(c.getId())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">broadcast</span>(<span class="hljs-params">msg,username,admin=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> clients.values():<br>        c.sendMsg(msg,username,admin)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_server</span>(<span class="hljs-params">port</span>):</span><br>    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br><br>    host = <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>    server.bind((host, port))<br><br>    <span class="hljs-comment"># 监听客户端</span><br>    server.listen(<span class="hljs-number">10</span>)<br>    print(<span class="hljs-string">&quot;服务器已开启，正在监听&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(server.getsockname()))<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 接受客户端连接</span><br>        conn, addr = server.accept()<br>        c = client(conn,addr,<span class="hljs-string">&quot;&quot;</span>)<br>        clients[c.getId()] = c<br>        <span class="hljs-comment"># 为该连接创建新线程</span><br>        t = threading.Thread(target=new_client_work, args=(c,server))<br>        t.start()<br><br></code></pre></td></tr></table></figure></details><hr><details><summary>Client.py</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> socket,threading,time<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,socket,addr,username</span>):</span><br>        self.addr = addr[<span class="hljs-number">0</span>]<br>        self.port = addr[<span class="hljs-number">1</span>]<br>        self.username = username<br>        self.socket=socket<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendMsg</span>(<span class="hljs-params">self,msg,username,admin</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> admin:<br>                self.socket.send((<span class="hljs-string">&quot;%s %s(管理员): %s&quot;</span> % (self.getTime(), username, msg)).encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>            <span class="hljs-keyword">else</span>:<br>                self.socket.send((<span class="hljs-string">&quot;%s %s: %s&quot;</span> %(self.getTime(), username, msg)).encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv</span>(<span class="hljs-params">self,mtu=<span class="hljs-number">1024</span></span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            data = self.socket.recv(mtu).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>            <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;-!-quit-!-&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> data:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> data<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_video</span>(<span class="hljs-params">self,username</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            self.capture = cv2.VideoCapture(<span class="hljs-number">0</span>)<span class="hljs-comment"># 从摄像头采集图像</span><br>            self.ret, self.frame = self.capture.read()<br>            self.fps = self.capture.get(<span class="hljs-number">5</span>)/<span class="hljs-number">10000</span>  <span class="hljs-comment">#查询帧率</span><br>            self.encode_param=[<span class="hljs-built_in">int</span>(cv2.IMWRITE_JPEG_QUALITY),<span class="hljs-number">90</span>] <span class="hljs-comment">#设置编码参数</span><br>            <span class="hljs-comment">#print(1111111111111111)</span><br>            <span class="hljs-keyword">while</span> self.ret: <br>                <span class="hljs-comment">#print(1111111111111111)</span><br>                <span class="hljs-comment">#cvimage = cv2.cvtColor(self.frame, cv2.COLOR_BGR2RGBA)</span><br>                <span class="hljs-comment">#pilImage=Image.fromarray(cvimage)</span><br>                <span class="hljs-comment">#self.frame = pilImage.resize((300, 250),Image.ANTIALIAS)</span><br>                self.result, self.imgencode = cv2.imencode(<span class="hljs-string">&#x27;.jpg&#x27;</span>, self.frame)<br>                data = numpy.array(self.imgencode)<br>                <span class="hljs-comment">#print(data)</span><br>                O_datas=numpy.array([])<br>                stringData = data.tobytes()<br>                datas=O_datas.tobytes()<br>                <span class="hljs-comment">#print(1111111111111111)</span><br>                self.socket.send((<span class="hljs-built_in">str</span>((<span class="hljs-built_in">len</span>(stringData))).ljust(<span class="hljs-number">16</span>)).encode())<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(stringData)):<br>                    datas+=data[i]<br>                    <span class="hljs-keyword">if</span> ((i+<span class="hljs-number">1</span>)%<span class="hljs-number">4096</span>==<span class="hljs-number">0</span>)<span class="hljs-keyword">or</span> (i+<span class="hljs-number">1</span>==<span class="hljs-built_in">len</span>(stringData)):<br>                        self.socket.send(datas)<br>                        datas=O_datas.tobytes()<br>                <span class="hljs-comment">#self.socket.send(data)</span><br>                <span class="hljs-comment">#print(1111111111111111)</span><br>                self.ret, self.frame = self.capture.read()<br>                print(self.fps)<br>                iloop=self.fps/<span class="hljs-number">2</span>  <span class="hljs-comment">#每秒处理2帧</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                    self.capture.grab()  <span class="hljs-comment">#只取帧不解码，</span><br>                    iloop =iloop - <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> iloop &lt;<span class="hljs-number">1</span> :<br>                            <span class="hljs-keyword">break</span> <br>                    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;q&#x27;</span>):<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-comment">#print(1111111111111111)</span><br>                data_r = self.socket.recv(<span class="hljs-number">50</span>)<br>                print(data_r)<br>        <span class="hljs-keyword">except</span> :<br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">finally</span>:<br>            self.capture.release()<br>            self.close()<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            self.socket.close()<br>            cv2.destroyAllWindows()<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getId</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;%s-%s&quot;</span> % (self.addr,self.port)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTime</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))<br>        <br>       <br></code></pre></td></tr></table></figure></details><p>一些奇怪的打表用于测试的请忽略（</p><h3 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h3><p>大概做完之后就是这样子的：<br><img src="/img/postpictures/getrhytreewdefrgthyjukytrewsdfghujgfdsadfrgttjuy.jpg" alt="界面是这样的"><br>运行后出来tkinter界面，然后点击视频按钮就可以获得服务器传来的实时摄像头视频。<br>（其实理论上应该是设计先用户登录，然后再点击视频按钮，这样子视频的连接就能和现在登录的这个用户的连接绑定，可以增加更多交互的可能性，不过有点赶工就没写这块逻辑）<br>目前的应用场景（在寝室直接监控机房）（雾）<br><img src="/img/postpictures/faf7ce2b9b38ee50c62afba0e6f5232.jpg" alt="偷窥！"><br>（这样不好）<br>最后还有一点在做完之后才发现，这玩意好费流量啊，我就打开了大概一分钟不到的时间就用俩70多M，之前做纯文本的服务器通信七八天用不了100kb。<br><img src="/img/postpictures/sadsadhuihvuicgerybfugtyeuhdyewuhidhwuidhjiuhu.png" alt="半分钟！！！"><br>想了能不能图片压缩什么的减少通信量，不过现在的照出来已经蛮模糊的了就没怎么搞。<br>总之是当不了机房监控了（算一算一个月免费的内网穿透流量大概只能用仨四小时？）。可能等之后有自己的服务器和域名的话就不用受这限制。</p><p>总之是蛮好玩的，并且也会继续好玩下去。<br><img src="/img/postpictures/dsvthcfewgryejfwracfawebyeujgregref4t4.png" alt="呢就不好玩了"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程</tag>
      
      <tag>服务器</tag>
      
      <tag>项目工程</tag>
      
      <tag>互联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>esp8266初试</title>
    <link href="/2023/03/24/esp8266%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/03/24/esp8266%E7%AE%80%E4%BB%8B%E4%B8%8E%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>ESP8266 是一个完整且自成体系的 WiFi 网络模块，能够独立运行， 也可以作为 slave 搭载于其他 Host 运行。<br>可以用于物联网、可穿戴电子产品和移动设备等领域。可以使用ESP8266来连接家里的路由器，将物理设备连接到WiFi无线网络上，进行互联网或局域网通信，实现联网功能。<br>esp8266有8根引脚，功能如下所示：</p><div class="table-container"><table><thead><tr><th>名称</th><th>作用</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>GND</td><td>接地</td><td>TXD</td><td>串口0数据发送端</td></tr><tr><td>GPIO2</td><td>通用IO，内部已上拉</td><td>EN</td><td>芯片使能，高电平使能低电平失能</td></tr><tr><td>GPIOO</td><td>工作模式选择：<br>1)悬空:Flash Boot，工作模式 <br> 2)下拉:UARTDownLoad，下载模式</td><td>RST</td><td>1)外部复位管脚低电平复位 <br> 2)可以悬空或者接外部MCU</td></tr><tr><td>RXD</td><td>串口0数据接收端</td><td>VCC</td><td>3.3V供电</td></tr></tbody></table></div><hr><h2 id="使用USB转TTL串口测试esp8266"><a href="#使用USB转TTL串口测试esp8266" class="headerlink" title="使用USB转TTL串口测试esp8266"></a>使用USB转TTL串口测试esp8266</h2><h3 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h3><p>我用的模块是esp8266-01s模块，需要连接的引脚有：RX,TX,GND,VCC,EN<br>电路图如下所示：<br><img src="/img/postpictures/asdfdsgfdhgkjtykteyuhtesygher.png" alt="电路连线"><br>注意一下esp模块的和usb转ttl模块的tx和rx是反着接的。<br>下方是我的连线状况，没有面包板所以比较乱，虽然没啥大问题但是感觉有点小危险。<br><img src="/img/postpictures/sdfsgfdshgfjyghjuykytkjtyjd.jpg" alt="我的连线状况"><br><img src="/img/postpictures/dsfgdsghfdhgjhfkfukeyhgtreyhr.jpg" alt="有点摇摇欲坠"></p><h3 id="AT指令测试"><a href="#AT指令测试" class="headerlink" title="AT指令测试"></a>AT指令测试</h3><p>将其连线好后连接到电脑上，电脑上打开<a href="/file/download/sscom32.zip">串口助手</a>，选择COM7并选择波特率115200。<br>发送“AT”，若返回“OK”，则代表连接无误，如下图所示：<br><img src="/img/postpictures/sdagrehgiuhhefwuinxciuqwbeuigd.png" alt="连接无误"></p><div class="table-container"><table><thead><tr><th>AT命令</th><th>作用</th><th>细分命令</th><th>细分作用</th></tr></thead><tbody><tr><td><strong>AT+RST</strong></td><td><strong>重启模块</strong></td><td></td><td></td></tr><tr><td><strong>AT+GMR</strong></td><td><strong>查看版本信息</strong></td><td></td><td></td></tr><tr><td><strong>AT+UART</strong></td><td><strong>UART配置</strong></td><td>AT+UART 115200,1,0,0</td><td></td></tr><tr><td><strong>AT+CWMODE</strong></td><td><strong>设置WiFi模式</strong></td><td><strong>设置指令</strong>：AT+CWMODE=1</td><td>1:Station模式 <br>2：SoftAP模式 <br>3：SoftAP+Station模式</td></tr><tr><td></td><td></td><td><strong>查询指令</strong>：AT+CWMODE?</td><td>查询当前是什么模式</td></tr><tr><td><strong>AT+CWJAP</strong></td><td><strong>连接AP（路由）</strong></td><td><strong>查询指令</strong>：AT+CWJAP？</td><td>查询当前连接的wifi信息</td></tr><tr><td></td><td></td><td><strong>设置指令（连接WiFi）</strong>：AT+CWJAP：[ssid],[psd][,bssid]</td><td>[ssid]: 目标AP的SSID  <br>[psd]:密码  最长64字节ASCII  <br>[bssid]: 目标 AP 的 MAC 地址，一般用于有多个 SSID 相同的 AP 的情况 <br>报错代码:1: 连接超时<br>2: 密码错误<br>3: 找不到目标AP<br>4: 连接失败<br>参数设置需要开启 Station 模式，若 SSID 或者password 中含有特殊符号例如“，”或者“ “ ”或者“\”时需要进行转义，其它字符转义无效。</td></tr><tr><td><strong>AT+CWQA</strong></td><td><strong>断开与AP的连接</strong></td><td></td><td></td></tr><tr><td><strong>AT+CIFSR</strong></td><td><strong>查询本地IP地址</strong></td><td></td><td></td></tr><tr><td><strong>AT+CIPSTART</strong></td><td><strong>建立TCP连接，UDP传输或SSL连接</strong></td><td>AT+CIPSTART=[ type ] ,[remote IP] ,[remoteport ][,TCP keep alive]</td><td>[type]: 字符串参数，连接类型，”TCP”，”UDP”或”SSL”<br>[remote IP]: 字符串参数，远端IP地址<br>[remote port]: 远端端口号<br>[TCP keep alive]: TCP keep-alive 侦测时间，默认关闭此功能<br>0:关闭 TCP keep-alive 功能<br>1~ 7200: 侦测时间，单位为 1s</td></tr><tr><td><strong>AT+CIPCLOSE</strong></td><td><strong>断开连接</strong></td><td>AT+CIPCLOSE=[id]</td><td>[id]为需要关闭的连接 id 当 id 为 5 时关闭所有连接</td></tr><tr><td><strong>AT+CIPMUX</strong></td><td><strong>设置多连接模式</strong></td><td>AT+CIPMUX=[id]</td><td>[id] 为0时为单连接，为1时为多链接</td></tr><tr><td><strong>AT+CIPSERVER</strong></td><td><strong>建立TCP服务器</strong></td><td>AT+CIPSERVER=[mode][,port]</td><td>[mode]:<br>0:关闭服务器 <br>1: 建立服务器  <br>[port]: 端口号，默认为 333。<br> 多连接情况下 (AT+CIPMUX=1)，才能开启 TCP 服务器。创建 TCP 服务器后，自动建立 TCP 服务器监听<br>当有 TCP 客户端接入，会自动占用一个连接 ID.</td></tr><tr><td><strong>AT+CIPMODE</strong></td><td><strong>设置传输模式</strong></td><td>AT+CIPMODE?</td><td>查询指令</td></tr><tr><td></td><td></td><td>AT+CIPMODE=[mode]</td><td>设置指令<br> 0: 普通传输模式 <br>1: 透传模式，仅支持 TCP 单连接和 UDP 固定通信对端的情况<br>透传模式传输时，如果连接断开，ESP8266 会不停尝试重连，此时单独输入 +++ (不要输入换行符)退出透传，则停止重连;普通传输模式则不会重连，提示连接断开。</td></tr><tr><td><strong>AT+CIPSEND</strong></td><td><strong>发送数据</strong></td><td></td><td>执行指令(在透传模式下，开始发送指令)</td></tr></tbody></table></div><h3 id="服务器连接测试"><a href="#服务器连接测试" class="headerlink" title="服务器连接测试"></a>服务器连接测试</h3><p>确认模块连接良好（输入&gt;&gt;AP 输出&gt;&gt;ok）后，先连接至路由器<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">AT</span>+CWMODE_DEF=<span class="hljs-number">1</span>  <span class="hljs-comment"># 设置Wi-Fi为 Station 模式并保存至 Flash，以后每次供电后自动连接</span><br><span class="hljs-built_in">AT</span>+CWJAP=<span class="hljs-string">&quot;HI_WiFi_cy1999&quot;</span>,<span class="hljs-string">&quot;zzuacmlab&quot;</span>  <span class="hljs-comment"># 实验室的wifi名称和密码</span><br></code></pre></td></tr></table></figure><br>连接成功后，使用AT+CIPSTART与服务器建立TCP连接：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">AT</span>+CIPSTART=<span class="hljs-string">&quot;TCP&quot;</span>,<span class="hljs-string">&quot;你的服务器地址&quot;</span>,你的服务器端口<br></code></pre></td></tr></table></figure><br>若是没有服务器的话也可以用内网ip测试（也可以看<a href="/2023/03/22/服务器通信设置/">这篇文章</a>免费进行搭建<br>与服务器成功建立连接后结果如下图所示：<br><img src="/img/postpictures/dsfdsgrtjhtyukuyktrhersthgertgerrgre.png" alt="与服务器成功建立连接"><br>之后开启透传模式，响应ok后开启透传：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">AT</span>+CIPMODE=<span class="hljs-number">1</span><br><span class="hljs-keyword">AT</span>+CIPSEND<br></code></pre></td></tr></table></figure><br>成功后应显示如下：<br><img src="/img/postpictures/sdgfdhkiulreutrhtbrehergergfew.png" alt="现在可以开始透传了"><br>之后就可以与服务器进行交互，也可以通过服务器与其他客户端进行交流。如图所示，命令框是本地客户端，发出的消息经过服务器转发至esp8266，然后显示在串口调试器上可以通过服务器与其他客户端进行交流<br><img src="/img/postpictures/sdgerhtyrjyuttrhgtrsgvertgretgregfer.png" alt="通过服务器与其他客户端进行交流"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>模块</category>
      
      <category>esp8266</category>
      
    </categories>
    
    
    <tags>
      
      <tag>物联网</tag>
      
      <tag>工程</tag>
      
      <tag>esp8266</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器通信初试-tcp通信</title>
    <link href="/2023/03/22/%E5%88%9D%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/03/22/%E5%88%9D%E8%AF%95%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p>其实很早就想自己整个服务器什么的了，不过一直没有什么迫切的需求，所以也一直搁置，前几天发现上学期拜托马老师在旁边整的linux一直没用上，所以就心血来潮整了整。<br>也是蛮简单的一个东西，就是写个TCP接收的服务，再做个内网穿透，就能把你的机房电脑变成免费服务器了（bushi）</p><hr><h3 id="TCP服务器接收程序"><a href="#TCP服务器接收程序" class="headerlink" title="TCP服务器接收程序"></a>TCP服务器接收程序</h3><p>TCP协议我在<a href="/2022/03/14/计算机网络/#TCP协议">计算机网络</a>中曾介绍过。就不详细展开了。<br>python代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> socket,threading,time<br><span class="hljs-comment"># 存储连接到服务器的客户端的dir，键是客户端ID，值是 client 对象</span><br>clients = &#123;&#125;<br><span class="hljs-comment"># 定义客户端类，包含 socket 连接、IP地址、端口号、用户名等信息</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">client</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,socket,addr,username</span>):</span><br>        self.addr = addr[<span class="hljs-number">0</span>] <span class="hljs-comment"># IP地址</span><br>        self.port = addr[<span class="hljs-number">1</span>] <span class="hljs-comment"># 端口号</span><br>        self.username = username <span class="hljs-comment"># 用户名</span><br>        self.socket=socket <span class="hljs-comment"># socket 连接对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendMsg</span>(<span class="hljs-params">self,msg,username,admin</span>):</span><span class="hljs-comment"># 发送消息</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> admin:  <span class="hljs-comment"># 判断是否是管理员</span><br>                self.socket.send((<span class="hljs-string">&quot;%s %s(管理员): %s&quot;</span> % (self.getTime(), username, msg)).encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>            <span class="hljs-keyword">else</span>:<br>                self.socket.send((<span class="hljs-string">&quot;%s %s: %s&quot;</span> %(self.getTime(), username, msg)).encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recv</span>(<span class="hljs-params">self,mtu=<span class="hljs-number">1024</span></span>):</span><span class="hljs-comment"># 接收消息的</span><br>        <span class="hljs-keyword">try</span>:<br>            data = self.socket.recv(mtu).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>            <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;-!-quit-!-&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> data:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> data<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># 关闭连接</span><br>        <span class="hljs-keyword">try</span>:<br>            self.socket.close()<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getId</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment"># 获取客户端ID的方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;%s-%s&quot;</span> % (self.addr,self.port)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTime</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment"># 获取当前时间=</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_client</span>(<span class="hljs-params">c</span>):</span><span class="hljs-comment"># 新客户端加入聊天室时的处理函数</span><br>    <span class="hljs-keyword">try</span>:<br>        print(<span class="hljs-string">&quot;%s(%s) 尝试连接&quot;</span> %(c.addr,c.port))<br>        data = c.recv()<span class="hljs-comment"># 接收客户端发送的用户名</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) &gt;= <span class="hljs-number">16</span>:<br>            c.socket.send(<span class="hljs-string">&quot;用户名太长了&quot;</span>)<br>            <span class="hljs-keyword">return</span><br>        c.username = data<br>        print(<span class="hljs-string">&quot;用户%s %s(%s)已连接&quot;</span> %(c.username,c.addr,c.port))<br>        c.socket.send(<span class="hljs-string">&quot;已连接&quot;</span>.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data = c.recv()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                print(<span class="hljs-string">&quot;用户%s %s(%s) 发送了: %s&quot;</span> % (c.username,c.addr, c.port, data))<br>                broadcast(data,c.username)<br><br>    <span class="hljs-keyword">except</span> socket.errno <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;Socket error: %s&quot;</span> % <span class="hljs-built_in">str</span>(e))<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;Other exception: %s&quot;</span> % <span class="hljs-built_in">str</span>(e))<br>    <span class="hljs-keyword">finally</span>:<span class="hljs-comment"># 输出断开连接的信息，并从字典中删除该客户端</span><br>        print(<span class="hljs-string">&quot;%s(%s) 断开连接&quot;</span> % (c.addr, c.port))<br>        c.close()<br>        clients.pop(c.getId())<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">broadcast</span>(<span class="hljs-params">msg,username,admin=<span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> clients.values():<br>        c.sendMsg(msg,username,admin)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_server</span>(<span class="hljs-params">port</span>):</span><span class="hljs-comment">#在本地端口上开放连接</span><br>    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br><br>    host = <span class="hljs-string">&quot;192.168.153.1&quot;</span>  <br>    server.bind((host, port))<br><br>    <span class="hljs-comment"># 监听客户端</span><br>    server.listen(<span class="hljs-number">10</span>)<br>    print(<span class="hljs-string">&quot;服务器已开启，正在监听&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(server.getsockname()))<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 接受客户端连接</span><br>        conn, addr = server.accept()<br>        c = client(conn,addr,<span class="hljs-string">&quot;&quot;</span>)<br>        clients[c.getId()] = c<br>        t = threading.Thread(target=new_client, args=(c,))<span class="hljs-comment">#为每个用户新创建一个线程。</span><br>        t.start()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    start_server(<span class="hljs-number">23333</span>)<br>    print(<span class="hljs-string">&quot;服务器已关闭&quot;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="内网穿透服务"><a href="#内网穿透服务" class="headerlink" title="内网穿透服务"></a>内网穿透服务</h3><p>内网穿透是一种网络技术，可以让外网用户通过公网访问内网中的服务。通常情况下，内网中的设备无法直接从公网访问，因为它们位于私有 IP 地址空间内，无法直接被公网访问到。而内网穿透技术通过一定的方法，可以将公网请求转发到内网设备上，实现公网用户访问内网服务的目的。</p><p>内网穿透可以通过多种方式实现，其中比较常见的是端口映射和反向代理。</p><p><strong>端口映射</strong><br>端口映射是指将公网端口和内网端口进行映射，将公网请求发送到公网端口，然后通过映射将请求转发到内网端口上。这种方式需要在公网服务器上安装内网穿透软件，通常还需要配置一些参数和规则来实现转发。</p><p><strong>反向代理</strong><br>反向代理是指将公网请求发送到反向代理服务器上，然后由反向代理服务器将请求转发到内网服务器上，并将响应返回给公网用户。这种方式需要在公网服务器上安装反向代理软件，将公网请求转发到内网服务器上。<br>可以简单理解为由于内网服务器没有一个公网的地址，公网用户只能先发消息到一个公网的服务器作为中间站，然后再由中间站转发到你内网中的服务器中。</p><p>我用的是<a href="https://www.natfrp.com/">SAKURA FRP</a>的反向代理，仅仅是tcp的话是免费的。之前用的是花生壳的不知道为啥过一段时间就掉，这个还相对稳定些。<br>需要在服务器上下载它的客户端，注册后会给你个密钥，在设备上下好后使用密钥启动隧道。<br>它本身的<a href="https://doc.natfrp.com/frpc/usage.html">教程</a>很详细，再此就不多赘述</p><h3 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h3><p>服务器打开后，可以看到可以接收到从客户端发来的数据。<br><img src="/img/postpictures/sdfjkshfuishuiasghduiashduiahduihui.jpg" alt="能接收客户端发送过来的数据"><br>客户端也可以收到服务器的反馈（只要是写可以tcp通信的服务都可以作为客户端），以下是我用来测试的客户端代码和示例：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">import <span class="hljs-built_in">socket</span><br><br><span class="hljs-comment"># 创建一个socket对象</span><br>s = <span class="hljs-built_in">socket</span>.<span class="hljs-built_in">socket</span>(<span class="hljs-built_in">socket</span>.AF_INET, <span class="hljs-built_in">socket</span>.SOCK_STREAM)<br><br><span class="hljs-comment"># 连接服务器</span><br>server_addr = (<span class="hljs-string">&#x27;你的服务器地址&#x27;</span>, 你的服务器端口)<br>s.connect(server_addr)<br><br><span class="hljs-keyword">while</span> True:<br>    <span class="hljs-comment"># 输入要发送的数据</span><br>    send_data = input(<span class="hljs-string">&quot;请输入要发送的数据：&quot;</span>)<br>    <span class="hljs-keyword">if</span> send_data == <span class="hljs-string">&#x27;exit&#x27;</span>:<br>        s.<span class="hljs-built_in">send</span>(send_data.encode())<br>        break<br>    <span class="hljs-comment"># 发送数据</span><br>    send_data+=<span class="hljs-string">&#x27;@&#x27;</span><br>    print(send_data,<span class="hljs-string">&#x27;676767&#x27;</span>)<br>    <span class="hljs-comment">#中间测试用，以上这两句可以删（（</span><br>    s.<span class="hljs-built_in">send</span>(send_data.encode())<br>    recv_data=s.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    print(recv_data)<br>    <br>s.<span class="hljs-built_in">close</span>()<br><br></code></pre></td></tr></table></figure><p><img src="/img/postpictures/asddasfdsgfdhgfjhgjhgjfgyj.png" alt="能接收服务器发送过来的数据"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程</tag>
      
      <tag>服务器</tag>
      
      <tag>项目工程</tag>
      
      <tag>互联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标签画像项目开发记录</title>
    <link href="/2022/06/27/%E6%A0%87%E7%AD%BE%E7%94%BB%E5%83%8F%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/06/27/%E6%A0%87%E7%AD%BE%E7%94%BB%E5%83%8F%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>现在是7/17/2022，实际上是这个项目已经接近完成了，目前就剩下导师们的评审了。<br>我的项目主体是由c++的后端部分以及python的前端部分，c++的部分打包成来exe供python进行使用，之间的交互以及数据的暂存均通过文件方式。<br>c++的后端部分主要是写具体的业务逻辑，由于中途需求改动了一次，导致部分业务逻辑并没有用上，不过在本文中回阐明所有的逻辑<br>python的前端部分经历了三次主要改动，第一次是初学tkinter时搭建的简易框架，由于需要美化在csdn上找到了前人写的exbutton相关的以及ttk相关的内容，这是第二次对整体页面框架的修改。由于exbutton部分前人断更了，但是离需求需要的美化还有着不小的距离，因此在搜索进一步美化的时候找到并学习了ttkbootstrap，第三次修改主要的是页面上的具体内容。<br>单人，从mysql开始学习然后到项目结束大概是三周的时间，中间由于休息，考试，培训的时间除外（也除外mysql的学习时间的话），单论从设计到项目实施，实际的打代码时间（包括后续的一次需求变动），大概实际所用时间是是十一二天左右（3天设计，两天半后端，半天到一天后端测试，四五天前端）<br>c++部分大约是近1.4k行的代码,python的话大概是有2.3k左右行的代码，大概是课程作业量级的项目？<br>学习了很多的东西，比如项目需求的分析，项目框架以及具体的设计，mysql的初步学习使用，以及python的一大堆相关的库，等等。</p><p>大概就是这样，接下来就是项目的具体情况</p><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><h3 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h3><p>基于用户数据进行数据分析，需求分析，功能设计，数据库设计，代码开发，实现用户标签和画像系统。</p><h3 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h3><p>考虑角色分工以及项目工作量，建议以团队协作模式开展，建议3~6人协作完成，充分体验项目分工和项目协作。<del>确实，感觉想要实现多种功能的话还是人多一点好，起码来一个人帮忙写前端就能多一半开发时间取做额外修饰</del><br>按照需求分析、设计、编码和联调、运行等过程展开项目。<br>实现用户标签和画像功能，要求满足以下功能：<br>1) 标签<br>    a) 支持分多层设计，不少于 2 层；<br>    b) 支持自定义标签阈值，调整阈值后，能重新生成标签；<br>    c) 标签总数，不少于 10 个。</p><p>2) 画像支持 2 类：<br>    a) 单客户画像，不少于 10 个字段，不少于 3 个标签；<br>    b) 客户群体画像，不少于 3 个图表（或数据指标）。</p><h3 id="技术要求"><a href="#技术要求" class="headerlink" title="技术要求"></a>技术要求</h3><p>1) 使用 Java 语言进行程序设计和开发；<del>坏了，我用的是c++和py</del><br>2) 使用 MySQL 数据库；<br>3) 前端实现技术，依据自身的掌握能力选择。如果能够实现前端页面展示，适当加分。</p><p>项目介绍大致就是这样，提供有30W条数据进行查询。</p><h2 id="程序设计框架图"><a href="#程序设计框架图" class="headerlink" title="程序设计框架图"></a>程序设计框架图</h2><p><img src="/img/postpictures/vhuisdvhuifbisdncoijeidoiehhufo.jpg" alt="项目主体架构"><br><img src="/img/postpictures/fddfgfgjuykiulfykufhntr.png" alt="业务逻辑层"><br><img src="/img/postpictures/sdvsbgtryjukijhgfdefrgthy.png" alt="数据交换层"><br><img src="/img/postpictures/xngfgdfhsrthnjghmk.png" alt="细碎模块部分"></p><p>这几个模块设计也是第二版的，由于中途需求改动，改动了一些模块的实现方式，可能会有一些细节没有更新到，导致最终程序可能和本项目规划图可能有一些细微差别。</p><h2 id="c-后端部分"><a href="#c-后端部分" class="headerlink" title="c++后端部分"></a>c++后端部分</h2><p><img src="/img/postpictures/dfsgtrshyrdjhsryghtrsyhgr.png" alt="c++模块的主要文件结构"></p><p>c++模块实际上没什么好说的，就是 把设计框架呢堆东西使用程序语言实现即可，小项目，逻辑简单，也没什么卡住的地方。唯一卡的地方可能就是前期设计时思考的不全面的问题导致中期开发时得额外加东西，比如信息流部分实际上是在写代码时才逐渐完善的，这样子搞在团队协作时可能会造成一定的冲突，因此还是主要在前期规划时要规划好。<br>大概是每完成一个小模块就测试一下，然后最后也没什么大bug，这是个好习惯。</p><h2 id="python前端部分"><a href="#python前端部分" class="headerlink" title="python前端部分"></a>python前端部分</h2><p>py的部分比较繁杂，最开始确定使用EXbutton实际上是嫖了csdn上<a href="https://blog.csdn.net/RCHT1_Hideonbush/article/details/119520839">这位</a>的框架，觉得蛮不错的就开始学tkinter，（最终实现的效果实际上就能看出这个框架的影子）。<br>python阶段的开发实际上是比较艰难的时刻，因为在学新的东西，并且py本来就不怎么适合写界面（本来是想学QT的但是被pass了<del>寄</del>）。因此写的比较混乱并且也没怎么好好规划（字体，ico，其他图片都放在一个文件夹里）。<br>所用到的库有：</p><pre><code>PILrandompathlibostkinterttkbootstrapmysqlmatplotlibwordcloudjiebaimageio</code></pre><p>可能还会有些边边角角的没有统计上，具体的可以在我的源码里看。</p><h3 id="项目结果"><a href="#项目结果" class="headerlink" title="项目结果"></a>项目结果</h3><p>我将c++后端的部分编译成了可执行文件供python调用<br>直接点击main.py即可打开主界面<br><img src="/img/postpictures/adsfdsgdhjyjytdjyg.png" alt="主界面"><br>主界面就链接了整个数据库，可以直接查询数据库中的信息<br><img src="/img/postpictures/sdgrfjukiuylhfdgh.png" alt="主界面查询"><br>当然，也支持多种方式查询，比如范围查询，时间日期类型数据查询等。<br><img src="/img/postpictures/dsafghtmjuyfrehgragw.png" alt="多种方式查询"><br>标签选择界面，一共是三个大标签类，每个标签类下有数个小标签类，每一个小标签类都有多个选项，可多选，使用标签选取数据的原则是：各个 小标签类里选择的并集 的交集部分<br><img src="/img/postpictures/safrshgtrjyghkyfufkerg.png" alt="比如这些数据就是来源地为（内蒙古或台湾或山东）同时用户等级为（VIP用户或普通用户或粉丝），用户年龄在（青年用户或中年用户）这一阶段的人。"><br>以上标签中的标签具体值是可以修改的，比如说少年标签设定的是0~18岁，我现在想要修改他的值为0~22岁。需要进入标签修改页面<br><img src="/img/postpictures/sdgfdhyjuylokdytusrtywer.png" alt="标签值修改页面"><br><img src="/img/postpictures/sdgfdhgtjykuyfrg.png" alt="具体值输入框"><br><img src="/img/postpictures/dfagtrhjytjerwtgefefew.png" alt="修改成功提示"><br>在右边小框内显示的用户编号双击后可以来道用户画像构建页面并自动建立用户画像<br>用词云图的方式呈现。<br><img src="/img/postpictures/safsdhtujyifywertewtfercvtuyrt.png" alt="词云图，我其实想尽力构建一个人像的形式，但是做的效果可能还是不太星（"><br>群体画像的话主要是选取了一些标签用图表的方式表现了出来<br>其中一些图表如下<br><img src="/img/postpictures/adfdhygkufdwetrwwrqer.png" alt="用户种类"><br><img src="/img/postpictures/asfjytiwetreyhtrhwyjnnbvw.png" alt="用户来源"><br>点击具体标签会在旁边一栏显示该标签所属人群<br>（他这数据好平均啊）</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><h3 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h3><p>首先是词云图，应该是可以使用算法来使得构建更加智能<br>或者是完善构建方式，添加补全未知信息预测的功能<br>（对于不全的信息目前只是提示无法构建词云图，理想状态下应该是用一些分类模型来能根据原本的数据来预测的。）<br>还有就是图表的效果，由于tkinter并没有现成的图表样式，因此是自己用矩阵三角等形状元素构建的图表库，目前是只实现了样式，并没有相应的交互，理想状态应该是鼠标晃到上去可以显示相应的信息，一些逻辑处理以及显示信息的位置还做起来比较麻烦，因此目前还没有实现。</p><p>还有的是效率问题，目前每次调用数据均需要从数据库中读入，总信息量300w条，假如选取的标签所涉及的数据过多会产生较严重的延时问题。修改代码的时候也是找了一些解决方法但是用处不大。当然，也有可能是我刚学mysql，不是很熟悉其中的优化。<br>问了一下，实际工程中一般都会将数据直接预读入到内存里，数据量加大时一半加内存就行了，我应该是用不了这种方法了。</p><h3 id="学习到的东西"><a href="#学习到的东西" class="headerlink" title="学习到的东西"></a>学习到的东西</h3><p>项目开发经验，自学能力<br>完整的项目周期：做需求分析-构建xml图、类图、思维导图-程序代码实现-测试-交付<br>瀑布式开发流程-敏捷式开发流程<br>开发的具体知识：mysql python GUI工具 c++面向对象开发 一些语法糖<br>大概就是这样</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>项目工程</tag>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
      <tag>标签画像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信号与系统</title>
    <link href="/2022/04/12/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/04/12/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>难啊</code></pre><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><p>信号可以表示为时间的一个函数或序列，该函数图像就被称为信号的波形<br>一些信号的特性可能不能用函数来描述，但是可以有具体波形<br>信号分为以下的种类：</p><h4 id="连续信号和离散信号"><a href="#连续信号和离散信号" class="headerlink" title="连续信号和离散信号"></a>连续信号和离散信号</h4><p><strong>连续时间信号是在连续时间范围内有定义的信号，这里的连续指的是定义域的连续（所以连续信号可以含有不连续点），值域可以是连续的也可以是非连续的。</strong><br><strong>离散信号是仅在一些离散的瞬间才有定义的信号（离散信号无连续定义域）。</strong><br>这本书新学的一个重点的时间信号是：<script type="math/tex">\epsilon (k)= \begin{cases} 0,k<0 \\\\ 1,k\geq 0\end{cases}</script> ,他的名字为单位阶跃函数，其值域只有0，1两个数值。<br>目前定义有三种，主要区分点在于自变量为0时函数值不相同（<strong>一种是0点没有定义，一种是0点为1/2，一种就是我书写的这种，0点为1，我使用的教材为吴大正的信号与系统第五版，这是这本书上的定义。</strong>）<br>单位阶跃函数的导数为冲击函数：<script type="math/tex">\delta (t)= \begin{cases} \int^{\infty}_{-\infty}\delta (t)dt=1 \\\\ \delta (t)=0,t\neq 0 \end{cases}</script><br>冲击函数只在0点有非0值并趋近于正无穷。（可以想象一个限定面积为1的矩形信号以y轴为对称轴，不断将其拉高使得其高度趋近于正无穷宽度趋近于0）</p><h4 id="周期信号和非周期信号"><a href="#周期信号和非周期信号" class="headerlink" title="周期信号和非周期信号"></a>周期信号和非周期信号</h4><p><strong>周期信号是定义在<script type="math/tex">(-\infty ,\infty)</script>区间，每隔一定时间T或整数N（离散信号），按相同规律重复变化的信号。</strong><br><strong>不具有周期性的信号被称为非周期信号（T或者N趋近于无穷）</strong></p><h4 id="能量信号与功率信号"><a href="#能量信号与功率信号" class="headerlink" title="能量信号与功率信号"></a>能量信号与功率信号</h4><p>若信号f(t)的能量有界，则称其为能量有限信号，简称为能量信号。弱信号f(t)的功率有界，则称其为功率有限信号，简称为功率信号。仅在有限时间区间不为零的信号为能量信号，因为这些信号的平均功率为0，因此只能从能量的角度去考察，直流信号，周期信号阶跃信号这些都是功率信号，他们的能量为无限，只能从功率的角度去考察。<strong>一个信号不可能既是能量信号又是功率信号</strong><br>对于连续信号是积分，离散信号是求和。<br><img src="/img/postpictures/sdagtrhrtjhtygjngfdbdsgfewf.png" alt="大概是这样"></p><h4 id="关于冲激函数的重要性质"><a href="#关于冲激函数的重要性质" class="headerlink" title="关于冲激函数的重要性质"></a>关于冲激函数的重要性质</h4><p>冲激信号的广义函数定义：<script type="math/tex">\int^{\infty}_{-\infty}\delta(t)\varphi(t)dt=\varphi(0)</script><br>由此可得:  <script type="math/tex">\int^{\infty}_{-\infty}\delta(t-t_0)\varphi(t)dt=\varphi(t_0)</script><br>由这两个式子可以推出冲激函数的取样性： <script type="math/tex">\int^{t_2}_{t_1} f(t)\delta(t-t_0)dt= \begin{cases} f(t_0),t_0\in [t_1,t_2] \\\\ 0,t_0 \notin [t_1,t_2]\end{cases}</script><br>单位冲击函数为偶函数，<br>单位冲激信号的尺度变化:<script type="math/tex">在a\neq 0 时,\delta(at)=\frac{1}{|a|}\delta(t),\delta(at-t_0)=\frac{1}{|a|}\delta(t-\frac{t_0}{a}),\int^{\infty}_{-\infty}\delta(at-t_0)f(t)dt=\frac{1}{|a|}f(\frac{t_0}{a})</script><br>单位冲激信号与普通函数相乘:<script type="math/tex">f(t)\delta(t)=f(0)\delta(t),f(t)\delta(t-t_0)=f(0)\delta(t-t_0)</script><br>单位冲激信号的导数称作为冲击偶信号，冲击偶信号为奇函数。<br>冲击偶信号与普通信号相乘：<script type="math/tex">f(t)\delta'(t)=f(0)\delta'(t)-f'(0)\delta(t),f(t)\delta'(t-t_0)=f(0)\delta'(t-t_0)-f'(0)\delta(t-t_0)</script><br>冲击偶信号的尺度变换特性：<script type="math/tex">在a\neq 0 时,\delta'(at)=\frac{1}{a|a|}\delta'(t)</script></p><h3 id="关于系统"><a href="#关于系统" class="headerlink" title="关于系统"></a>关于系统</h3><p>信号的产生、传输和处理需要一定的物理装置，这样的物理装置常称为系统。一般而言，系统(System)是指若干相互关联的事物组合而成具有特定功能的整体。系统的基本作用是对信号进行传输和处理.<br>系统分类有很多，在此一一说明：</p><h4 id="连续系统，离散系统，混合系统"><a href="#连续系统，离散系统，混合系统" class="headerlink" title="连续系统，离散系统，混合系统"></a>连续系统，离散系统，混合系统</h4><p>连续(时间)系统：系统的激励和响应均为连续信号。<br>离散(时间)系统：系统的激励和响应均为离散信号。<br>混合系统(Hybrid Systems):系统的激励和响应一个是连续信号，一个为离散信号。如A/D，D/A变换器。</p><h4 id="动态系统与即时系统"><a href="#动态系统与即时系统" class="headerlink" title="动态系统与即时系统"></a>动态系统与即时系统</h4><p>动态系统也称为记忆系统，若系统在任一时刻的响应不仅与该时刻的激励有关，而且与它过去的历史状况有关，则称为动态系统 (Dynamic system)或记忆系统。否则称即时系统(Memoryless system)。    </p><h4 id="单输入单输出系统与多输入多输出系统"><a href="#单输入单输出系统与多输入多输出系统" class="headerlink" title="单输入单输出系统与多输入多输出系统"></a>单输入单输出系统与多输入多输出系统</h4><p>单输入单输出(SISO/single input single output)系统：系统的输入、输出信号都只有一个。<br>多输入多输出(MIMO/multi-input multi-output)系统：系统的输入、输出信号有多个。<br>注意：多个输入输出指的并不是多维输入输出的情况。</p><h4 id="线性系统与非线性系统"><a href="#线性系统与非线性系统" class="headerlink" title="线性系统与非线性系统"></a>线性系统与非线性系统</h4><p>线性系统：指满足线性性质（齐次性和可加性）的系统。<br>齐次性：f(·) →y(·) 可推出 af(·) →ay(·)<br>可加性：f1(·) →y1(·)，f2(·) →y2(·) 可推出 f1(·) +f2(·) →y1(·)+y2(·)<br>*所以线性性质可以这么写：af1(·) +bf2(·) →ay1(·)+by2(·)<br>动态系统是线性系统的条件：动态系统不仅与激励有关，也与系统的初始状态有关，初始状态也可以叫做“内部激励”。满足动态系统输出可分为零输入响应的输出以及零状态响应的和（可分解性），以及零输入响应与零状态响应均为线性时为线性系统。<br>反之则是非线性系统</p><h4 id="因果系统与非因果系统"><a href="#因果系统与非因果系统" class="headerlink" title="因果系统与非因果系统"></a>因果系统与非因果系统</h4><p>因果系统：指零状态响应不会出现在激励之前的系统。<br>比较迷的玩意，一半都是因果的。一般是没什么东西是在激励之前就出响应的。</p><h4 id="时不变系统与时变系统"><a href="#时不变系统与时变系统" class="headerlink" title="时不变系统与时变系统"></a>时不变系统与时变系统</h4><p>时不变系统：指满足时不变性质(<script type="math/tex">f(t)\to y_{zs}(t)\Rightarrow f(t-t_0)\to y_{zs}(t-t_0)</script>)的系统。时变系统反之。</p><p>这门课程主要学习LTI系统，即线性时不变系统。</p><h3 id="LTI系统分析"><a href="#LTI系统分析" class="headerlink" title="LTI系统分析"></a>LTI系统分析</h3><p>LTI连续系统的时域分析，主要是建立并求解线性微分方程，这种方法也可以称为时域分析法。比较直观，物理概念清楚，是学习各种变换域分析法的基础。 </p><h4 id="用微分方程来分析LTI系统"><a href="#用微分方程来分析LTI系统" class="headerlink" title="用微分方程来分析LTI系统"></a>用微分方程来分析LTI系统</h4><p>我们可以把一个线性系统转化为微分方程的形式，方式如下：<br><img src="/img/postpictures/sudighudfintjijdcoixzjiocxjiwkjhfgh.png" alt="根据系统框图描述建立微分方程"><br>关于解微分方程的具体方法就很老生常谈了。<br><img src="/img/postpictures/dsgfdgdfklhviosdjhfiosdmkforehjiohoj.png" alt="通过一般解和特解的方式求得"></p><p><strong>初始状态</strong>：<script type="math/tex">y(0-),y'(0-)...,y^{(n-1)}(0-)</script>反映历史信息，与激励⽆关，⼀般为已知。<br><strong>初始条件</strong>：<script type="math/tex">y(0+),y'(0+)...,y^{(n-1)}(0+)</script> 由初始状态和外加激励共同决定。<br>因为<strong>激励</strong>的加⼊，从<script type="math/tex">y^{(j)}(0-) 过渡⾄ y^{(j)}(0+)</script>时可能会产⽣跳变，即初始条件=初始状态+跳变量。<br>可以用冲击平衡法从初始状态来求初始条件：根据⽅程两边所含有的冲激函数及其各阶导数相同来判断是否跳变。</p><p>也可以分别求零输入响应以及零状态响应的方法来求得<br><img src="/img/postpictures/dsgfdhytjfgdhbfdhrtjhytjkygfhbfdg.png" alt="通过分别求零输入响应以及零状态响应的方法来求得"></p><h4 id="冲激响应与阶跃响应"><a href="#冲激响应与阶跃响应" class="headerlink" title="冲激响应与阶跃响应"></a>冲激响应与阶跃响应</h4><p>激励<script type="math/tex">e(t)=\delta(t)</script>时， 系统的零状态响应称为单位冲激响应，简称冲激响应，常⽤“<script type="math/tex">h(t)</script>”表<br>示。冲激响应<script type="math/tex">h(t)</script>反映系统特性，是后续分析涉及到的重要概念之⼀。 <script type="math/tex">e(t)=\delta(t)</script> 时⽅程右端为 及其各阶导数的线性组合，<script type="math/tex">t>0</script>时⽅程右端恒为零，故冲激响应的形式与⻬次解的形式相同。<br><img src="/img/postpictures/sadgfdfhgfdiuobvhsdiouvhncoi.png" alt=""><br>阶跃响应顾名思义就和冲击响应差不多，就是激励项变为了阶跃函数。求法和冲激响应的差不多，并且由于冲击函数通过积分可以得到阶跃函数以及LTI为线性时不变的，所以阶跃响应也可以通过冲激响应积分得到。</p><h4 id="卷积计算"><a href="#卷积计算" class="headerlink" title="卷积计算"></a>卷积计算</h4><p>定义两个函数 <script type="math/tex">f_1(t),f_2(t)</script> 的卷积为 <script type="math/tex">f_1(t)*f_2(t)=\int^{\infty}_{-\infty}f_1(\tau)f_2(t-\tau)d\tau</script>,其中 <script type="math/tex">\tau</script> 为虚设的积分变量，积分结果仍为t的时间信号。<br>运算时通过被卷积信号的类型确定积分上下限，从而简化积分运算。<br>也可以图解法求解：</p><blockquote><p>步骤⼀： <script type="math/tex">f_1(t)</script>与 <script type="math/tex">f_2(t)</script>变量置换，t变为 <script type="math/tex">\tau</script>，并将 <script type="math/tex">f_2(\tau)</script>以纵坐标为轴反折后的 <script type="math/tex">f_2(-\tau)</script>与 <script type="math/tex">f_1(\tau)</script>画在同⼀个坐标图中（横坐标为 <script type="math/tex">\tau</script>轴）。<br>步骤⼆：给定⼀个<script type="math/tex">t</script>值，将 <script type="math/tex">f_2(-\tau)</script>的波形沿 <script type="math/tex">\tau</script>轴平移，平移量为<script type="math/tex">|t|</script>，平移后的信号为 <script type="math/tex">f_2(t-\tau)</script> , <script type="math/tex">t>0</script> 时 <script type="math/tex">f_2(-\tau)</script>向右平移， <script type="math/tex">t\le 0</script>时<script type="math/tex">f_2(-\tau)</script>向左平移。<br>步骤三：将 <script type="math/tex">f_1(\tau)</script>与 <script type="math/tex">f_2(t-\tau)</script>相乘的到卷积积分的被积函数 <script type="math/tex">f_1(\tau)f_2(t-\tau)</script>。<br>步骤四：若 <script type="math/tex">f_1(\tau)</script>波形与 <script type="math/tex">f_2(t-\tau)</script>波形有重叠，则两信号的卷积积分为 <script type="math/tex">f_1(\tau)f_2(t-\tau)</script>在重叠区间的积分，若两信号的波形⽆重叠部分，则 <script type="math/tex">f_1(\tau)f_2(t-\tau)=0</script>，卷积也为零。<br>步骤五：令变量 <script type="math/tex">t</script>在 <script type="math/tex">( -\infty,\infty )</script>内变化，重复步骤2,3,4，最终得到卷积信号<script type="math/tex">f_1(t)*f_2(t)</script>。</p></blockquote><p>卷积积分的运算性质：<img src="/img/postpictures/sdgdfhngfmjhgjmhglkiyhgliug.png" alt=""><br>顺便再说一下用matlab里的conv函数来做两函数卷积图像的代码：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">t</span>=-<span class="hljs-number">3</span>:<span class="hljs-number">0</span>.<span class="hljs-number">001</span>:<span class="hljs-number">3</span>;<br><span class="hljs-attribute">t1</span> = -<span class="hljs-number">3</span> :<span class="hljs-number">0</span>.<span class="hljs-number">0005</span>:<span class="hljs-number">3</span>;<br><span class="hljs-attribute">y1</span> = stepfun(t,<span class="hljs-number">0</span>);<br><span class="hljs-attribute">y2</span> = stepfun(t,-<span class="hljs-number">1</span>) - stepfun(t,<span class="hljs-number">1</span>);<br><span class="hljs-attribute">y3</span> = t<span class="hljs-number">1</span>.* stepfun(t<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-attribute">y</span> = conv(y<span class="hljs-number">1</span>,y<span class="hljs-number">1</span>);<br><span class="hljs-attribute">l1</span> = length(y<span class="hljs-number">1</span>);   <br><span class="hljs-attribute">l2</span> = length(y<span class="hljs-number">2</span>);  <br><span class="hljs-attribute">l</span> = length(y);<br><span class="hljs-attribute">fprintf</span>(&#x27;%d&#x27;,l);<br><span class="hljs-attribute">subplot</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-attribute">plot</span>(t, y<span class="hljs-number">1</span>);<br><span class="hljs-attribute">subplot</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-attribute">plot</span>(t, y<span class="hljs-number">1</span>);<br><span class="hljs-attribute">subplot</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br><span class="hljs-attribute">plot</span>(t<span class="hljs-number">1</span>, y);<br><span class="hljs-attribute">subplot</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);<br><span class="hljs-attribute">plot</span>(t<span class="hljs-number">1</span>, y<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><br>这样子写法会产生一个问题就是，在函数边缘区域的卷积结果会由于定义域的问题产生不对的结果，如图所示：<br><img src="/img/postpictures/asdfsdchuihaxsyigycisbaucinidschiuhiu.png" alt="最下方为实际卷积函数，第三个是conv的结果"><br>可以看出，图像只在定义域一半的区间是符合实际的，这点注意。</p><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>傅里叶变换是一种将信号从时域变为频域的方法，频域里函数有一些优于时域函数的性质，用频域来解析函数可以揭示了信号内在的频率特性以及信号时间特性与其频率特性之间的密切关系，从而导出了信号的频谱带宽以及滤波、调制等重要概念</p><h4 id="正交函数集"><a href="#正交函数集" class="headerlink" title="正交函数集"></a>正交函数集</h4><p>学习傅里叶变换，首先要学习正交函数集的概念。<br><strong><em>函数正交的定义是</em></strong>：定义在<script type="math/tex">(t_1，t_2)</script>区间的 <script type="math/tex">\phi 1(t)</script> 和 <script type="math/tex">\phi 2(t)</script> 满足 <script type="math/tex">\int_{t_1}^{t_2} \phi 1(t) * \phi 2(t) = 0</script>,则称这两个函数在<script type="math/tex">(t_1，t_2)</script>区间内正交。<br><strong><em>正交函数集</em></strong>：若n个函数 <script type="math/tex">\phi_1(t) \phi_2(t) ... \phi_n(t)</script>构成的函数集中，两两在<script type="math/tex">(t_1，t_2)</script>区间之间相互均为正交函数，则称此函数集在<script type="math/tex">(t_1，t_2)</script>区间为正交函数集。<br><strong><em>完备正交函数集</em></strong>：若在一个正交函数集之外<strong>不存在</strong>一个函数 <script type="math/tex">\delta(t)</script> 使得 <script type="math/tex">\int_{t_1}^{t_2} \phi_i(t) * \delta(t) = 0</script>,呢么这个函数集就是完备正交函数集。</p><p>用线性代数的基理论来类比很容易理解这些概念，正交的函数就是两个不同的基，正交函数集就是很多不同的基组成的集合，完备正交函数基就是在当前空间里所有的基组成的集合。在线性代数里基组成了多维的向量，而在傅里叶变换中，我们需要用一个完备正交函数集来组成原函数（将原函数分解为不同集的组合）。<br>正弦函数集 <script type="math/tex">sin(n \Omega t),n=1.2.3...</script>就是一个完备正交函数集。也就是说我们可以用不同频率的正弦函数通过线性加减得到任意（连续可微）函数。<br>插一嘴，有时候可以看到使用cos函数也喊正弦，这么说是可以的，因为在频域中只要是频率相同这两个都能看作同一个变量，只不过是相位的差别。<br>（延申思考一下，一个相位）<br>这也是我们将函数从时域转到频域的方法————正弦函数集两个函数之间的不同只有频率上的不同，不同频率的正弦函数就可以代表原函数在这个频率上的分量。</p><h4 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h4><p>简单的描述起来就是：傅里叶级数是函数经过傅里叶变换之后正弦函数集的幅值大小。<br>设原函数为<script type="math/tex">f(t)</script>，傅里叶级数<script type="math/tex">F_n</script>，呢么可以得到：<script type="math/tex">f(t)=\Sigma_{n=-\infty}^{\infty}F_n e^{jn\Omega t}</script>，其中<script type="math/tex">e^{jn\Omega t}</script>就是代表的频率,这是信号频谱的指数表示方法.<br>同时也有三角表示方法，即<script type="math/tex">f(t)=\frac{a_0}{2}+\Sigma_{n=1}^{\infty}a_n cos(n\Omega t) +\Sigma_{n=1}^{\infty}b_n sin(n\Omega t)</script>.或者也可以写成：<script type="math/tex">f(t)=\frac{A_0}{2}+\Sigma_{n=1}^{\infty}A_n cos(n\Omega t +\phi_n)</script>.</p><blockquote><p>关于相位的问题，其实对于相同频率的正弦波信号，最终的相位是唯一的。因为频率相同相位不同的正弦波的叠加无论叠加多少都不会改变它的频率，最终频率的相位可以由<script type="math/tex">a_n,b_n</script>计算得到：<script type="math/tex">\phi_n=-arctan(\frac{b_n}{a_n})</script>.</p></blockquote><p><strong>周期函数展开为傅里叶级数：</strong><br><img src="/img/postpictures/safdsvvvxzcuischuibaigsyxgasuyxn.png" alt=""></p><div class="note note-success">            <p>图片里面直接有傅里叶变换计算的过程，就直接把对傅里叶变换的理解说一下。从图片来看计算傅里叶级数的过程需要乘上<script type="math/tex">e^{-jn\Omega t}</script>然后再积分，这个也可以用基理论来解释，想象一个高维向量,<script type="math/tex">(x,y,z...)</script>,假如我们想得知这个向量在x这个基上的幅度，呢我们可以将这个向量直接乘上<script type="math/tex">(1,0,0,0...)</script>得到的数值就是x基的幅值。虽然不能直接比较，但是道理可以相通，傅里叶变换中的<script type="math/tex">e^{-jn\Omega t}</script>起到的就是<script type="math/tex">(1,0,0,0...)</script>这个向量的作用：筛选出对应频率函数所对应的幅值并且把其他的基的影响变为0（用到了正交函数的性质）。个人理解的大致就是这样。</p>          </div>   <h4 id="周期信号的频谱"><a href="#周期信号的频谱" class="headerlink" title="周期信号的频谱"></a>周期信号的频谱</h4><p>频谱包括幅度谱以及相位谱，由上面可以知道，一个固定的原函数对于每一个频域的频率来说，其幅度和相位都是一定的。<br>幅度谱可以分为单边幅度谱以及双边幅度谱，单边幅值谱的每个频率所对应的幅值是该频率分量的模(即<script type="math/tex">A_n</script>)，双边幅度谱的每个频率的幅值是单边的一半（0除外），数值为<script type="math/tex">|F_n|</script>，但是双边的在<script type="math/tex">[-\infty,0]</script>也有函数图像，也就是说双边幅度谱的函数是一个关于y轴对称的函数。<br>单边相位谱每一个频率对应的数值为其相位，双边相位谱其中正半轴的图像与单边相位谱的一样，但是负半轴的图像与正半轴的图像刚好相反数，相当于以原点对称。<br><img src="/img/postpictures/dssdhuihxusaibuixniausjicjsiovufsho.png" alt="大概是这样"><br><strong>频率越大，频谱图的相邻间隔越小。</strong><br>设f(t)傅里叶变换为F(w)，若时域为实偶信号——频域为实偶函数，若时域为实奇信号——频域为纯虚奇函数。相位谱的话，实偶信号相位谱未必恒为零。其对应的频域函数虽为实函数，但是若F（w）恒为正，那相位就是0. 若有正有负，那为负的时候，相位为±π</p><h4 id="非周期信号的傅里叶变换"><a href="#非周期信号的傅里叶变换" class="headerlink" title="非周期信号的傅里叶变换"></a>非周期信号的傅里叶变换</h4><p>非周期信号的周期可以看作是无限大，其频谱的相邻谱线间隔<script type="math/tex">\Omega</script>趋近于无穷小，此时信号的频谱就是连续频谱，同时各频率分量的幅度也趋近于无穷小（仍保持一定比例关系）。因此引入频谱密度的概念：<script type="math/tex">F(j\omega)=lim_{T \to \infty}\frac{F_n}{1/T}=lim_{T \to \infty}F_n T</script></p><div class="note note-success">            <p><strong>关于傅里叶变换的过冲现象</strong><br>实际上，我们使用傅里叶变换之后获得的函数在某些地方是“无限”也无法逼近的区域，拿合成方波的来举例，所用的频率越多，合成的波越接近方波，但是在棱角处却有着一定的突起，虽然在一直变小但是一直存在，这个就是过冲现象。像方波这种有突变的波形我们用连续的正弦波是无法完全拟合的，过冲现象随着频域的扩充只会减少但是不会消失，拉格朗日当年也是举了这个例子来反驳傅里叶的成果。<br>不过，拉格朗日是从数学的角度来看待的，但是傅里叶是个物理学家，他提出傅里叶变换就是为了使得在解析分析热过程时更加方便。从使用的角度来看经过傅里叶变换后的波形在能量上与原波形没什么差别（有也是目前测量精度无法计算的程度）。在实际工程使用时可以直接运用，</p>          </div>   <script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>大学课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>大学基础课程</tag>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tensorflow学习&amp;深度学习实操(2)</title>
    <link href="/2022/04/01/Tensorflow%E5%AD%A6%E4%B9%A0%202/"/>
    <url>/2022/04/01/Tensorflow%E5%AD%A6%E4%B9%A0%202/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>投了算法岗的简历，写到了了解一些深度学习相关的内容，便复习了一下</p><h3 id="Fashion-MNIST数据集"><a href="#Fashion-MNIST数据集" class="headerlink" title="Fashion MNIST数据集"></a>Fashion MNIST数据集</h3><p>可以看作是minist的升级版，由于minist过于简单，初学者都能跑出准确率很高的模型，因此有大佬推出了Fashion MNIST数据集<br>paper 地址： <a href="https://arxiv.org/abs/1708.07747">https://arxiv.org/abs/1708.07747</a><br>GitHub地址：<a href="https://github.com/zalandoresearch/fashion-mnist">https://github.com/zalandoresearch/fashion-mnist</a><br>每张图片都是服饰的灰度图，数据格式是（60000，28，28）。其中四分之三为训练集，四分之一为测试集。<br>有很多调用的方式，tensorflow自带这一数据集，因此可以直接使用：<code>fashion_mnist = keras.datasets.fashion_mnist(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()</code></p><p>数据集不带标签，只是有0·9 9个数字，因此需要自己打上:</p><p><code>class_names = [&#39;T-shirt/top&#39;, &#39;Trouser&#39;, &#39;Pullover&#39;, &#39;Dress&#39;, &#39;Coat&#39;,&#39;Sandal&#39;, &#39;Shirt&#39;, &#39;Sneaker&#39;, &#39;Bag&#39;, &#39;Ankle boot&#39;]</code></p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>构建的模型有2层卷积层，两层全连接层<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">model = keras.Sequential([<br>    keras.layers.Conv2D(64, <span class="hljs-attribute">kernel_size</span>=2, strides=(1,1),<span class="hljs-attribute">padding</span>=<span class="hljs-string">&#x27;same&#x27;</span>, <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;relu&#x27;</span>,input_shape=(28,28,1)),<br>    keras.layers.MaxPool2D(pool_size=(2, 2),<span class="hljs-attribute">strides</span>=None,padding=&#x27;same&#x27;),<br>    keras.layers.Dropout(0.3),<br><br>    keras.layers.Conv2D(32, <span class="hljs-attribute">kernel_size</span>=3, strides=(1,1),<span class="hljs-attribute">padding</span>=<span class="hljs-string">&#x27;same&#x27;</span>, <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>    keras.layers.MaxPool2D(pool_size=(2, 2),<span class="hljs-attribute">strides</span>=None,padding=&#x27;same&#x27;),<br>    keras.layers.Dropout(0.3),<br>    keras.layers.BatchNormalization(),<br>    <br>    keras.layers.Flatten(),<br>    keras.layers.Dense(256, <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;relu&#x27;</span>),<br>    keras.layers.Dropout(0.5),<br>    keras.layers.Dense(10, <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;softmax&#x27;</span>)<br>])#构建模型<br></code></pre></td></tr></table></figure><br>*也有试过其他的结构，有个据称能做到97%准确率的网络（6层卷积4层全连接）在我机子上训练极尽死机，用了gpu服务（免费）然后由于可用ram占满训练失败，最终确立了这个结构</p><p>以及关于数据维度的问题，起初在调网络结构的时候一直提示我输入维度不对，查了之后才发现tensorflow卷积层的维度需要是四个以上，因此需要给数据补充一维（好像应该放到数据处理里）<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">train_images = tf.expand<span class="hljs-constructor">_dims(<span class="hljs-params">train_images</span>,(<span class="hljs-params">int</span>)</span><span class="hljs-number">(-1)</span>)#增加数据维度<br>test_images = tf.expand<span class="hljs-constructor">_dims(<span class="hljs-params">test_images</span>,(<span class="hljs-params">int</span>)</span><span class="hljs-number">(-1)</span>)<br></code></pre></td></tr></table></figure><br>改结构的时候加了池化层后就一直说要输入4个不能输入五个，我想他也没五维啊然后又是查半天错，最后是发现自己在第一层的卷积层的<code>input_shape</code>将维度直接写了四维<code>input_shape=(1,28,28,64)</code>，但是由于数据集是28*28一张的，所以他会自动忽略1这一维然后进行运算，但是由于运算需要至少四维所以他会自动补全一维，造成卷积层到池化层就是五维的数据。</p><p>模型的编译及训练指令：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">model.compile(<span class="hljs-attribute">optimizer</span>=<span class="hljs-string">&#x27;adam&#x27;</span>,<br>              <span class="hljs-attribute">loss</span>=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),<br>              metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])#模型编译指令<br>model.fit(train_images, train_labels, <span class="hljs-attribute">epochs</span>=10,batch_size=1000, <span class="hljs-attribute">validation_split</span>=0.2, <span class="hljs-attribute">verbose</span>=1)#模型训练指令<br>test_loss, test_acc = model.evaluate(test_images,  test_labels, <span class="hljs-attribute">verbose</span>=2)<br></code></pre></td></tr></table></figure><br>输出测试集的准确率以及存下模型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;\nTest accuracy:&#x27;</span>, test_acc)</span></span><br><span class="hljs-selector-id">#checkpoint_path</span> = <span class="hljs-string">&quot;E:/file/tensorflow file/model.ckptt&quot;</span><br>model<span class="hljs-selector-class">.save</span>(<span class="hljs-string">&#x27;E:/file/tensorflow file/model.ckptt&#x27;</span>)<br></code></pre></td></tr></table></figure><br>需要的时候直接导出进行训练或者直接预测<code>model = tf.keras.models.load_model(&#39;E:/file/tensorflow file/model.ckptt&#39;)</code><br>预测并作图：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>probability_model = tf<span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.Sequential</span>(<span class="hljs-selector-attr">[model,tf.keras.layers.Softmax()]</span>)<br>predictions = probability_model<span class="hljs-selector-class">.predict</span>(test_images)<br>test_loss, test_acc = model<span class="hljs-selector-class">.evaluate</span>(test_images,  test_labels, verbose=<span class="hljs-number">2</span>)<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;\nTest accuracy:&#x27;</span>, test_acc)</span></span><br><br>num_rows = <span class="hljs-number">5</span><br>num_cols = <span class="hljs-number">3</span><br>num_images = num_rows*num_cols<br>plt<span class="hljs-selector-class">.figure</span>(figsize=(<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*num_cols, <span class="hljs-number">2</span>*num_rows))<br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> range(num_images):<br>  plt<span class="hljs-selector-class">.subplot</span>(num_rows, <span class="hljs-number">2</span>*num_cols, <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>)<br>  plot_image(<span class="hljs-selector-tag">i</span>, predictions<span class="hljs-selector-attr">[i]</span>, test_labels, test_images)<br>  plt<span class="hljs-selector-class">.subplot</span>(num_rows, <span class="hljs-number">2</span>*num_cols, <span class="hljs-number">2</span>*i+<span class="hljs-number">2</span>)<br>  plot_value_array(<span class="hljs-selector-tag">i</span>, predictions<span class="hljs-selector-attr">[i]</span>, test_labels)<br>plt<span class="hljs-selector-class">.tight_layout</span>()<br>plt<span class="hljs-selector-class">.show</span>()<br></code></pre></td></tr></table></figure><br>关于作图由我直接用的官网上的代码，放在了<code>pltshow.py</code>里，需要用的时候直接导入就行<code>from pltshow import plot_image,plot_value_array</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>class_names = [<span class="hljs-string">&#x27;T-shirt/top&#x27;</span>, <span class="hljs-string">&#x27;Trouser&#x27;</span>, <span class="hljs-string">&#x27;Pullover&#x27;</span>, <span class="hljs-string">&#x27;Dress&#x27;</span>, <span class="hljs-string">&#x27;Coat&#x27;</span>,<span class="hljs-string">&#x27;Sandal&#x27;</span>, <span class="hljs-string">&#x27;Shirt&#x27;</span>, <span class="hljs-string">&#x27;Sneaker&#x27;</span>, <span class="hljs-string">&#x27;Bag&#x27;</span>, <span class="hljs-string">&#x27;Ankle boot&#x27;</span>]<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_image</span>(<span class="hljs-params">i, predictions_array, true_label, img</span>):</span><br>  predictions_array, true_label, img = predictions_array, true_label[i], img[i]<br>  plt.grid(<span class="hljs-literal">False</span>)<br>  plt.xticks([])<br>  plt.yticks([])<br><br>  plt.imshow(img, cmap=plt.cm.binary)<br><br>  predicted_label = np.argmax(predictions_array)<br>  <span class="hljs-keyword">if</span> predicted_label == true_label:<br>    color = <span class="hljs-string">&#x27;blue&#x27;</span><br>  <span class="hljs-keyword">else</span>:<br>    color = <span class="hljs-string">&#x27;red&#x27;</span><br><br>  plt.xlabel(<span class="hljs-string">&quot;&#123;&#125; &#123;:2.0f&#125;% (&#123;&#125;)&quot;</span>.<span class="hljs-built_in">format</span>(class_names[predicted_label],<br>                                <span class="hljs-number">100</span>*np.<span class="hljs-built_in">max</span>(predictions_array),<br>                                class_names[true_label]),<br>                                color=color)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_value_array</span>(<span class="hljs-params">i, predictions_array, true_label</span>):</span><br>  predictions_array, true_label = predictions_array, true_label[i]<br>  plt.grid(<span class="hljs-literal">False</span>)<br>  plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br>  plt.yticks([])<br>  thisplot = plt.bar(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>), predictions_array, color=<span class="hljs-string">&quot;#777777&quot;</span>)<br>  plt.ylim([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>])<br>  predicted_label = np.argmax(predictions_array)<br><br>  thisplot[predicted_label].set_color(<span class="hljs-string">&#x27;red&#x27;</span>)<br>  thisplot[true_label].set_color(<span class="hljs-string">&#x27;blue&#x27;</span>)<br><br></code></pre></td></tr></table></figure><br>训练许久之后最终模型的准确率达到了92.9%,大概就是这样<br><img src="/img/ergerhrtjyufcsbfeg4ethtdhbfdggs.png" alt="结果如图"><br>这是我的<a href="https://github.com/Linzeyin/Fsah-Mnist-model">模型以及其他文件</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>python</tag>
      
      <tag>tensorflow</tag>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电磁场与电磁波</title>
    <link href="/2022/03/31/%E7%94%B5%E7%A3%81%E5%9C%BA%E4%B8%8E%E7%94%B5%E7%A3%81%E6%B3%A2/"/>
    <url>/2022/03/31/%E7%94%B5%E7%A3%81%E5%9C%BA%E4%B8%8E%E7%94%B5%E7%A3%81%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>电磁场与电磁波这门课程，主体是大量的公式推导计算，从而去理解电磁学的整个体系框架，因此在此记录主要为各方程。</p><h3 id="矢量分析"><a href="#矢量分析" class="headerlink" title="矢量分析"></a>矢量分析</h3><p>主体还是高数的那些内容。<br>首先是三种常用正交坐标系：</p><h4 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h4><p><strong>直角坐标系</strong>：直观理解，在此不过多阐述。<br><strong>圆柱坐标系</strong>：圆柱坐标系的三个坐标分量为$ r,\varphi,z $ , 他们的变化范围分别是：<script type="math/tex">0 \leq r < \infty , 0 \leq \varphi \leq 2\pi,-\infty < z < \infty</script>.<br>圆柱坐标系和直角坐标系之间的变换关系是:  <script type="math/tex">r=\sqrt{ x^2+y^2},tan\varphi = \frac{y}{x} ,z=z</script><br>或者是：<script type="math/tex">x=rcos\varphi ,y=rsin\varphi, z=z</script>.<br>圆柱坐标系的三个单位矢量也相互正交（两两点乘为0，叉乘为第三个单位向量）<br>注意，单位矢量中 <script type="math/tex">e_r,e_{\varphi}</script> 的不是常矢量，它们的方向随位置的变化而变化。<br>圆柱坐标系的微分线元为： <script type="math/tex">\frac{de_r}{d\varphi}=-e_x sin\varphi +e_y  cos\varphi = e_{\varphi} ,  \quad \quad \frac{de_{\varphi}}{d\varphi}=-e_x cos\varphi - e_y  sin\varphi = -e_r</script></p><script type="math/tex; mode=display">dr=e_r dr+e_zdz+e_\varphi r d\varphi</script><p>体积元为 <script type="math/tex">dV=rdrd\varphi dz</script></p><p><strong>球坐标系</strong>：球系的三个坐标分量为$ r,\varphi,\theta $ , 他们的变化范围分别是：<script type="math/tex">0 \leq r < \infty , 0 \leq \varphi \leq 2\pi, 0 \leq \theta \leq \pi</script>.<br>球坐标系和直角坐标系之间的变换关系是: <script type="math/tex">r=\sqrt{ x^2+y^2+z^2},tan\varphi = \frac{y}{x} ,tan \theta =\frac{x^2+y^2}{z}</script><br>或者是：<script type="math/tex">x=rcos\varphi ,y=rsin\varphi, z=rcos\theta</script>.<br>球坐标系的三个单位矢量也相互正交（两两点乘为0，叉乘为第三个单位向量）<br>注意，球坐标系的三个单位矢量不是常矢量，它们的方向随位置的变化而变化。<br>圆柱坐标系的微分线元为： <script type="math/tex">dr=e_r dr+e_{\theta}rd\theta +e_\varphi r sin\theta d\varphi</script><br>体积元为 <script type="math/tex">dV=r^2 sin\theta dr d\theta d\varphi</script></p><blockquote><p>建议认真推一遍，笔者在重推的过程中处理了不少高等数学的历史遗留问题。</p></blockquote><h4 id="矢量的微分"><a href="#矢量的微分" class="headerlink" title="矢量的微分"></a>矢量的微分</h4><p>矢量可以看作是各个方向上的函数的线性组合，求矢量场的微分相当于在求各个方向不同自变量的偏微分。</p><h5 id="散度-amp-旋度-amp-梯度"><a href="#散度-amp-旋度-amp-梯度" class="headerlink" title="散度&amp;旋度&amp;梯度"></a>散度&amp;旋度&amp;梯度</h5><p>由于数学包的问题，环路积分符号无法敲出，之后会用图片代替。<br><img src="/img/postpictures/isdjgviojrieghniernmiojfuhsdfuhuish.jpg" alt=""></p><h5 id="亥姆霍兹定理"><a href="#亥姆霍兹定理" class="headerlink" title="亥姆霍兹定理"></a>亥姆霍兹定理</h5><p>一个矢量场可以表示为一个无旋的散度场和一个无散的旋度场的叠加，该种方式是<strong>唯一的</strong>，即：<script type="math/tex">F(r)= - \bigtriangledown \phi (r) + \bigtriangledown \times A(r)</script><br>其中 <script type="math/tex">\phi(r) = \frac{1}{4 \pi } \int_{v'} \frac{ \bigtriangledown ' \dot F(r')}{|r-r'|} \quad \quad  A(r) = \frac{1}{4 \pi } \int_{v'} \frac{ \bigtriangledown ' \times F(r')}{|r-r'|}</script><br>其中|r-r’|为源点(r)到场点(r’)的距离，算子 <script type="math/tex">\bigtriangledown '=e_x \frac{\partial}{\partial x'} +e_y \frac{\partial}{\partial y'} +e_z \frac{\partial}{\partial z'}</script><br>是对源点坐标微分，积分也是对原点坐标积分</p><h3 id="静电场分析"><a href="#静电场分析" class="headerlink" title="静电场分析"></a>静电场分析</h3><h4 id="电荷与电荷分布"><a href="#电荷与电荷分布" class="headerlink" title="电荷与电荷分布"></a>电荷与电荷分布</h4><p><strong>体电荷密度</strong>：当电荷在某一空间体积连续分布时，用体电荷密度来描述电荷在空间中的分布特性，体电荷密度定义为空间某点处单位体积中的电荷量，即<script type="math/tex">\rho(r)=lim_{\Delta V \to 0} \frac{\Delta q}{\Delta V}</script><br>通过体积分可以求出某个体积V中总的电量，即<script type="math/tex">q=\iiint_V \rho(r)dV</script><br><strong>面电荷密度</strong>：可以将电荷在一个极薄的薄层空间中的连续分布视为面电荷分布，用面电荷密度来描述面电荷的分布特性，面电荷密度定义为某点处单位面积中的电荷量，即<script type="math/tex">\rho s(r)=lim_{\Delta S \to 0} \frac{\Delta q}{\Delta S}</script><br>通过面积分可以求出某个曲面S中总的电量，即<script type="math/tex">q=\iint_V \rho(r)dS</script><br><strong>线电荷密度</strong>：将电荷在半径极小的管型空间中的分布视为线电荷分布，用线电荷密度来描述线电荷的分布特性，线电荷密度定义为某点处单位长度中的电荷量，即<script type="math/tex">\rho l(r)=lim_{\Delta l \to 0} \frac{\Delta q}{\Delta l}</script><br>通过面线积分可以求出某条曲线S中总的电量，即<script type="math/tex">q=\int_V \rho(r)dl</script><br><strong>点电荷与点电荷的 <script type="math/tex">\delta</script> 函数表示法</strong> ：点电荷为电磁场理论中的一个理想模型，点电荷的电量为q，占据的体积为趋近为0的一个几何点。显然，点电荷所在的体电荷密度趋近于无穷大，为了定量描述点电荷的分布，定义 <script type="math/tex">\delta</script> 函数 <script type="math/tex">\delta (r-r')= \begin{cases}  0 \quad \quad r \ne r' \\\\ \infty \quad \quad r =r' \end{cases}</script></p><script type="math/tex; mode=display">\iiint_V \delta (r-r')dV= \begin{cases}  0 \quad \quad r'不在V内 \\\\ \infty \quad \quad r'在V内 \end{cases}</script><p>可以用 <script type="math/tex">\delta</script> 函数表示点电荷的体电荷密度 <script type="math/tex">\rho(r)=q\delta (r-r')= \begin{cases}  0 \quad \quad r \ne r' \\\\ \infty \quad \quad r =r' \end{cases}</script><br>对于点电荷，空间任意体积V中总的电量Q可以得到<script type="math/tex">Q=\iiint_V \rho(r)dV = q\iiint_V \delta (r-r')dV= \begin{cases}  0 \quad \quad r'不在V内 \\\\ q \quad \quad r'在V内 \end{cases}</script></p><h4 id="场强E与电位-Phi"><a href="#场强E与电位-Phi" class="headerlink" title="场强E与电位\Phi"></a>场强E与电位<script type="math/tex">\Phi</script></h4><p>场强E与电位<script type="math/tex">\Phi</script>是研究电磁场基础的两个物理量<br>定义式分别为<script type="math/tex">\begin{cases}  E(r)=\frac{F(r)}{q_0} \quad 空间某点场强 \\\\ \Phi(r)=\int_P^Q E \cdot dl \quad 空间某点电位 \end{cases}</script><br>场强E与电位<script type="math/tex">\Phi</script>之间相互转换：<script type="math/tex">\begin{cases}  E(r)=-\bigtriangledown \Phi (r) \\\\ \Phi(r)=\int_P^Q E \cdot dl  \end{cases}</script><br>由真空中两个静止的点电荷之间的相互作用力<script type="math/tex">F=\frac{1}{4\pi \epsilon_0 }\frac{q1q2}{r^2}e_r</script>可推出<script type="math/tex">E=\frac{1}{4\pi \epsilon_0 }\frac{q1}{r^2}e_r</script><br>以及点电荷电位：<script type="math/tex">\Phi(r)= \frac{1}{4\pi \epsilon_0} \frac{q(r')}{R}</script></p><h4 id="静电场基本方程"><a href="#静电场基本方程" class="headerlink" title="静电场基本方程"></a>静电场基本方程</h4><p>同 见图片</p><h4 id="静电场中的导体"><a href="#静电场中的导体" class="headerlink" title="静电场中的导体"></a>静电场中的导体</h4><blockquote><p>静电场中导体内场强处处为0<br>导体是等位体，导体的表面为等位面<br>导体内无电荷分布，电荷只分布在导体表面.孤立导体表面的电荷分布与曲率有关。曲率较大（凸出且尖锐）的地方面电荷密度较大，曲率较小（平坦）的地方，面电荷密度也较小，曲率为负值（凹进去）的地方，面电荷密度更小。<br>导体表面附近，电场强度的方向与表面垂直。电场强度的大小等于该点附近导体表面的面电荷密度除以真空中介电常数，所以导体表面附近的电场强度为<script type="math/tex">E=\hat{n} \frac{\rho s}{\epsilon_0}</script>,其中<script type="math/tex">\hat{n}</script>为导体表 面处的单位法线向量，可以用高斯定理证明。</p></blockquote><h4 id="电介质"><a href="#电介质" class="headerlink" title="电介质"></a>电介质</h4><p>分为线性与非线性介质，各向同性与各向异性介质，均匀介质与非均匀介质。<br>线性介质指介质的性质是线性的，比如随着温度的升高，声速等比例增长。（可能是在一定范围内的近似）<br>各向同性，指各各方向上性质相同，比如空气中的声速朝各方向都相同。而不是在水平方向和竖直方向不同。<br>均匀介质是指介质在一定范围内是均匀的，而不是一些地方疏、一些地方密。<br><strong>这三种性质相似，可以同时存在，但互不相同，相互独立。</strong><br>主要学习的是线性，各向同性，均匀介质中电场的特性，满足有关系<script type="math/tex">P=\epsilon_0 \chi_e E \quad \quad D=\epsilon_0 \epsilon_r E \quad \quad \epsilon_r =1+\chi_e</script><br>P为极化强度。<script type="math/tex">\chi_e</script>为电介质的磁化率（比例系数），对于线性介质与E无关。</p><h4 id="高斯定理"><a href="#高斯定理" class="headerlink" title="高斯定理"></a>高斯定理</h4><p>真空中静电场穿过任一闭合曲面的电场强度通量等于该曲面所包围的所有电荷的代数和除以<script type="math/tex">/epsilon_0</script>。<br>注：高斯面为闭合曲面，说明了通过整个闭合回路的电场强度只与闭合曲面内部电荷有关。<strong>而曲面上任意一点电场强度不仅与曲面内部电荷有关，还与曲面外部电荷有关</strong>。同时还说明了电场为有源场。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>大学课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>大学基础课程</tag>
      
      <tag>电磁场与电磁波</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python小工具</title>
    <link href="/2022/03/15/python%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/03/15/python%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="excal数据拟合并作图"><a href="#excal数据拟合并作图" class="headerlink" title="excal数据拟合并作图"></a>excal数据拟合并作图</h3><p>可以用多项式拟合excal中的数据并直接作网格图<br><img src="/img/postpictures/dsgtrfgjhytkujhfmxfghnbfdggb.png" alt="大概是这样"><br><a href="/file/download/python_excal_date_painting.zip">样例</a>用了大物实验的数据，作了三次图<br>自行修改使用</p><h3 id="浏览单词记录发至邮箱"><a href="#浏览单词记录发至邮箱" class="headerlink" title="浏览单词记录发至邮箱"></a>浏览单词记录发至邮箱</h3><p>读取了浏览器的历史记录并检查是否用了翻译，存储单词到csv中再email<br><img src="/img/postpictures/khivorejihontronmkodcznuhc.png" alt="效果如图"><br>email的话需要邮箱以及凭证，有点麻烦</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>数学建模</tag>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2022/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>计算机网络的各层集齐协议的集合就是计算机网络的体系结构。计算机网络的体系结构就是这个计算机网络及其构件所应完成的功能的精确定义。<br>标准的体系结构为OSI的七层协议。OSI体系理论完整但是较为复杂。主流使用的是TCP/IP体系结构。<br><img src="/img/postpictures/sdgtrejhytkjyukghfjfgsdaf.jpg" alt="关于OSI于TCP/IP体系的对比"><br>实质上来讲TCP/IP体系的体系结构主要是在网络层，运输层，应用层。再往下的数据链路层以及物理层没什么具体的内容（就是硬件从业人员要搞的了，不对，我好像就是硬件人员. . .）</p><h2 id="TCP-IP体系结构"><a href="#TCP-IP体系结构" class="headerlink" title="TCP/IP体系结构"></a>TCP/IP体系结构</h2><p><img src="/img/postpictures/dfgtrhytrjusftgasdfweretewtretyg.jpg" alt=""><br>按照从底往上的顺序讲解</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><p>网络中的可靠传输一般分为三种方法。</p><h6 id="停止-等待协议（SW）"><a href="#停止-等待协议（SW）" class="headerlink" title="停止-等待协议（SW）"></a>停止-等待协议（SW）</h6><p>发送端发送数据，之后进入等待区间，在等待区间内若是收到接收端返回的确认报表则继续发下一帧数据。若是等待区间结束仍未接收到返回的确认报表则重新发送数据，知道收到确认报表为止。接收端若是收到数据就会发送确认报表，若是发现下一次发来的数据仍是上次的数据则可认定是确认报表丢失或未在等待时间内到达发送端，则会继续发送确认报表直到发来新的数据。<br>简单，十分可靠，保证了不丢包，但是信道利用率较低，延时较长。<br><img src="/img/postpictures/dfhbsrtgjyukiuljhhmnfgcbxdfhbfd.jpg" alt=""></p><h6 id="后退n帧协议（GBN）"><a href="#后退n帧协议（GBN）" class="headerlink" title="后退n帧协议（GBN）"></a>后退n帧协议（GBN）</h6><p>对帧进行编号，一次性发送多个帧（W），若是收到接收端发送的收到确认，滑动发送窗口。接收端接收时接受多个帧后发送一次确认报表，若是收到错误帧则丢弃，并发送重复之前的确认报表。发送端收到重复的确认报表就会发起重传，由具体实现而定。<br>相比于停止-等待协议，信道利用率大大增加。发送方在收到确认之前会发送多个数据帧。<br>不过，当通信线路质量不好的时候回退N帧协议并不比停止等待协议的信道利用率高。<br><img src="/img/postpictures/asfdsgtrjuytcvbcvxhtreewsdfmjyh.jpg" alt=""></p><p>学习来源于<a href="https://zhuanlan.zhihu.com/p/405573476">这里</a></p><h6 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h6><h5 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h5><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="ARP-RARP协议"><a href="#ARP-RARP协议" class="headerlink" title="ARP/RARP协议"></a>ARP/RARP协议</h4><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP协议是TCP/IP协议栈中最核心的协议之一，通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。它提供了无连接的数据传输服务，主要功能有路由选择、寻址、分段以及组装。上层的数据报文在传输层分成了若干个数据包，每一个数据包首先在源头的网关上进行路由匹配，然后一跳跳地穿越若干个设备（每个传输节点都需经历物理层，数据链路层，网络层三层），最终送到目标主机。数据包在传输的过程中，由于物理层最大传输单元长度的要求会被切割成若干小段，每一个小段都包含有完整的IP报文头部，但其中只有第一个小段包含了TCP头部。在穿越包过滤防火墙时，由于后续小段不包含TCP头部，将无法通过检测，在穿越状态检测防火墙时，则可以被检测通过。<br>IP协议接收来自更底层发来的数据包，然后把数据包传递给更高的一层TCP层(传输层)。同样，IP层也会接收来自TCP层的数据包，并传递给更底层。由于IP协议是无连接的，无法确认数据是否有丢失或破损。</p><div class="note note-success">            <p>IP协议只能指明数据包的源通信方，<strong>但无法保证数据一定能传输到目标地址</strong></p>          </div><h5 id="IP头"><a href="#IP头" class="headerlink" title="IP头"></a>IP头</h5><p>由于历史因素，目前IPv4仍有相当数量的网络在使用，因此于此将IPv4及IPv6的IP头均记下。<br><img src="/img/postpictures/dsgfdvjiodvjiocmokmdskocmopwefko.jpg" alt="IPv4数据报"></p><blockquote><p>(1) 版本号：IP协议的版本。对于IPv4来说值是4<br>(2) 头部长度(IHL)：4位最大为0xF，注意该字段表示单位是字(4字节)<br>(3) 服务类型(Type Of Service)：该字段指定路由器在传送过程中如何处理数据报文，也即表示这个数据报文在由IPv4 网络中的路由器转发时所期待的服务。这个字段长度为8位。这个字段也可以解释为区分业务编码点（Differentiated Services Codepoints, DSCP)。RFC2474 提供了关于 DSCP 的详细定义。<br>(4) 总长度: 指整个IP数据报的长度，单位为字节，即IP数据报的最大长度为65535字节(长度为16)。由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP分片数据报的长度远没有达到最大值<br>(5)(6)(7)3个字段则描述如何实现分片:<br>(5) 标识：唯一地标识主机发送的每一个数据报，其初始值是随机的，每发送一个数据报其值就加1。同一个数据报的所有分片都具有相同的标识值<br>(6)标志: 位1保留，位2表禁止分片，若设置了此位IP模块将不对数据报进行分片，在此情况下若IP数据报超过MTU，IP模块将丢弃数据报并返回一个ICMP差错报文；位3标识更多分片(MF)，除了数据报的最后一个分片，其他分片都要把它设置为1<br>(7) 位偏移：分片相对原始IP数据报数据部分的偏移。实际的偏移值为该值左移3位后得到的，所以除了最后一个IP数据报分片外，每个IP分片的数据部分的长度都必须是8的整数倍<br>(8) 生存时间:数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置，常设置为64。数据报在转发过程中每经过一个路由该值就被路由器减1.当TTL值为0时，路由器就将该数据包丢弃，并向源端发送一个ICMP差错报文。TTL可以防止数据报陷入路由循环<br>(9) 协议: 区分IP协议上的上层协议。在Linux系统的/etc/protocols文件中定义了所有上层协议对应的协议字段，ICMP为1，TCP为6，UDP为17<br>(10) 头部校验和： 由发送端填充接收端对其使用CRC算法校验，检查IP数据报头部在传输过程中是否损坏<br>(11) 源IP地址和目的IP地址: 表示数据报的发送端和接收端。一般情况下这两个地址在整个数据报传递过程中保持不变，不论中间经过多少个路由器<br>(12) 选项：可变长的可选信息，最多包含40字节。选项字段很少被使用。可用的IP可选项有：<br>  a. 记录路由: 记录数据包途径的所有路由的IP，这样可以追踪数据包的传递路径<br>  b. 时间戳: 记录每个路由器数据报被转发的时间或者时间与IP地址对，这样就可以测量途径路由之间数据报的传输的时间<br>  c. 松散路由选择: 指定路由器的IP地址列表数据发送过程中必须经过所有的路由器<br>  d. 严格路由选择: 数据包只能经过被指定的IP地址列表的路由器<br>  e. 上层协议(如TCP/UDP)的头部信息</p></blockquote><p><img src="/img/postpictures/dsvmomdsopkptiojidwhendunxlasmxlk.jpg" alt="IPv6数据报"></p><blockquote><p>版本：版本字段用来表示IP数据报使用的是IPv6协议封装，占4位，对应值为6（0110）。<br>通信分类（Traffic Class）：通信分类字段用来标识对应IPv6的通信流类别，或者说是优先级别，占8位，类似于IPv4中的ToS（服务类型）字段。<br>流标签（Flow Label）：流标签字段时IPv6数据报中新增的一个字段，占20位，可用来标记报文的数据流类型，以便在网络层区分不同的报文。流标签字段有源节点分配，通过流标签、源地址、目的地址三元组方式就可以唯一标识一条通信流，而不用像IPv4那样需要使用五元组方式（源地址、目的地址、源端口、目的端口和传输层协议号）。这样发动的最大好处有两点：一是流标签可以和任意的关联，需要标识不同类型的流（可以是非五元组）时，无需对流标签做改动；二是流标签在IPv6基本头中，使用IPSec时此域对转发路由器可见，因此转发路由器可以在使用IPv6报文IPSec的情况下仍然可以通过三元组（流标签、源地址、目的地址）针对特定的流进行QoS（质量服务）处理。<br>有效载荷长度（PayLoad Length）：有效载荷长度字段是以字节为单位的标识IPv6数据报中有效载荷部分（包括所有扩展报头部分）的总长度，也就是除了IPv6的基本报头以外的其他部分的总长度，占20位。<br>下一个头部（Next Header）：下一个头部字段用来标识当前报头（或者扩展报头）的下一个头部类型，占8位。每种扩展报头都有其对应的值。下一个头部字段内定义的扩展报头类型与IPv4中的协议字段值类似，但在IPv6数据报中，紧接着IPv6报头的可能不是上层协议头部（当没有扩展报头或者为最后一个扩展报头时才是上层协议头），而是IPv6扩展报头。这一机制下处理扩展报头更搞笑，因为标识了数据报中对应的上层协议或者扩展报头类型，转发路由器只需处理必须处理的扩展报头，提高了转发效率。<br>跳数限制（Hop Limit）：跳数限制于IPv4报文中的TTL字段类似，指定了报文可以有效转发的次数，占8位。报文每经过一个路由器结点，跳数值就减1，当此字段值减到0时，则直接丢弃该报文。<br>源地址（Source IP Address）：源IP地址字段标识了发送该IPv6报文源节点的IPv6地址，占128位。<br>目的IP地址（Destination IP Address）：目的IP地址字段标识了IPv6报文的接受节点的IPv6地址，占128位。</p></blockquote><p>IPv6扩展报头：在各字段介绍中我们讲到了，IPv6报文中可以携带可选的IPv6扩展报头。IPv6扩展报头是跟在IPv6基本报头后面的可选报头。由于在IPv4的报头中包含了几乎所有的可选项，因此每个中间路由器都必须检查这些选项是否存在。在IPv6中，这些相关选项被统一移到了扩展报头中，这样中间路由器不必处理每一个可能出现的选项（仅有“逐跳选项”报头是必须要处理的），提高了处理器处理数据报文的速度，也提高了其转发的性能。<br>IPv6扩展报头附加在IPv6报头目的IP地址字段后面，可以有0个，或者多个扩展报头。主要的IPv6扩展报头有一下几类：</p><blockquote><p>逐跳选项头（Hop-by-hop Options Header）:本扩展报头类型值为0（在IPv6报头下一个头部字段中定义，下同）。此扩展报头须被转发路径所有节点处理。目前在路由告警（RSVP和MLDv1）与Jumbo帧处理中使用了逐跳选项头，因为路由告警需要通知到转发路径中所有结点，而Jumbo帧是长度超过65535字节的报文，传输这种报文需要转发路径中所有结点都能正常处理。<br>目的选项头（Destination Options Header）:本扩展报头类型值为60。只可能出现在两个位置：</p><ol><li>路由头前，这是此选项头被目的节点和路由头中指定的结点处理；</li><li>上层头前（任何的ESP头后），此时只能被目的结点处理。</li></ol><p>移动IPv6中使用了目的选项头，称为家乡地址选项。家乡地址选项由目的选项头携带，用以移动结点离开“家乡”后通知接受节点此移动结点对应的家乡地址。接受节点收到带有家乡地址选项的报文后，会把家乡地址选项中的源地址（移动节点的家乡地址）和报文中源地址（移动节点的转交地址）交换，这样上层协议始终认为是在和移动节点的家乡地址通信，实现了移动漫游功能。<br>路由头（Routing Header）：本扩展报头类型值为43，用于源路由选项和移动IPv6<br>分段头：本扩展报头类型值为44，用于标识数据报的分段，在IPv4中就有对应的字段。当源节点发送的报文超过传输链路MTU（源节点和目的节点之间传输路径的MTU）时，需要对报文进行分段时使用。<br>认证头：本扩展报头类型值为51，用于IPSec，提供报文验证，完整性检查。<br>封装安全有效载荷头：本扩展头类型值为50，用于IPSec，提供报文验证、完整性检查差和加密。<br>上层头：这是用来标识数据报中上层协议类型，如TCP、UDP、ICMP等。</p></blockquote><hr><h3 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h3><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>传输控制协议TCP，提供了面向连接的，可靠的数据传输服务。<br>面向连接是指程序在使用TCP协议之前必须先建立TCP链接，在传输完数据后要释放连接。<br>TCP链接只能有两个端点，因此每一条TCP的链接为点对点的。<br>TCP协议提供<strong>全双工通信</strong>，允许通信的双方在任何时候都能发送数据。TCP链接的两端都设置有发送和接收缓存。可供应用程序随时取用。<br>TCP是面向字节流的，上层应用程序传给它的所有数据仅作为无结构的字节流，并不知道传送数据实际的含义。传输是会将字节流分为数据块传输，<strong>发送端输出的数据块和接收端向上层应用发送的数据块可以不一样，但是要保证上层应用向发送端输出的字节流和接收端向上层应用发送的字节流完全一样。</strong><br><img src="/img/postpictures/hfudvodsjvjdscomdsicdshcuis.jpg" alt="TCP传输数据的组成"><br><div class="note note-success">            <p><strong>各个段位说明</strong><br><strong>源端口和目的端口</strong>:各占2字节.端口是传输层与应用层的服务接口.传输层的复用和分用功能都要通过端口才能实现<br><strong>序号</strong>:占 4 字节.TCP 连接中传送的数据流中的每一个字节都编上一个序号.序号字段的值则指的是本报文段所发送的数据的第一个字节的序号<br><strong>确认号</strong>:占 4 字节,是期望收到对方的下一个报文段的数据的第一个字节的序号<br><strong>数据偏移/首部长度</strong>:　　占 4 位,它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远.“数据偏移”的单位是 32 位字(以 4 字节为计算单位)<br><strong>保留</strong>:　　占 6 位,保留为今后使用,但目前应置为 0<br><strong>紧急URG</strong>:　　当 URG=1 时,表明紧急指针字段有效.它告诉系统此报文段中有紧急数据,应尽快传送(相当于高优先级的数据)<br><strong>确认ACK</strong>:　　只有当 ACK=1 时确认号字段才有效.当 ACK=0 时,确认号无效<br><strong>PSH(PuSH)</strong>:　　接收 TCP 收到 PSH = 1 的报文段,就尽快地交付接收应用进程,而不再等到整个缓存都填满了后再向上交付<br><strong>RST (ReSeT)</strong>:　　当 RST=1 时,表明 TCP 连接中出现严重差错(如由于主机崩溃或其他原因),必须释放连接,然后再重新建立运输连接<br><strong>同步 SYN</strong>:　　同步 SYN = 1 表示这是一个连接请求或连接接受报文<br><strong>终止 FIN</strong>:　　用来释放一个连接.FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接<br><strong>检验和</strong>:　　占 2 字节.检验和字段检验的范围包括首部和数据这两部分.在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部<br><strong>紧急指针</strong>:　　占 16 位,指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)<br><strong>选项</strong>:　　长度可变.TCP 最初只规定了一种选项,即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]<br><strong>填充</strong>:　　这是为了使整个首部长度是 4 字节的整数倍</p><p><strong>窗口扩大</strong>:　　占 3 字节,其中有一个字节表示移位值 S.新的窗口值等于TCP 首部中的窗口位数增大到(16 + S),相当于把窗口值向左移动 S 位后获得实际的窗口大小<br><strong>时间戳</strong>:　　占10 字节,其中最主要的字段时间戳值字段(4字节)和时间戳回送回答字段(4字节)<br><strong>选择确认</strong>:　　接收方收到了和前面的字节流不连续的两2字节.如果这些字节的序号都在接收窗口之内,那么接收方就先收下这些数据,但要把这些信息准确地告诉发送方,使发送方不要再重复发送这些已收到的数据</p>          </div></p><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>TCP建立连接的过程通常被称为三次握手，因为主要步骤有三步。</p><blockquote><p>第一次握手：请求端通过向服务器发送一个含有同步序列号的标志位的数据段请求建立连接，通过这个数据段，服务器可以了解到是请求端想要和你通信；以及可以用哪个序列号作为起始数据段来回应请求端。</p><p>第二次握手：服务器收到请求端的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应请求端，请求端收到数据段后就可以知道服务器已经收到请求，可以传输数据；以及需要使用那个序列号作为起始数据段来回应服务器。</p><p>第三次握手：请求端收到这个数据段后，再发送一个确认应答，确认已收到服务器的数据段，表明已收到回复，要开始传输实际数据了，这样3次握手就完成了，请求端和服务器就可以传输数据了。</p></blockquote><h5 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h5><div class="note note-success">            <p><strong>如何处理丢包问题</strong><br>发送端会首先将数据送到发送缓冲中，<br>TCP协议发送端发送时会在数据头中加入序列号以及本次发送数据的长度。接收端接收到后会返回ACK=序列号+长度 即下一段数据的起始位置。这样发送端就可以知道接收端已经接收到的位置，接收端也可以重构数据。若有丢包问题，则接收端不会返回新的起始位置，会要求发送端重传，达到不丢包的效果。<br>注意“TCP 标准没有规定对不按序到达的数据应如何处理.通常是先临时存放在接收窗口中,等到字节流中所缺少的字节收到后,再按序交付上层的应用进程</p>          </div><h5 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h5><p>断开连接有四个步骤</p><blockquote><p>第一次： 当请求端完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；</p><p>第二次： 服务器收到FIN后对其作出响应，确认来自该请求端上的TCP连接将关闭,将ACK置1；</p><p>第三次： 由服务器端再提出反方向的关闭请求,将FIN置1 ；</p><p>第四次： 请求端对服务器的请求进行确认，将ACK置1，双方向的关闭结束。</p></blockquote><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>超文本传输协议，将超文本标记语言(HTML)从服务器传输到客户端的协议。它是通过TCP或通过TLS加密的 TCP 连接发送的应用层协议。<br><div class="note note-success">            <p><strong>特点</strong><br>简单易懂：传输的报表消息可以被测试人员直接理解运用，使测试更加简单。<br>传输效率高:<br>    HTTP 是无状态的：在同一连接上连续执行的两个请求之间没有链接。对于试图连贯地与某些页面交互的用户来说，这会立即成为问题，例如，使用电子商务购物篮。但是，虽然 HTTP 本身的核心是无状态的，但 HTTP cookie 允许使用有状态会话。使用标头可扩展性，HTTP Cookie 被添加到工作流中，允许在每个 HTTP 请求上创建会话以共享相同的上下文或相同的状态。<br>可靠性高:<br>兼容性好:<br>灵活度高:HTTP是可拓展的，允许传输任意类型的数据对象</p>          </div></p><h5 id="建立链接步骤"><a href="#建立链接步骤" class="headerlink" title="建立链接步骤"></a>建立链接步骤</h5><ol><li>打开TCP链接：TCP 连接用于发送一个或多个请求，并接收一个应答。客户端可以打开一个新的连接，重用一个现有的连接，或者打开几个到服务器的 TCP 连接。</li><li>发送 HTTP 消息：HTTP 消息（在 HTTP/2 之前）是人类可读的。在 HTTP/2 中，这些简单的消息被封装在帧中，无法直接读取，但原理是一样的。</li><li>服务器接受请求并返回HTTP响应:Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP连接里，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li><li>释放连接TCP连接</li><li>客户端解析返回的数据：浏览器解析HTML内容，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。<h2 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h2><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3>集线器（hub）属于纯硬件网络底层设备，基本上不具有类似于交换机的”智能记忆”能力和”学习”能力。它也不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到与集线器相连的所有节点，因此在同一时间若是有两条线路在发送数据则会造成信息碰撞，用集线器链接的各设备处于<strong>同一冲突域</strong>内。<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3>相当于集线器的升级版，集线器只能进行两个端口之间的链接。交换机拥有高密度的接口并且有着mac表，每个端口都具有桥接功能，可以连接一个局域网或一台高性能服务器或工作站。实际上，交换机有时被称为多端口网桥。交换机允许许多组端口间的通道同时工作。所以，交换机的功能体现出不仅仅是一个网桥的功能，而是多个网桥功能的集合。<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3>路由器（Router）是连接两个或多个网络的硬件设备，在网络间起网关的作用，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。它能够理解不同的协议，例如某个局域网使用的以太网协议，因特网使用的TCP/IP协议。这样，路由器可以分析各种不同类型网络传来的数据包的目的地址，把非TCP/IP网络的地址转换成TCP/IP地址，或者反之；再根据选定的路由算法把各数据包按最佳路线传送到指定位置。所以路由器可以把非TCP/IP网络连接到因特网上。路由器具有防火墙的功能，因为其不传送不支持路由协议的数据，可防止广播风暴，而交换机没有这个功能。</li></ol><h4 id="关于猫"><a href="#关于猫" class="headerlink" title="关于猫"></a>关于猫</h4><p>猫的学名叫调制解调器，它的作用是将数字信号（电脑想要发送的信息）转换成模拟信号（网线中的电流脉冲）从而使信息在网线中传输。       由于计算机的一切信号都要由电流脉冲传送出去，因而猫是必须的。目前的家用路由器一般都是路由猫，即路由器兼顾了猫和简单交换机的功能</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>人们通过例如 google.com 等域名在线访问信息。Web 浏览器通过IP地址进行交互。DNS将域名转换为IP地址，以便浏览器能够加载互联网资源。连接到 Internet 的每个设备都有一个唯一 IP 地址，其他计算机可使用该 IP 地址查找此设备。DNS 服务器使人们无需存储一个32位的和人类理解范畴中与目标网站毫无关联的数，便利了用户使用。<br><img src="/img/postpictures/dsgfadsrahgtrjhytjhgfdjhgjhgjdtg.jpg" alt=""><br>DNS系统是一个树的结构，所有的请求都会先发送到根服务器中，DNS的根服务器有十三组，每一组又有数量不一的多台服务器，散布在世界各地。用户在访问一个根服务器所对应的ip时，会优先选择对应该ip的根服务器的物理距离最近的一台。<br>用户个人机上也存在有一定的DNS缓存，存放了最近使用DNS系统进行的查询的相关数据，本地储存最大的优势在于极其优秀且稳定的速度。减少了延迟。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>工程</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stm32学习汇总</title>
    <link href="/2022/02/26/stm32%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/02/26/stm32%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>得到这块板子是源于学校的一个口袋实验室的实验课程。每小组分一块正点原子的阿波罗Stm32F4的板子并要求自学。由于个人也有一定的嵌入式开发的意向，于是将Stm32学习的部分于此记录成博客。</p><h3 id="初步介绍"><a href="#初步介绍" class="headerlink" title="初步介绍"></a>初步介绍</h3><p>全面的板子介绍在开发指南上写有。在此补充一些初学者对板子的认知，可能会方便理解一些。<br>Stm32的芯片其实在学校发的这块正点原子的板子只是很小的一个部分，这块板子上的绝大多数配件是配套设施很全的外设。<br><img src="/img/postpictures/asdsgfdhgfjhytjtyujkyukyu.jpg" alt="大概是这样的"><br>板子的供电有两种方式，一种是直接用右上角的充电接口连接电源，另一种是通过USB SLAVE接口连接到电脑。<br>其中直接供电的话最高电压会高一些（16v→12v）USB SLAVE链接的是电脑usb接口所以在跑一些耗电量较大的工程时可能会带不太动。<br>与电脑的交互部分，我们可以通过USB SLAVE来直接下载代码以及向电脑发送串口信号。还可以通过STLink来进行电脑的下载。（<a href="https://www.bilibili.com/video/BV1Wx411d7wT?p=5&amp;t=1356.2">关于STLink的介绍及配置</a>）<br>然后是代码编辑器。使用的是keil5，需要注册。没注册的话只能编译大小受限的代码，解决方法是在网上找到了<a href="/file/download/new.zip">注册软件</a>。（注意，我的这个是2020版的，网上大多是比2020更早的版本，若是后来者发现注册码无法激活，可能需要找到最新版的软件来生成。）<br>编辑器具体配置可以去看正点原子的官方教程，一步一步来就不会出错。</p><hr><h2 id="开始学习"><a href="#开始学习" class="headerlink" title="开始学习"></a>开始学习</h2><pre><code>注明：我学习的是HAL库写法，HAL库封装的功能很多并且对于初学者很友好。</code></pre><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>大多数东西初学的时候都会由Hello World来引入。Stm32的hello world 就是点亮第一盏LED灯。<br>在 <code>main.c</code> 中，首先得初始化HAL库 <code>HAL_Init();</code> ，将HAL库引入程序。之后设置系统时钟。有一定电路基础的话就知道，时钟提供了周期性变化的电压，给整个系统确立了最小的单位时间以及维持着整个系统的时间轴，对于任和想实现的功能来说时钟是极为重要的。设置系统时钟的代码为 <code>Stm32_Clock_Init(360,25,2,8)</code> 。括号里的参数可以自己配置，不过对于这块板子（STM32F429）来说这些数据是固定的。（关于时钟配置的详细讲解移步<a href="/2022/02/26/stm32%E5%AD%A6%E4%B9%A0/#%E6%97%B6%E9%92%9F">这里</a>）。<br>下一步是确定自己所要使用的接口，我们自己可以配置的接口也就是通用性接口是GPIO接口，这些接口可供自由使用。  <code>GPIO_InitTypeDef GPIO_Initure</code> 可以初始化一个GPIO类型的结构体，我们可以通过这个结构体来对GPIO接口来做相应的配置。（关于GPIO的详细讲解移步<a href="/2022/02/26/stm32%E5%AD%A6%E4%B9%A0/#GPIO">这里</a>）。<br>点亮LED灯，所需的接口是GPIOB 的 Pb0 | Pb1 接口。首先开启GPIOB的时钟 语句是 <code>__HAL_RCC_GPIOB_CLK_ENABLE();</code> 然后给GPIO类型的结构体赋值，大概是这样：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">GPIO_Initure.Pin</span>=GPIO_PIN_5<span class="hljs-comment">; //PB1,0</span><br><span class="hljs-attr">GPIO_Initure.Mode</span>=GPIO_MODE_OUTPUT_PP<span class="hljs-comment">;  //推挽输出</span><br><span class="hljs-attr">GPIO_Initure.Pull</span>=GPIO_PULLUP<span class="hljs-comment">;          //上拉</span><br><span class="hljs-attr">GPIO_Initure.Speed</span>=GPIO_SPEED_HIGH<span class="hljs-comment">;     //高速</span><br></code></pre></td></tr></table></figure><p>其中第一条确定的是哪个或者哪些接口，后面的则都是在规范IO类型。<br>然后就是将这个结构体赋值到接口上 <code>HAL_GPIO_Init(GPIOB,&amp;GPIO_Initure);</code> 这句话的意思是把我们所赋值的这个结构体复制到GPIOB的接口上。</p><p>完成这一步，就已经把所用接口的准备工作做完了。<br>然后就是主程序部分，主程序是一个while循环，我们将在这里完善自己的程序逻辑。<br>点亮LED灯所需要的是给LED的两级接上高低不同的电压。通过原理图可以知道，当输出电平为低电平时LED单向导通发亮。因此假如发亮就得让GPIO口输出电平为低，反之则为高。<br><img src="/img/postpictures/fdskjghbdfosajgnoakdsf.jpg" alt="原理图是这样的"><br>我们可以通过 <code>HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,GPIO_PIN_SET);</code> 来将GPIOB的PB1接口设置为高电平。 <code>HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,GPIO_PIN_RESET);</code> 将GPIOB的PB1接口设置为低电平。只要在函数里加上这两条语句，就能使LED亮灭了。<br>但是假如直接这么写的话你会发现LED好像是恒亮的，这是因为由于人眼的视觉暂留因素，高频率的亮灭无法让人区分。因此我们可以在这两条亮灭语句后各添一条延时函数，让LED保持状态一段时间。常用的是 <code>delay()</code> 函数，当然也可以自己写一个简单的循环，按照之前打OI的经历，大概2e8次空循环是1s。</p><p>代码如下：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sys.h&quot;</span><br>#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;delay.h&quot;</span><br>#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;usart.h&quot;</span><br>#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;led.h&quot;</span><br>void <span class="hljs-constructor">Delay(<span class="hljs-params">__IO</span> <span class="hljs-params">uint32_t</span> <span class="hljs-params">nCount</span>)</span>;<br>void <span class="hljs-constructor">Delay(<span class="hljs-params">__IO</span> <span class="hljs-params">uint32_t</span> <span class="hljs-params">nCount</span>)</span>&#123;<span class="hljs-keyword">while</span>(nCount--)&#123;&#125;&#125;<br><span class="hljs-built_in">int</span> main(void)<br>&#123;<br>    <span class="hljs-constructor">HAL_Init()</span>;<span class="hljs-comment">//HAL库初始化  </span><br>    <span class="hljs-constructor">Stm32_Clock_Init(360,25,2,8)</span>;<span class="hljs-comment">//系统时钟确立</span><br><br>    <span class="hljs-constructor">__HAL_RCC_GPIOB_CLK_ENABLE()</span>;<span class="hljs-comment">//GPIOB口时钟确立</span><br>GPIO_InitTypeDef GPIO_Initure;<br>    GPIO_Initure.Pin=GPIO_PIN_0<span class="hljs-pattern-match">|<span class="hljs-constructor">GPIO_PIN_1</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-constructor">PB1</span>,0</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">GPIO_Initure</span>.<span class="hljs-constructor">Mode</span>=<span class="hljs-constructor">GPIO_MODE_OUTPUT_PP</span>;  </span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">GPIO_Initure</span>.<span class="hljs-constructor">Pull</span>=<span class="hljs-constructor">GPIO_PULLUP</span>;          </span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">GPIO_Initure</span>.<span class="hljs-constructor">Speed</span>=<span class="hljs-constructor">GPIO_SPEED_HIGH</span>;     </span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">HAL_GPIO_Init(GPIOB,&amp;GPIO_Initure)</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"><span class="hljs-keyword">while</span>(1)</span><br><span class="hljs-pattern-match">&#123;</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,GPIO_PIN_SET)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,GPIO_PIN_SET)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">Delay(0x7FFFFF)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,GPIO_PIN_RESET)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,GPIO_PIN_RESET)</span>;</span><br><span class="hljs-pattern-match"><span class="hljs-constructor">Delay(0x7FFFFF)</span>;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match">&#125;</span><br><span class="hljs-pattern-match"></span><br></code></pre></td></tr></table></figure></p><hr><h2 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h2><h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>GPIO代表“通用输入/输出”。是集成电路上的一种引脚，没有特定功能。虽然大多数引脚都有特定用途，例如向某个组件发送信号，但 GPIO 引脚的功能是可定制的，并且可以通过软件控制。<br>GPIO 接口变化很大。在某些情况下，一组可以作为一组切换到输入或输出的引脚。在其他情况下，每个引脚都可以设置为接受或提供不同的逻辑电压，具有可配置的驱动强度和上拉/下拉。输入和输出电压通常受限于带有 GPIO 的设备的电源电压，并且可能会被更高的电压损坏。（所以要小心输入）</p><pre><code>GPIO 功能可能包括：GPIO 引脚可配置为输入或输出GPIO 引脚可以启用/禁用输入值是可读的（通常是高低电平）输出值是可写/可读的输入值通常可以用作IRQ（通常用于唤醒事件）</code></pre><h4 id="Stm32中的GPIO配置"><a href="#Stm32中的GPIO配置" class="headerlink" title="Stm32中的GPIO配置"></a>Stm32中的GPIO配置</h4><p>首先是开启时钟 <code>__GPIOA_CLK_ENABLE();//使能GPIOA时钟</code> 以及配置GPIO输入输出模式。<br>GPIO_InitTypeDef结构体定义有一些赋值项，在HAL库中我们通过为这些元素赋值来控制GPIO。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">uint32_t</span> Pin; <span class="hljs-comment">//指定 IO 口</span><br><span class="hljs-keyword">uint32_t</span> Mode; <span class="hljs-comment">//模式设置</span><br><span class="hljs-keyword">uint32_t</span> Pull; <span class="hljs-comment">//上下拉设置</span><br><span class="hljs-keyword">uint32_t</span> Speed; <span class="hljs-comment">//速度设置</span><br><span class="hljs-keyword">uint32_t</span> Alternate;<span class="hljs-comment">//复用映射配置</span><br>&#125;GPIO_InitTypeDef;<br></code></pre></td></tr></table></figure><p>(1) <code>uint32_t Pin</code> 指定了输出的IO口，可以是一个可以是多个，多个IO口用或(|)符号隔开。<br>(2) <code>uint32_t Mode</code> 设置了输入输出的模式，模式一共有以下八种：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">GPIO_Mode_AIN             <span class="hljs-regexp">/*模拟输入，特点：应用ADC模拟输入，或者低功耗下省电*/</span><br> <br>GPIO_Mode_IN_FLOATING     <span class="hljs-regexp">/*浮空输入，特点：浮空输入一般多用于外部按键输入，IO的电平状态是不确定的，完全由外部输入决定，如果在该引脚悬空的情况下，读取该端口的电平是不确定的*/</span><br> <br>GPIO_Mode_IPD             <span class="hljs-regexp">/*下拉输入，特点：默认低电平*/</span><br> <br>GPIO_Mode_IPU             <span class="hljs-regexp">/*上拉输入，特点：默认高电平*/</span><br> <br>GPIO_Mode_Out_OD          <span class="hljs-regexp">/*开漏输出，特点：IO输出0接GND，IO输出1，悬空；接上拉电阻才可以输出高电平，上升沿速度慢。适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内)；可以将多个开漏输出的Pin，连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系。*/</span><br> <br>GPIO_Mode_Out_PP          <span class="hljs-regexp">/*推挽输出，特点：可以输出高,低电平，导通损耗小，效率高，读输入值是未知的*/</span><br> <br>GPIO_Mode_AF_OD           <span class="hljs-regexp">/*复用开漏输出，特点：可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用），如：片内外设功能（TX1,MOSI,MISO.SCK.SS）*/</span><br> <br>GPIO_Mode_AF_PP           <span class="hljs-regexp">/*复用推挽输出，特点：可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用），如：片内外设功能（I2C的SCL,SDA）*/</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/postpictures/asdgfdbhgfdhbgfhsdfgh.jpg" alt="GPIO引脚的各种IO模式电路"></p><p>(3) <code>uint32_t Pull</code> 区分这个GPIO口用于输入还是输出,输出模式的话一般是 <code>no pull</code> 。这样可以正确输出目标值。<br>当输入模式的时候，需要根据输入值来配置，若默认输入为高电平，则需要 <code>pull up</code> ，反之 <code>pull down</code> 。<br><strong>上拉(pull up)是对器件注入电流，下拉是输出电流，上拉就是将不确定的信号通过一个电阻钳位在高电平，电阻同时起到限流作用；而下拉就是将不确定的信号通过一个电阻钳位在低电平，电阻同时起到限流作用。</strong><br>(4) <code>uint32_t Speed</code> 规定输出电路的响应速度，可以理解为输出电路的带宽，涉及到信号失真问题。同时，速度配置越高，噪声越大，功耗越大。<br>(5) <code>uint32_t Alternate</code> 接口的复用功能，可作为I2C，SPI，USART等通讯接口。此时GPIO的作用不是通用的输入输出。此时端口的输出模式需要配置为复用状态。</p><h4 id="GPIO常用函数汇总"><a href="#GPIO常用函数汇总" class="headerlink" title="GPIO常用函数汇总"></a>GPIO常用函数汇总</h4><h5 id="GPIO接口初始化"><a href="#GPIO接口初始化" class="headerlink" title="GPIO接口初始化"></a>GPIO接口初始化</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"> void HAL<span class="hljs-emphasis">_GPIO_</span>Init(GPIO<span class="hljs-emphasis">_TypeDef  *GPIOx, GPIO_</span>InitTypeDef <span class="hljs-emphasis">*GPIO_Init);</span><br><span class="hljs-emphasis">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span></span><br><span class="hljs-emphasis">功能:根据指定参数初始化GPIOx外设</span><br><span class="hljs-emphasis">参数定义:</span><br><span class="hljs-emphasis">GPIOx：其中x可以是（A..H），用于选择STM32L4系列的GPIO外设</span><br><span class="hljs-emphasis">GPIO_Init：指向GPIO_InitTypeDef结构的指针，该结构包含指定GPIO外设的配置信息。</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*/</span></span></span><br></code></pre></td></tr></table></figure><h5 id="GPIO接口去初始化"><a href="#GPIO接口去初始化" class="headerlink" title="GPIO接口去初始化"></a>GPIO接口去初始化</h5><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lisp">void HAL_GPIO_DeInit(<span class="hljs-name">GPIO_TypeDef</span>  *GPIOx, uint32_t GPIO_Pin);<br>/************************************<br>功能:将GPIOx外设寄存器解除初始化为其默认复位值。<br>参数定义:<br>GPIOx：其中x可以是（A..H），用于选择STM32L4系列的GPIO外设<br>GPIO_Pin：指定要写入的端口位;此参数可以是GPIO_Pin_x的任意组合，其中x可以是（0..15）。<br>***********************************/<br></code></pre></td></tr></table></figure><h5 id="读取GPIO的值"><a href="#读取GPIO的值" class="headerlink" title="读取GPIO的值"></a>读取GPIO的值</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">GPIO<span class="hljs-emphasis">_PinState HAL_</span>GPIO<span class="hljs-emphasis">_ReadPin(GPIO_</span>TypeDef<span class="hljs-emphasis">* GPIOx, uint16_t GPIO_Pin)</span><br><span class="hljs-emphasis">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span></span><br><span class="hljs-emphasis">参数定义:</span><br><span class="hljs-emphasis">GPIOx：其中x可以是（A..H），用于选择STM32L4系列的GPIO外设</span><br><span class="hljs-emphasis">GPIO_Pin：指定要写入的端口位;此参数可以是GPIO_Pin_x的任意组合，其中x可以是（0..15）。</span><br><span class="hljs-emphasis">返回值:端口引脚值</span><br><span class="hljs-emphasis"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*/</span></span></span><br></code></pre></td></tr></table></figure><h5 id="向指定接口写入值"><a href="#向指定接口写入值" class="headerlink" title="向指定接口写入值"></a>向指定接口写入值</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">void HAL<span class="hljs-emphasis">_GPIO_</span>WritePin(GPIO<span class="hljs-emphasis">_TypeDef* GPIOx, uint16_</span>t GPIO<span class="hljs-emphasis">_Pin, GPIO_</span>PinState PinState)<br>/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><br>参数定义:<br>GPIOx：其中x可以是（A..H），用于选择STM32L4系列的GPIO外设<br>GPIO<span class="hljs-emphasis">_Pin：指定要写入的端口位;此参数可以是GPIO_</span>Pin<span class="hljs-emphasis">_x的任意组合，其中x可以是（0..15）。</span><br><span class="hljs-emphasis">PinState:指定要写入的值</span><br><span class="hljs-emphasis">   *此参数可以是GPIO_</span>PinState枚举值之一：<br><span class="hljs-bullet">   *</span>  GPIO<span class="hljs-emphasis">_PIN_</span>RESET：清0<br><span class="hljs-bullet">   *</span>  GPIO<span class="hljs-emphasis">_PIN_</span>SET：置1<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*/</span></span><br></code></pre></td></tr></table></figure><h5 id="对GPIO值取反和锁定"><a href="#对GPIO值取反和锁定" class="headerlink" title="对GPIO值取反和锁定"></a>对GPIO值取反和锁定</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">void HAL<span class="hljs-emphasis">_GPIO_</span>TogglePin(GPIO<span class="hljs-emphasis">_TypeDef* GPIOx, uint16_</span>t GPIO<span class="hljs-emphasis">_Pin)</span><br><span class="hljs-emphasis">HAL_</span>StatusTypeDef HAL<span class="hljs-emphasis">_GPIO_</span>LockPin(GPIO<span class="hljs-emphasis">_TypeDef* GPIOx, uint16_</span>t GPIO<span class="hljs-emphasis">_Pin);</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span></span><br><span class="hljs-emphasis">参数定义:</span><br><span class="hljs-emphasis">GPIOx：其中x可以是（A..H），用于选择STM32L4系列的GPIO外设</span><br><span class="hljs-emphasis">GPIO_</span>Pin：指定要写入的端口位;此参数可以是GPIO<span class="hljs-emphasis">_Pin_</span>x的任意组合，其中x可以是（0..15）。<br><br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*/</span></span><br></code></pre></td></tr></table></figure><h5 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">void  HAL<span class="hljs-emphasis">_GPIO_</span>EXTI<span class="hljs-emphasis">_IRQHandler(uint16_</span>t GPIO<span class="hljs-emphasis">_Pin);</span><br><span class="hljs-emphasis"><span class="hljs-strong">__weak void HAL<span class="hljs-emphasis">_GPIO_</span>EXTI<span class="hljs-emphasis">_Callback(uint16_</span>t GPIO<span class="hljs-emphasis">_Pin);</span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis">/<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis">功能:</span></span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"> HAL_GPIO_EXTI_IRQHandler: 中断请求标志位清零并进入回调函数</span></span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"> HAL_GPIO_EXTI_Callback: 中断服务函数</span></span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"> EXTI线路检测回调。</span></span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong">__weak:__</span>weak 修饰符的函数，用户可以在用户文件中重新定义一个同名函数，最终编译器编译的时候，会选择用户定义的函数，如果用户没有重新定义这个函数，那么编译器就会执行<span class="hljs-strong">__weak 声明的函数，并且编译器不会报错。</span></span></span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong">***************************************<span class="hljs-emphasis">*/</span></span></span></span></span></span></span><br></code></pre></td></tr></table></figure><hr><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>时钟是电路的脉搏，这个形容我感觉很贴切，系统时钟的频率很高，统一使用系统时钟（高频）会造成功耗的无意义消耗。STM32F429的时钟有很多源，可以支持许多繁杂的外设。<br><img src="/img/postpictures/dfsghtrhtyjygjvbdbntrhb.jpg" alt="这是STM32F429的系统时钟图"><br>STM32有五个时钟源，分别是：HSI、HSE、LSI、LSE、PLL。<br>①、LSI 是低速内部时钟，RC 振荡器，频率为 32kHz 左右。供独立看门狗和自动唤醒单元使用。<br>②、LSE 是低速外部时钟，接频率为 32.768kHz 的石英晶体。这个主要是 RTC 的时钟源。<br>③、HSE 是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz~26MHz。<br>我们的开发板接的是 25M 的晶振。HSE 也可以直接做为系统时钟或者 PLL 输入。<br>④、HSI 是高速内部时钟，RC 振荡器，频率为 16MHz。可以直接作为系统时钟或者用作 PLL<br>输入。<br>⑤、PLL 为锁相环倍频输出。STM32F4 有三个 PLL:</p><pre><code>1） 主 PLL(PLL)由 HSE 或者 HSI 提供时钟信号，并具有两个不同的输出时钟。第一个输出 PLLP 用于生成高速的系统时钟（最高 180MHz）第二个输出 PLLQ 为 48M 时钟，用于 USB OTG FS 时钟，随机数发生器的时钟和 SDIO时钟。2） 第一个专用 PLL(PLLI2S)用于生成精确时钟，在 I2S 和 SAI1 上实现高品质音频性能。其中，N 是用于 PLLI2S vco 的倍频系数，其取值范围是：192~432；R 是 I2S 时钟的分频系数，其取值范围是：2-7；Q 是 SAI 时钟分频系数，其取值范围是：2-15；P 没用到。3） 第二个专用 PLL(PLLSAI)同样用于生成精确时钟，用于 SAI1 输入时钟，同时还为 LCD_TFT接口提供精确时钟。其中，N 是用于 PLLSAI vco 的倍频系数，其取值范围是：192~432；Q 是 SAI 时钟分频系数，其取值范围是：2~15；R 是 LTDC 时钟的分频系数，其取值范围是：2~7；P 没用到</code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>嵌入式</tag>
      
      <tag>Stm32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CDQ分治</title>
    <link href="/2021/10/21/CDQ%E5%88%86%E6%B2%BB/"/>
    <url>/2021/10/21/CDQ%E5%88%86%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h3><p>CDQ 分治是一种思想而不是具体的算法。目前这个思想的拓展十分广泛，依原理与写法的不同，大致分为三类：</p><pre><code>解决和点对有关的问题。1D 动态规划的优化与转移。通过 CDQ 分治，将一些动态问题转化为静态问题。</code></pre><p>来自OIERDB。<br>介绍听的有点乱，是吧。实际上很简单，就是将需要分治的区间分为子区间，然后假设我们可以获得子区间的答案，呢么我们还需要算出这个区间里所有子区间之间相互影响的答案。层层递归，最终求解。</p><h4 id="第一道例题"><a href="#第一道例题" class="headerlink" title="第一道例题"></a>第一道例题</h4><p>一个很经典的问题是三维偏序问题：即给你n个三元组，要求你求出对于每个三元组有多少个其他三元组严格不大于该三元组。<br>二位偏序我们一般解决的方式是使用树状数组来求，将权值离散化后按第一关键字顺序插入至树状数组里第二关键字所对应的位置，这样我们在计算的时候就可以直接用树状数组求和，来得出对于每个三元组有多少合适的三元组在它前面。<br>简单的剖析一下这个过程，因为插入的顺序是按第一关键字排序，所以保证了目前树状数组里的元素第一关键字严格不大于目前元素的第一关键字，插入树状数组第二关键字对应的位置保证了第二关键字的严格不降。<br>假如我们想要在树状数组的基础上求三维偏序，呢么第三关键字也需要保证严格不降。此时就用到了cdq分治。</p><h4 id="用CDQ分治来解决"><a href="#用CDQ分治来解决" class="headerlink" title="用CDQ分治来解决"></a>用CDQ分治来解决</h4><p>我们首先按照第一关键字排序，然后使用cdq分治将区间分为左右两个区间，此时严格不大于关系只有三种，一种是全在左区间，一种是全在右区间，一种是大的在右区间，不大的在左区间。<br>全在左右两子区间的我们可以递归解决，我们只需要解决不大的元素在左区间，大的元素在右区间这种规则下有多少种分法。<br>很明显，右区间的第一关键字绝对大于左区间的第一关键字，因此就算我们将左区间或右区间单独排序也不会改变第一关键字的关系。呢就将第二第三关键字按照二维偏序的方式算得即可。<br>由于我们可以先处理子区间，也就是可以保证子区间是有序的（按第二关键字排序），也就是使用类似归并排序的方式来搞。这样我们就可以直接按照顺序将第三关键字插入树状数组中得到结果。<br>具体实现见例题代码：<br><a href="https://www.luogu.com.cn/problem/P3810">洛谷3810</a></p><details><summary>代码</summary><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include &lt; bits/stdc++.h &gt;</span><br><span class="hljs-comment">#define maxn 200010</span><br>using namespace std;<br>long long n,k,kl,C[maxn],A[maxn],nn[maxn];<br>struct ss<br>&#123;<br>long long a,b,c,num,id;<br>&#125;e[maxn],B[maxn];<br>inline bool mycmp(ss a1,ss a2)&#123;<br><span class="hljs-keyword">if</span>(a1.a!=a2.a)<span class="hljs-keyword">return</span> a1.a&lt;a2.a;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a1.b!=a2.b)<span class="hljs-keyword">return</span> a1.b&lt;a2.b;<br><span class="hljs-keyword">return</span> a1.c&lt;a2.c;&#125;<br>inline bool cmp(ss a1, ss a2)&#123;<span class="hljs-keyword">return</span> a1.id&lt;a2.id;&#125;<br>inline void copy(<span class="hljs-keyword">int</span> q1,<span class="hljs-keyword">int</span> q2)&#123;B[q1].a=e[q2].a;B[q1].b=e[q2].b;B[q1].c=e[q2].c;B[q1].id=e[q2].id;B[q1].num=e[q2].num;&#125;<br>inline <span class="hljs-keyword">int</span> lowbit(<span class="hljs-keyword">int</span> kk)&#123;<span class="hljs-keyword">return</span> kk&amp;(-kk);&#125;<br><span class="hljs-keyword">int</span> add(<span class="hljs-keyword">int</span> yu,<span class="hljs-keyword">int</span> kk)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kl=yu;kl&lt;=k;kl+=lowbit(kl))C[kl]+=kk;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><span class="hljs-keyword">int</span> Find(<span class="hljs-keyword">int</span> kk)&#123;<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kl=kk;kl&gt;<span class="hljs-number">0</span>;kl-=lowbit(kl))sum+=C[kl];<span class="hljs-keyword">return</span> sum;&#125;<br>inline void merge(<span class="hljs-keyword">int</span> ll,<span class="hljs-keyword">int</span> rr)<br>&#123;<br><span class="hljs-keyword">if</span>(ll+<span class="hljs-number">1</span>==rr)<br>&#123;<br><span class="hljs-keyword">if</span>(e[rr].b&lt;e[ll].b)B[++kl]=e[rr],e[rr]=e[ll],e[ll]=B[kl];<br>kl=<span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-keyword">int</span> mid=(ll+rr)/<span class="hljs-number">2</span>;kl=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=ll,j=mid+<span class="hljs-number">1</span>;kl&lt;=(rr-ll+<span class="hljs-number">1</span>);)<br>&#123;<br><span class="hljs-keyword">while</span>(i==mid+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(j==rr+<span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;copy(++kl,j++);&#125;<br><span class="hljs-keyword">while</span>(j==rr+<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span>(i==mid+<span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;copy(++kl,i++);&#125;<br><span class="hljs-keyword">if</span>(e[i].b&lt;=e[j].b&amp;&amp;i&lt;=mid)&#123;copy(++kl,i++);&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&lt;=rr)&#123;copy(++kl,j++);&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;//cout&lt;&lt;ll&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;rr&lt;&lt;<span class="hljs-string">&#x27;-&#x27;</span>&lt;&lt;kl&lt;&lt;endl;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=kl;i++)e[i+ll-<span class="hljs-number">1</span>]=B[i];<br>//cout&lt;&lt;ll&lt;&lt;<span class="hljs-string">&#x27;-&#x27;</span>&lt;&lt;rr&lt;&lt;<span class="hljs-string">&#x27;=&#x27;</span>&lt;&lt;kl&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=kl;i++)cout&lt;&lt;e[i+ll-<span class="hljs-number">1</span>].b&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;endl;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>inline void slove(<span class="hljs-keyword">int</span> ll,<span class="hljs-keyword">int</span> rr)<br>&#123;<br><span class="hljs-keyword">int</span> mid=(ll+rr)/<span class="hljs-number">2</span>,ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>,j=ll;i&lt;=rr;i++)<br>&#123;<br><span class="hljs-keyword">while</span>(e[j].b&lt;=e[i].b&amp;&amp;j&lt;=mid)add(e[j].c,e[j].num),j++;<br>A[e[i].id]+=Find(e[i].c);<br>&#125;<br>//<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)cout&lt;&lt;C[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;endl;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=mid+<span class="hljs-number">1</span>,j=ll;i&lt;=rr;i++)<span class="hljs-keyword">while</span>(e[j].b&lt;=e[i].b&amp;&amp;j&lt;=mid)add(e[j].c,(<span class="hljs-number">0</span>-e[j].num)),j++;<br>&#125;<br>inline <span class="hljs-keyword">int</span> cd<span class="hljs-string">q(int ll,int rr)</span><br>&#123;<br><span class="hljs-keyword">if</span>(ll==rr)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> mid=(ll+rr)/<span class="hljs-number">2</span>,ans=<span class="hljs-number">0</span>;<br>ans+=cd<span class="hljs-string">q(ll,mid)</span>;<br>ans+=cd<span class="hljs-string">q(mid+1,rr)</span>;<br>slove(ll,rr);<br>//cout&lt;&lt;ll&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;rr&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>//<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cout&lt;&lt;A[e[i].id]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>//<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cout&lt;&lt;e[i].a&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>//<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cout&lt;&lt;e[i].b&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>//<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cout&lt;&lt;e[i].c&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>//<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">19</span>;i&lt;=n;i++)cout&lt;&lt;e[i].num&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>//<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cout&lt;&lt;e[i].id&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>merge(ll,rr);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">int</span> main()<br>&#123;<br>memset(e,<span class="hljs-number">10</span>,sizeof(e));<br>scanf(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);<br><span class="hljs-keyword">int</span> yu=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)scanf(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;e[i].a,&amp;e[i].b,&amp;e[i].c),e[i].num=<span class="hljs-number">1</span>,e[i].id=i;<br><span class="hljs-keyword">sort</span>(e+<span class="hljs-number">1</span>,e+n+<span class="hljs-number">1</span>,mycmp);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span>(e[i].a==e[i-<span class="hljs-number">1</span>].a&amp;&amp;e[i].b==e[i-<span class="hljs-number">1</span>].b&amp;&amp;e[i].c==e[i-<span class="hljs-number">1</span>].c)<br>&#123;<br>e[i].num+=e[i-<span class="hljs-number">1</span>].num;<br>e[i-<span class="hljs-number">1</span>]=e[<span class="hljs-number">0</span>];<br>yu++;<br>&#125;<br><span class="hljs-keyword">sort</span>(e+<span class="hljs-number">1</span>,e+n+<span class="hljs-number">1</span>,mycmp);<br>n-=yu;<br>cd<span class="hljs-string">q(1,n)</span>;<br>//<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cout&lt;&lt;A[e[i].id+e[i].num-<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)nn[A[e[i].id]+e[i].num-<span class="hljs-number">1</span>]+=e[i].num;<br>n+=yu;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,nn[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></details><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字电路</title>
    <link href="/2021/10/09/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/"/>
    <url>/2021/10/09/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="逻辑代数基础"><a href="#逻辑代数基础" class="headerlink" title="逻辑代数基础"></a>逻辑代数基础</h3><h4 id="数制转换-amp-amp-位运算"><a href="#数制转换-amp-amp-位运算" class="headerlink" title="数制转换&amp;&amp;位运算"></a>数制转换&amp;&amp;位运算</h4><pre><code>太基础了，pass</code></pre><p><img src="/img/postpictures/asfsadgfdhgtrfsh.png" alt="不过还是符号还是得记下的"></p><h4 id="逻辑代数运算规律"><a href="#逻辑代数运算规律" class="headerlink" title="逻辑代数运算规律"></a>逻辑代数运算规律</h4><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/postpictures/asgdrfgtrshtrhtrshtgr.png" alt="一些基础"></div><div class="group-image-wrap"><img src="/img/postpictures/asdgfreagregregredga.png" alt="一些基础"></div></div></div><h4 id="逻辑函数的标准形式"><a href="#逻辑函数的标准形式" class="headerlink" title="逻辑函数的标准形式"></a>逻辑函数的标准形式</h4><p><strong>最小项之和</strong>或是<strong>最大项之积</strong>的形式</p><p>最小项m：<strong>为乘积项，包含n个因子。n个变量均以原变量或反变量的形式出现一次，通俗的来说就是每一项，2个变量有4个最小项，3个有8个最小项。</strong>(我也不知道为啥叫最小项. . .感觉好怪)</p><blockquote><p>性质：<br>对变量的任意取值，有且只有一个最小项的值为1.<br>所以全体最小项之和为1，任意两个最小项之积为0.<br>相邻最小项可以合并，相邻指的是格雷码上相邻，也就是二进制码上只有一位不同。</p></blockquote><p>最大项m：<strong>为相加项，包含n个因子。n个变量均以原变量或反变量的形式出现一次，通俗的来说就是每一项，2个变量有4个最大项，3个有8个最大项。</strong>(同不知道为啥叫最大项. . .感觉好怪)</p><blockquote><p>性质：<br>对变量的任意取值，有且只有一个最大项的值为0.<br>所以全体最大项之积为0，任意两个最大项之和为1.</p></blockquote><p>将真值表转化为这两种形式的时候，最小项之和将真值表所有为1项相加（或）。最大项之积将真值表所有为0项相乘（与）。</p><h4 id="化简逻辑函数"><a href="#化简逻辑函数" class="headerlink" title="化简逻辑函数"></a>化简逻辑函数</h4><p>就是用公式瞎鼓捣…鼓捣不出来的转化成最小项之和的形式在卡诺图里找点合并。<br>假如有无关项的限制（一般是几个项相加为0）相加为0的无关项在卡诺图里打上叉可合可不合。<br>得记住卡诺图各项的分布。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/postpictures/sagreghtryhtrfgbsryea.png" alt="n=2卡诺图分布"></div><div class="group-image-wrap"><img src="/img/postpictures/wsegreh5r6uj7iuu76r.png" alt="n=3卡诺图分布"></div><div class="group-image-wrap"><img src="/img/postpictures/asgrhtrujy7tikuykgfh.png" alt="n=4卡诺图分布"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/postpictures/sdgafrsgrehtrhssdf.png" alt="n=5卡诺图分布"></div></div></div><h3 id="门电路"><a href="#门电路" class="headerlink" title="门电路"></a>门电路</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>大学课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>数字电路分析</tag>
      
      <tag>大学基础课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间不同数的个数</title>
    <link href="/2021/10/04/%E5%8C%BA%E9%97%B4%E4%B8%8D%E5%90%8C%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/10/04/%E5%8C%BA%E9%97%B4%E4%B8%8D%E5%90%8C%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>题外话：树状数组作为一个非常易写的结构以及常数很小的算法来说，应用广泛。这篇可能会以后加入到树状数组知识总结里。</code></pre><p>朴素的想法就是每个区间都扫一遍，稍微优化一下就是对区间排个序，然后用莫队类似的搞一搞。<br>但是实际上复杂度还是不够优秀，所以还得继续优化。<br>思考下，实际上一个区间里“有用的数”会把其他相同的数取代，我们之前记录的是每个区间数字的出现次数，但是我们获得答案只需要直到是否出现了就行。也就是说，我们只让“有用的数”来提供贡献（时空复杂度上的），减少“没用的数”花费的时空复杂度。<br>呢我们可以只记录相同的数的最后一个，令其贡献为1，在我们对区间排序是以右端点为第一优先级排序的情况下，就能保证扫到某一区间的右端点时我们只需要计算前面被记录的数的个数即可。这时，问题就转化成了单点修改，区间求和的问题。<br>之后使用树状数组即可。<br><a href="https://ac.nowcoder.com/acm/contest/20322/J">例题</a><br>这里计算的是除这个区间外的不同数个数，用到的技巧是将原数列首尾相连，就能变成一个区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 200500</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> last[N],team[N],c[N],Ans[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(x)</span></span>&#123;<span class="hljs-keyword">return</span> (x&amp;(-x));&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span></span>&#123;<span class="hljs-keyword">for</span>(;x&lt;N;x+=lowbit(x))c[x]+=v;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;x&gt;<span class="hljs-number">0</span>;x-=lowbit(x))ans+=c[x];<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> l,r,ans,index;<br>&#125;qu[N];<br><span class="hljs-keyword">int</span> n,q,sum;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ss a,ss b)</span></span>&#123;<span class="hljs-keyword">return</span> a.r&lt;b.r;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;q)==<span class="hljs-number">2</span>)<br>   &#123;<br>        <span class="hljs-built_in">memset</span>(last,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(last));<br>        <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(c));<br>        sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>           <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;team[i]);<br>           team[i+n]=team[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;qu[i].r,&amp;qu[i].l),qu[i].index=i,qu[i].r+=n;<br>        sort(qu+<span class="hljs-number">1</span>,qu+<span class="hljs-number">1</span>+q,cmp);<br>        <span class="hljs-keyword">int</span> c1=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=c1;j&lt;=qu[i].r;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(last[team[j]]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    updata(j,<span class="hljs-number">1</span>);<br>                    last[team[j]]=j;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    updata(j,<span class="hljs-number">1</span>);<br>                    updata(last[team[j]],<span class="hljs-number">-1</span>);<br>                    last[team[j]]=j;<br>                &#125;<br>            &#125;<br>            c1=qu[i].r+<span class="hljs-number">1</span>;<br>            Ans[qu[i].index]=Sum(qu[i].r)-Sum(qu[i].l<span class="hljs-number">-1</span>);<br>        &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,Ans[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
      <category>树状数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>技巧</tag>
      
      <tag>数据结构</tag>
      
      <tag>区间问题</tag>
      
      <tag>树状数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点分治</title>
    <link href="/2021/09/14/%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <url>/2021/09/14/%E7%82%B9%E5%88%86%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>点分治可以有效解决一类树上路径问题，时间复杂度十分优秀。<br>首先需要知道<a href="https://oi-wiki.org/graph/tree-centroid/">树的重心</a>的相关概念.<br>我们这里需要用到的性质是：以树的重心为根的任意一颗子树大小不超过<script type="math/tex">\frac{n}{2}</script>.<br>于是我们每一次递归时以树的重心做根就可以保证最多进行<script type="math/tex">log(n)</script>层。<br>来道<a href="https://www.luogu.com.cn/problem/P3806">板子</a>.<br>代码：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;bits/stdc++.h&gt; <br>#define maxn <span class="hljs-number">10010</span><br>#define bign <span class="hljs-number">10001000</span><br>using namespace std;<br>int n,m,tmp[bign],judge[bign];<br>int <span class="hljs-symbol">Size</span>[maxn],vis[maxn],head[maxn],que[maxn],kl=<span class="hljs-number">0</span>,maxp[maxn];<br>int tot,<span class="hljs-symbol">Root</span>,dis[maxn];<br>int q[bign],ynn[maxn];<br>struct edge<br>&#123;int next,to,dis;&#125;e[maxn*<span class="hljs-number">2</span>];<br>inline void addedge(int xx,int yy,int vv)&#123;e[++kl].to=yy;e[kl].dis=vv;e[kl].next=head[xx];head[xx]=kl;&#125;<br>inline void getzx(int now,int fat)<br>&#123;<br><span class="hljs-symbol">Size</span>[now]=<span class="hljs-number">1</span>;maxp[now]=<span class="hljs-number">0</span>;<br>for(int i=head[now],j;i;i=e[i].next)<br>&#123;<br>j=e[i].to;<br>if(j==fat||vis[j]) continue;<br>getzx(j,now);<br><span class="hljs-symbol">Size</span>[now]+=<span class="hljs-symbol">Size</span>[j];<br>maxp[now]=max(<span class="hljs-symbol">Size</span>[j],maxp[now]);<br>&#125;<br>maxp[now]=max(maxp[now],tot-<span class="hljs-symbol">Size</span>[now]);<br>if(maxp[now]&lt;maxp[<span class="hljs-symbol">Root</span>]) <span class="hljs-symbol">Root</span>=now;<br>&#125;<br>inline void getdis(int now,int fat)<br>&#123;<br>tmp[++tmp[<span class="hljs-number">0</span>]]=dis[now];<br>for(int i=head[now],j;i;i=e[i].next)<br>&#123;<br>j=e[i].to;<br>if(vis[j]||j==fat) continue;  //vis和fat限制了这个子树只能向下遍历。<br>dis[j]=dis[now]+e[i].dis;<br>getdis(j,now);<br>&#125;<br>&#125;<br>inline void calc(int now)<br>&#123;<br>int p=<span class="hljs-number">0</span>;<br>for(int i=head[now],j;i;i=e[i].next)<br>&#123;<br>j=e[i].to;<br>if(vis[j]) continue;<br>tmp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;dis[j]=e[i].dis;<br>getdis(j,now);<br>for(int z=tmp[<span class="hljs-number">0</span>];z;z--)<br>    for(int l=<span class="hljs-number">1</span>;l&lt;=m;l++)<br>                if(que[l]&gt;=tmp[z])<br>                    ynn[l]|=judge[que[l]-tmp[z]];  <br>for(int z=tmp[<span class="hljs-number">0</span>];z;z--) q[++p]=tmp[z],judge[tmp[z]]=<span class="hljs-number">1</span>;  <br>&#125;<br>for(int i=p;i;i--) judge[q[i]]=<span class="hljs-number">0</span>; <br>&#125;<br><br>inline void solve(int now)<br>&#123;<br>vis[now]=judge[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; calc(now);<br>for(int i=head[now],j;i;i=e[i].next)<br>&#123;<br>j=e[i].to;<br>if(vis[j]) continue;<br>tot=<span class="hljs-symbol">Size</span>[j];<br>maxp[<span class="hljs-symbol">Root</span>=<span class="hljs-number">0</span>]=bign;<br>getzx(j,<span class="hljs-number">0</span>);<br>solve(<span class="hljs-symbol">Root</span>);<br>&#125;<br>&#125;<br><br>int main()<br>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br>for(int i=<span class="hljs-number">1</span>,t1,t2,t3;i&lt;n;i++)<br>&#123;<br>cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;<br>addedge(t1,t2,t3);<br>addedge(t2,t1,t3);<br>&#125;<br>for(int i=<span class="hljs-number">1</span>;i&lt;=m;i++) cin&gt;&gt;que[i];<br>maxp[<span class="hljs-symbol">Root</span>=<span class="hljs-number">0</span>]=n;<br>tot=n;<br>getzx(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>solve(<span class="hljs-symbol">Root</span>);// 每次solve从重心开始<br>for(int i=<span class="hljs-number">1</span>;i&lt;=m;i++) <br>&#123;<br>if(ynn[i]) cout&lt;&lt;<span class="hljs-string">&quot;AYE&quot;</span>&lt;&lt;endl;<br>else cout&lt;&lt;<span class="hljs-string">&quot;NAY&quot;</span>&lt;&lt;endl;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>分治</tag>
      
      <tag>树上操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图覆盖问题</title>
    <link href="/2021/09/12/%E6%9C%80%E5%B0%8F%E7%8E%AF%E8%A6%86%E7%9B%96/"/>
    <url>/2021/09/12/%E6%9C%80%E5%B0%8F%E7%8E%AF%E8%A6%86%E7%9B%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a>最小路径覆盖</h2><p>最小路径覆盖就是在一个有向图中找一些路径，使之覆盖了图中的所有顶点，且任何一个顶点有且只有一条路径与之关联。对于单独的点也可以算作一条路径，长度为0.<br>这个问题实际上有两种细分：一种是路径不相交的，一种是路径可以相交的</p><h3 id="不相交最小路径覆盖"><a href="#不相交最小路径覆盖" class="headerlink" title="不相交最小路径覆盖"></a>不相交最小路径覆盖</h3><p>将原图变为二分图，左边是入节点右边是出节点，每一条边都连一条入节点和一条出节点。然后在这个二分图上跑网络流或者匈牙利啥的都行。这样可以确保每个出节点都有只一进，保证了路径不重复。所以最小路径覆盖=原图的结点数-新图的最大匹配数。</p><h3 id="可相交最小路径覆盖"><a href="#可相交最小路径覆盖" class="headerlink" title="可相交最小路径覆盖"></a>可相交最小路径覆盖</h3><p>可以相交的话需要先用floyd个跑<a href="https://zhuanlan.zhihu.com/p/266356742">传递闭包</a>，之后就转化为了不相交的最小路径覆盖了。<br>例题：POJ2594<br>题意是N个点M条边的图需要多少机器人探完。<br>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">510</span>;<br><span class="hljs-keyword">int</span> n,m,match[N],f[N][N];<br><span class="hljs-keyword">bool</span> vis[N];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hunguary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vis[i]&amp;&amp;f[x][i])<br>        &#123;<br>          vis[i]=<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span>(!match[i]||hunguary(match[i]))&#123;match[i]=x;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyed</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>                <span class="hljs-keyword">if</span>(f[i][k]&amp;&amp;f[k][j])f[i][j]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br>        <span class="hljs-keyword">if</span>(hunguary(i)) ans++;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,n-ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="hljs-number">2</span>,n+m)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)f[i][j]=<span class="hljs-number">0</span>;match[i]=<span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y;i&lt;=m;i++)<br>          <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),f[x][y]=<span class="hljs-number">1</span>;<br>        floyed();<br>        solve();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="最小环覆盖"><a href="#最小环覆盖" class="headerlink" title="最小环覆盖"></a>最小环覆盖</h2><p>问题大概是这样的：给你一个N个顶点M条边的带权有向图，要你把该图分成一个或多个不相交的有向环。且所有定点都被有向环覆盖。问你该有向环所有权值的总和最小是多少?<br>还是建个二分图，设置每个出点到汇点的边上界为1即可，在汇点流量为n时保证每个出点都有且只有一个“前一点”。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>图论</tag>
      
      <tag>欧拉回路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串总结</title>
    <link href="/2021/09/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/09/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>关于字符串的系统学习&amp;总结。<br>感觉字符串的相关算法，都是精巧的运用了储存下来的数据信息来挖掘其中的信息。也就是当前问题可以拆成子问题和其他，通过子问题来节省一部分时间复杂度。<br>感觉这么说好怪）</p><h3 id="前缀数组"><a href="#前缀数组" class="headerlink" title="前缀数组"></a>前缀数组</h3><p><strong>定义：前缀函数为n个数， <script type="math/tex">\pi[i]</script> 表示字符串s的子串s[0,i]中最长的 前缀和后缀相同的段落</strong><br>注意，这里说的前缀是真前缀（也就是 <script type="math/tex">\pi[0] = 0</script> ）<br>线性求法：<br><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; prefix_function(string s) &#123;<br>  <span class="hljs-keyword">int</span> n = (<span class="hljs-keyword">int</span>)s.length();<br>  <span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">pi</span>(n);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-built_in">pi</span>[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) j = <span class="hljs-built_in">pi</span>[j - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (s[i] == s[j]) j++;<br>    <span class="hljs-built_in">pi</span>[i] = j;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">pi</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><h3 id="Z函数"><a href="#Z函数" class="headerlink" title="Z函数"></a>Z函数</h3><p><strong>定义：z函数为n个数，z[i]代表以s[i]开头且是s的一个前缀的最长字符串长度。</strong><br>线性求法：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">z_function</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> n = (<span class="hljs-keyword">int</span>)s.length();<br>  <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="hljs-number">1</span>) &#123;<br>      z[i] = z[i - l];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      z[i] = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r - i + <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; s[z[i]] == s[i + z[i]]) ++z[i];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i + z[i] - <span class="hljs-number">1</span> &gt; r) l = i, r = i + z[i] - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> z;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><h3 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h3><h3 id="后缀自动机"><a href="#后缀自动机" class="headerlink" title="后缀自动机"></a>后缀自动机</h3><h3 id="马拉车"><a href="#马拉车" class="headerlink" title="马拉车"></a>马拉车</h3><p>求回文串，d1[i]表示以第i位为中心的字符串为回文串的最长长度。（只针对奇数串）<br>对于偶数串，我们可以在它的每一个字符中间添加特殊符号让其变为奇数串。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//注意，需要将字符串转变为奇数长度串</span><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">d1</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">int</span> k = (i &gt; r) ? <span class="hljs-number">1</span> : <span class="hljs-built_in">min</span>(d1[l + r - i], r - i + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt;= i - k &amp;&amp; i + k &lt; n &amp;&amp; s[i - k] == s[i + k]) &#123;<br>    k++;<br>  &#125;<br>  d1[i] = k--;<br>  <span class="hljs-keyword">if</span> (i + k &gt; r) &#123;<br>    l = i - k;<br>    r = i + k;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="序列自动机"><a href="#序列自动机" class="headerlink" title="序列自动机"></a>序列自动机</h3><p>见我的<a href="https://linzeyin.github.io/2021/03/01/%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/#%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA">旧blog</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>字符串</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线段树知识整合</title>
    <link href="/2021/08/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88/"/>
    <url>/2021/08/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线段树是常用的用来维护 <strong>区间信息</strong> 的数据结构。</p><p>线段树可以在 <script type="math/tex">O(logn)</script> 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。<br>（基础的入门操作就不说了</p><h3 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h3><p>一般的线段树我们需要开四倍空间，但是某些时候空间限制无法直接开这么大的空间，这时需要动态开点来节省空间。<br>动态开点指的是在建树时只建立所需区间的部分，这样空间复杂度会降低到 <script type="math/tex">O(nlogn)</script> 。<br>实现的话需要记录左右儿子的id，需要用新点时候开。<br>代码大概是这样：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-keyword">update</span>(<span class="hljs-type">int</span> &amp;now,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> x)&#123;<br>    <span class="hljs-keyword">if</span>(!now)now=++kl;//<span class="hljs-keyword">if</span> &quot;now&quot; <span class="hljs-keyword">is</span> a <span class="hljs-built_in">new</span> <span class="hljs-type">point</span>,<span class="hljs-keyword">create</span> it.<br>    <span class="hljs-keyword">if</span>(l==r)&#123;<span class="hljs-keyword">return</span>;&#125;//<span class="hljs-keyword">Do</span> whatever you want<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x&lt;=mid)<span class="hljs-keyword">update</span>(lc[now],l,mid,x,val);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">update</span>(rc[now],mid+<span class="hljs-number">1</span>,r,x,val);<br>    pushup(now);// upload it<span class="hljs-string">&#x27;s elements.</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>很简单，并且用处很大。</p><p>动态开点的合并代码：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs llvm">int merge(int <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span>int y)<br>&#123;<br>    if(<span class="hljs-title">!x</span>)return y<span class="hljs-comment">;//if anynode isn&#x27;t exist,return the other.</span><br>    if(<span class="hljs-title">!y</span>)return <span class="hljs-keyword">x</span><span class="hljs-comment">;</span><br>    sum[<span class="hljs-keyword">x</span>]+<span class="hljs-operator">=</span>sum[y]<span class="hljs-comment">;//add the other node&#x27;s information into this node</span><br>    lc[<span class="hljs-keyword">x</span>]<span class="hljs-operator">=</span>merge(lc[<span class="hljs-keyword">x</span>]<span class="hljs-punctuation">,</span>lc[y])<span class="hljs-comment">;</span><br>    rc[<span class="hljs-keyword">x</span>]<span class="hljs-operator">=</span>merge(rc[<span class="hljs-keyword">x</span>]<span class="hljs-punctuation">,</span>rc[y])<span class="hljs-comment">;</span><br>    return <span class="hljs-keyword">x</span><span class="hljs-comment">;//only return one ,and it means delate the otherone</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><p>可以理解为很多棵线段树，假如每棵线段树都建一棵完整的树呢么会有空间问题，假如有一些部分相同，我们建树的时候就可以直接使用这部分，这需要用到动态开点的手法。<br>实际上就是每次动态开点的时候连接到之前版本的节点上。<br>一般用的主席树就是大概是这样：<a href="https://www.luogu.com.cn/problem/P3919">例题</a>,常规的历史版本咨询。<br>这是源码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 1000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> data=<span class="hljs-number">0</span>,w=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> ch=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(ch!=<span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>))ch=getchar();<br>    <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)w=<span class="hljs-number">-1</span>,ch=getchar();<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)data=data*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>,ch=getchar();<br>    <span class="hljs-keyword">return</span> data*w;<br>&#125;<br><span class="hljs-keyword">int</span> a[MAXN*<span class="hljs-number">20</span>],n,m,rt[MAXN*<span class="hljs-number">20</span>],lc[MAXN*<span class="hljs-number">20</span>],rc[MAXN*<span class="hljs-number">20</span>],val[MAXN*<span class="hljs-number">20</span>],kl=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;now,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    now=++kl;<span class="hljs-comment">//开点</span><br>    <span class="hljs-keyword">if</span>(l==r)&#123;val[now]=a[l];<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    build(lc[now],l,mid);build(rc[now],mid+<span class="hljs-number">1</span>,r);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;now,<span class="hljs-keyword">int</span> pre,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    now=++kl;<br>    lc[now]=lc[pre];rc[now]=rc[pre];val[now]=val[pre];<br>    <span class="hljs-keyword">if</span>(l==r)&#123;val[now]=v;<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x&lt;=mid)insert(lc[now],lc[pre],l,mid,x,v);<br>    <span class="hljs-keyword">else</span> insert(rc[now],rc[pre],mid+<span class="hljs-number">1</span>,r,x,v);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;now,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r)<span class="hljs-keyword">return</span> val[now];<br>    <span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x&lt;=mid)<span class="hljs-keyword">return</span> query(lc[now],l,mid,x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> query(rc[now],mid+<span class="hljs-number">1</span>,r,x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)a[i]=<span class="hljs-built_in">read</span>();<br>    build(rt[<span class="hljs-number">0</span>],<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,jkl,pre,l;i&lt;=m;i++)<br>&#123;<br>        pre=<span class="hljs-built_in">read</span>(),jkl=<span class="hljs-built_in">read</span>(),l=<span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span>(jkl==<span class="hljs-number">1</span>)<br>&#123;<br>            <span class="hljs-keyword">int</span> v=<span class="hljs-built_in">read</span>();<br>            insert(rt[i],rt[pre],<span class="hljs-number">1</span>,n,l,v);<span class="hljs-comment">//保存修改后的版本</span><br>        &#125;<br><span class="hljs-keyword">else</span> <br>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,query(rt[pre],<span class="hljs-number">1</span>,n,l));<br>rt[i]=rt[pre];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如要做区间第k大，可以把每棵线段树变为权值线段树，然后按照数列顺序插入主席树，求[l,r]区间的第k大就是同时在l和r这两个版本的书上找，类似前缀和的思想，找到相差k的子树再搞就行了。<br>（不过这个我一般都是用树状数组来搞的，比主席树好写多了，就不写主席树写法了。</p><h3 id="一些奇怪的用法"><a href="#一些奇怪的用法" class="headerlink" title="一些奇怪的用法"></a>一些奇怪的用法</h3><p>后面的不太清楚到底是一种新算法还只是思路的延申，就记录下来充作小点。</p><h4 id="差分主席树？（雾"><a href="#差分主席树？（雾" class="headerlink" title="差分主席树？（雾"></a>差分主席树？（雾</h4><p>这中写法我没找到确切的算法介绍，是在看<a href="https://ac.nowcoder.com/acm/contest/19646/J">2020icpc沈阳j</a>时看他人代码发现的，感觉是一种奇怪的主席树写法，但是和以前碰到的主席树用法不太一样。又感觉像是把差分数组建成了一颗树，觉得很妙，记了下来。<br>这道题题意大体是这样：给你一个初始为0的序列，一个操作是将区间[l,r]的所有值为v的数加一，另一个操作是询问区间[l,r]的最值。<br>以下是算法详解（具体看源码）<br>这个算法也是建立了多棵树，第i棵树的[l,r]区间数的个数减去第i-1棵树的[l,r]区间数的个数表示第值为i的数的存在情况，最开始每棵树都是<strong>包含区间[1,n]的完整的线段树</strong>，然后当我们执行一次修改操作（将[l,r]的所有值为v的数加一）时，找到第v棵树，第v-1棵树所代表的区间，然后取差。假如差为0代表这个区间无v直接返回，假如有则新建节点接到第v棵树上（负责把第v棵树的这个区间“归零”）。<br>很显然，我们构造的这个区间在不同树之间是一个严格不减的“区间序列”（就是呢个意思，你懂. . .），每次操作相当于把第i棵树这个区间清零，以及让i+1这颗树加上第i棵树的答案。（由差分易得：将一个数加到后面的呢个数上只需要把这个数在差分序列里对应的呢个数变为前一项即可。）<br>用差分的一个好处就是可以在查询的时候用二分来找到一个区间的最大的v，由于我们建立的这个“差分主席树”的性质，假如一个区间最大值为v，呢么v以后的区间和不变并且v以前的区间和单调不减。（我最开始想用单纯的主席树搞的，但是就是卡在了查询这一步。加了差分这一性质就让这题可做了。）<br>以下是源码（看的呢份源码写的多了很多不必要的东西. .. 可读性很差，便删改了以下（可能是比赛代码加了些保全？））</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rep(i,x,y) for(int i=x; i&lt;=y; ++i)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> mid (l+r&gt;&gt;1)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">500005</span>,M=<span class="hljs-number">20000005</span>;<br><span class="hljs-keyword">int</span> n,q,ql,qr,tp,x,root[N],ls[M],rs[M],sonnum[M],tot;<br>   <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> ch;<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(ch=getchar()));<br>    <span class="hljs-keyword">int</span> x=ch<span class="hljs-number">-48</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(ch=getchar())) x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br>   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> &amp;rt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!rt) rt=++tot;<br>    <span class="hljs-keyword">if</span>(l==r) &#123;sonnum[rt]=<span class="hljs-number">1</span>; <span class="hljs-keyword">return</span>;&#125;<br>    build(l,mid,ls[rt]);<br>    build(mid+<span class="hljs-number">1</span>,r,rs[rt]);<br>    sonnum[rt]=sonnum[ls[rt]]+sonnum[rs[rt]];<br>&#125;<br>   <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> rt)</span><span class="hljs-comment">//求该树该区间的节点个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) <span class="hljs-keyword">return</span> sonnum[rt];<br>    <span class="hljs-keyword">if</span>(qr&lt;=mid) <span class="hljs-keyword">return</span> query(l,mid,ls[rt]);<br>    <span class="hljs-keyword">if</span>(ql&gt;mid) <span class="hljs-keyword">return</span> query(mid+<span class="hljs-number">1</span>,r,rs[rt]);<br>    <span class="hljs-keyword">return</span> query(l,mid,ls[rt])+query(mid+<span class="hljs-number">1</span>,r,rs[rt]);<br>&#125;<br>   <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ins</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> &amp;rt,<span class="hljs-keyword">int</span> lastrt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(sonnum[rt]-sonnum[lastrt]&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;rt=lastrt; <span class="hljs-keyword">return</span>;&#125;<br>    ++tot,ls[tot]=ls[rt],rs[tot]=rs[rt],rt=tot;<br>    <span class="hljs-keyword">if</span>(ql&lt;=mid) ins(l,mid,ls[rt],ls[lastrt]);<br>    <span class="hljs-keyword">if</span>(mid&lt;qr) ins(mid+<span class="hljs-number">1</span>,r,rs[rt],rs[lastrt]);<br>    sonnum[rt]=sonnum[ls[rt]]+sonnum[rs[rt]];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span><br>    n=<span class="hljs-built_in">read</span>(),q=<span class="hljs-built_in">read</span>();<br>    build(<span class="hljs-number">1</span>,n,root[<span class="hljs-number">0</span>]);<br>    rep(i,<span class="hljs-number">1</span>,q) root[i]=root[<span class="hljs-number">0</span>];<br>    rep(i,<span class="hljs-number">1</span>,q)<br>    &#123;<br>        <span class="hljs-keyword">int</span> tp=<span class="hljs-built_in">read</span>();ql=<span class="hljs-built_in">read</span>(),qr=<span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span>(tp==<span class="hljs-number">1</span>)<br>        &#123;<br>            x=<span class="hljs-built_in">read</span>();<br>            <span class="hljs-keyword">int</span> lastroot=x?root[x<span class="hljs-number">-1</span>]:<span class="hljs-number">0</span>;<br>            ins(<span class="hljs-number">1</span>,n,root[x],lastroot);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=q;<br>            <span class="hljs-keyword">while</span>(l&lt;=r)<br>            &#123;<br>                <span class="hljs-keyword">int</span> L=mid?query(<span class="hljs-number">1</span>,n,root[mid<span class="hljs-number">-1</span>]):<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">int</span> R=r&gt;=<span class="hljs-number">0</span>?query(<span class="hljs-number">1</span>,n,root[r]):<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(R-L) l=mid+<span class="hljs-number">1</span>; <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,l<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线段树辅助建图"><a href="#线段树辅助建图" class="headerlink" title="线段树辅助建图"></a>线段树辅助建图</h4><p>老算法了，整合一下<br><a href="https://linzeyin.github.io/2021/03/30/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%80%89%E6%8B%94-%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BE%85%E5%8A%A9%E5%BB%BA%E5%9B%BE/">快速跳转</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
      <category>线段树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>技巧</tag>
      
      <tag>数据结构</tag>
      
      <tag>区间问题</tag>
      
      <tag>线段树</tag>
      
      <tag>主席树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020沈阳icpc I 类欧几里得</title>
    <link href="/2021/08/20/%E6%95%B0%E8%AE%BA%20%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <url>/2021/08/20/%E6%95%B0%E8%AE%BA%20%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>  为了ccpc网络赛组了新队伍，拉了icpc2020沈阳来训练，然后被爆艹了。补题时学的新东西。</p><p>题意：给你一个H，一个M，一个A。一天有H个小时，一小时有M分钟，问你一天之内有多少整数分钟，时针和分针的角度差小于等于A</p><p>撕烤一下这个题目，就是在一个H大格，HM小格的表盘上，分针每分钟走H小格，时针每分钟走M小格，问相差A小格的整数分钟的数目。<br>呢么可以构造不等式：<br>_ <script type="math/tex">abs( k H \% (HM) - k) < = A</script> </p><p>_ <script type="math/tex">i HM − A ≤ k ( H − 1 ) ≤i HM + A</script></p><p>其中k是第k分钟，i是指分针已经走过了i圈，<br>所以我们只需要求满足不等式的(k,i)二元组的个数即可。<br>这时候就用到了<strong>类欧几里得算法</strong>，这个算法可以在<script type="math/tex">O(logn)</script>时间内得到 <script type="math/tex">F(a,b,c,n)=\sum^{n}_{i=0} \lfloor \frac{a*i+b}{c} \rfloor</script>，形象的理解可以理解为一条直线与x=0,y=0,x=n.四条直线围成的直角梯形区域有多少整点。<br><a href="https://oi-wiki.org/math/number-theory/euclidean/">算法的详细推导</a><br><a href="https://www.cnblogs.com/zjp-shadow/p/10601728.html">板子来源</a></p><p>代码：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br><span class="hljs-comment">#define ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>ll f(ll a, ll b, ll c, ll n) <br>&#123;<br><span class="hljs-keyword">if</span>(!a) <span class="hljs-keyword">return</span> b/c*(n+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(a&gt;=c||b&gt;=c)<br><span class="hljs-keyword">return</span> f(a%c,b%c,c,n)+(a/c)*n*(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>+(b/c)*(n+<span class="hljs-number">1</span>);<br>ll m=(a*n+b)/c;<br><span class="hljs-keyword">return</span> n*m<span class="hljs-operator">-f</span>(c,c<span class="hljs-literal">-b</span><span class="hljs-literal">-1</span>,a,m<span class="hljs-literal">-1</span>);<br>&#125;<br>int main()<br>&#123;<br>ll <span class="hljs-built_in">h</span>,m,a;<br>scanf(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;<span class="hljs-built_in">h</span>,&amp;m,&amp;a);<br>ll ans1=f(<span class="hljs-built_in">h</span>*m,a+<span class="hljs-built_in">h</span>*m,<span class="hljs-built_in">h</span><span class="hljs-literal">-1</span>,<span class="hljs-built_in">h</span><span class="hljs-literal">-3</span> );<br>ll ans2=f(<span class="hljs-built_in">h</span>*m,<span class="hljs-literal">-a</span>+<span class="hljs-built_in">h</span>*m<span class="hljs-literal">-1</span>,<span class="hljs-built_in">h</span><span class="hljs-literal">-1</span>,<span class="hljs-built_in">h</span><span class="hljs-literal">-3</span> );<br>ll ans=ans1<span class="hljs-literal">-ans2</span>;<br>ans+=(<span class="hljs-number">1</span>+a/(<span class="hljs-built_in">h</span><span class="hljs-literal">-1</span>))*<span class="hljs-number">2</span>;<br>ans--;<br><br>ans=min(ans,<span class="hljs-built_in">h</span>*m);//特判A=HM/<span class="hljs-number">2</span>的情况<br>printf(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>数论</tag>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021暑假训练赛总结汇总</title>
    <link href="/2021/08/19/2021%E7%89%9B%E5%AE%A2%E9%AB%98%E6%A0%A1%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E8%B5%9B%E8%AE%AD%E7%BB%83%E5%8F%8A%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB/"/>
    <url>/2021/08/19/2021%E7%89%9B%E5%AE%A2%E9%AB%98%E6%A0%A1%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E8%B5%9B%E8%AE%AD%E7%BB%83%E5%8F%8A%E6%80%BB%E7%BB%93%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>I have been took a long,awful,boring days,so I start writing,I hope it’s could work.<br>They took a lot of places in my blog. So I hide them and put their Links in there.</p><p><a href="/2021/07/17/2021牛客高校暑假训练赛一/">Link1</a><br><a href="/2021/07/19/2021牛客高校暑假训练赛二/">Link2</a><br><a href="/2021/07/25/2021牛客高校暑假训练赛三/">Link3</a><br><a href="/2021/07/27/2021牛客高校暑假训练赛四/">Link4</a><br><a href="/2021/08/01/2021牛客高校暑假训练赛五/">Link5</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>2021</category>
      
      <category>比赛</category>
      
      <category>暑期牛客高校训练赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>牛客</tag>
      
      <tag>icpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KLT实现目标动态追踪</title>
    <link href="/2021/07/24/KLT%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA-python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/07/24/KLT%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA-python%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>当时英才计划的时候吴老师曾经介绍过这个算法，不过当时我还很嘴巴选手所以并没有怎么去试着实现。前几天的江苏数学建模省赛有一题是用到了计算机视觉里的路径追踪。想起了老师曾经讲过，便重新学了下这个算法。<br>和我对神经网络的理解一样，我认为需要知道其背后原理，实际使用可以试着直接调用库来节省时间。</p><h3 id="Kanade-Lucas-Tomasi方法"><a href="#Kanade-Lucas-Tomasi方法" class="headerlink" title="Kanade-Lucas-Tomasi方法"></a>Kanade-Lucas-Tomasi方法</h3><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_image</span>(<span class="hljs-params">image,addr,num</span>):</span><br>  address = addr + <span class="hljs-built_in">str</span>(num)+ <span class="hljs-string">&#x27;.jpg&#x27;</span><br>  cv.imwrite(address,image)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Frame_Reading</span>(<span class="hljs-params">video_path, image_path</span>):</span><br>    video_capture = cv2.VideoCapture(video_path)<br>    images = []<br>    idx = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        ret, frame = video_capture.read()<br>        <span class="hljs-keyword">if</span> ret:<br>            idx = idx + <span class="hljs-number">1</span><br>            image = Image.fromarray(cv2.cvtColor(frame,cv2.COLOR_BGR2RGB))<br>            image_file=image_path+<span class="hljs-string">&#x27;/image_&#x27;</span>+<span class="hljs-built_in">str</span>(idx)+<span class="hljs-string">&#x27;.jpg&#x27;</span><br>            print(image_file)<br>            image.save(image_file)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br><br>lk_params = <span class="hljs-built_in">dict</span>( winSize  = (<span class="hljs-number">30</span>, <span class="hljs-number">30</span>),<br>                  maxLevel = <span class="hljs-number">2</span>,<br>                  criteria = (cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, <span class="hljs-number">10</span>, <span class="hljs-number">0.03</span>))<br><br>feature_params = <span class="hljs-built_in">dict</span>( maxCorners = <span class="hljs-number">500</span>,<br>                       qualityLevel = <span class="hljs-number">0.3</span>,<br>                       minDistance = <span class="hljs-number">7</span>,<br>                       blockSize = <span class="hljs-number">1</span> )<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, video_src</span>):</span><br>        self.track_len = <span class="hljs-number">10</span><br>        self.detect_interval = <span class="hljs-number">5</span><br>        self.tracks = []<br>        self.cam = cv.VideoCapture(video_src)<br>        self.frame_idx = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            _ret, frame = self.cam.read()<br>            <span class="hljs-keyword">if</span> _ret <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-comment">#save_image(frame,frame1,j)</span><br>            frame_gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)<br>            <span class="hljs-comment">#frame1 = cv.fastNlMeansDenoisingColored(frame_gray,None,10,10,7,21)</span><br>            vis = frame.copy()<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.tracks) &gt; <span class="hljs-number">0</span>:<br>                img0, img1 = self.prev_gray, frame_gray<br>                p0 = np.float32([tr[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> tr <span class="hljs-keyword">in</span> self.tracks]).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>                p1, _st, _err = cv.calcOpticalFlowPyrLK(img0, img1, p0, <span class="hljs-literal">None</span>, **lk_params)<br>                d = <span class="hljs-built_in">abs</span>(p1-p0).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).<span class="hljs-built_in">max</span>(-<span class="hljs-number">1</span>)<br>                good = d &gt; <span class="hljs-number">1</span><br><br>                new_tracks = []<br>                <span class="hljs-keyword">for</span> tr, (x, y), good_flag <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.tracks, p1.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), good):<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> good_flag:<br>                        <span class="hljs-keyword">continue</span><br>                    tr.append((x, y))<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tr) &gt; self.track_len:<br>                        <span class="hljs-keyword">del</span> tr[<span class="hljs-number">0</span>]<br>                    new_tracks.append(tr)<br>                    cv.circle(vis, (<span class="hljs-built_in">int</span>(x), <span class="hljs-built_in">int</span>(y)), <span class="hljs-number">2</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)<br>                self.tracks = new_tracks<br>                cv.polylines(vis, [np.int32(tr) <span class="hljs-keyword">for</span> tr <span class="hljs-keyword">in</span> self.tracks], <span class="hljs-literal">False</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>))<br><br>            <span class="hljs-keyword">if</span> self.frame_idx % self.detect_interval == <span class="hljs-number">0</span>:<br>                mask = np.zeros_like(frame_gray)<br>                mask[:] = <span class="hljs-number">255</span><br>                <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> [np.int32(tr[-<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> tr <span class="hljs-keyword">in</span> self.tracks]:<br>                    cv.circle(mask, (<span class="hljs-built_in">int</span>(x), <span class="hljs-built_in">int</span>(y)), <span class="hljs-number">5</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)<br>                p = cv.goodFeaturesToTrack(frame_gray, mask = mask, **feature_params)<br>                <span class="hljs-keyword">if</span> p <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> np.float32(p).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>):<br>                        self.tracks.append([(x, y)])<br>                        <br>            <br>            <span class="hljs-keyword">if</span> self.frame_idx%<span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                save_image(vis,<span class="hljs-string">&#x27;./output/West/image&#x27;</span>,self.frame_idx)<br>            <br>            self.frame_idx += <span class="hljs-number">1</span><br>            self.prev_gray = frame_gray<br>            cv.namedWindow(<span class="hljs-string">&quot;lk_track&quot;</span>,<span class="hljs-number">0</span>)<br>            cv.resizeWindow(<span class="hljs-string">&quot;lk_track&quot;</span>, <span class="hljs-number">1200</span>,<span class="hljs-number">800</span>)<br>            cv.imshow(<span class="hljs-string">&#x27;lk_track&#x27;</span>, vis)<br><br>            ch = cv.waitKey(<span class="hljs-number">30</span>)<br>            <span class="hljs-keyword">if</span> ch == <span class="hljs-number">27</span>:<br>                <span class="hljs-keyword">break</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">import</span> sys<br>    <span class="hljs-keyword">try</span>:<br>        video_src = sys.argv[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">except</span>:<br>        video_src = <span class="hljs-string">&quot;./附件/附件五_西口/20210311112657.mp4&quot;</span><span class="hljs-comment">#相对地址和绝对地址好像都行</span><br>    <br>    Work(video_src).run()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br>    cv.destroyAllWindows()<br><br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>数学建模</tag>
      
      <tag>KLT</tag>
      
      <tag>opencv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tensorflow学习&amp;深度学习实操(1)</title>
    <link href="/2021/07/18/Tensorflow%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/07/18/Tensorflow%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>其实高三的时候学习神经网络的时候就了解到有这么个东西了，当时是在知乎上看到了一位学长的文章入了神经网络的坑，跟着呢个学长的文章学习了许多，并且自己试着用c++实现了下简单的DNN和CNN，<br><img src="/img/postpictures/asdfdsgvfdcv cxzvre.png" alt="这是当时码的，虽然十分简单但是拥有完整的正向反向传播梯度下降等"><br>然后由于码量较大，只是做了两三个训练就废弃了。后来发现了有现成的库可以直接使用，不过当时找到的资料都是python+Tensorflow的组合，由于自己当时对PY不是太熟就没怎么学。最近一段时间学了些python的知识，并且数学建模需要神经网络来拟合，于是开一档记录Tensorflow的使用学习。</p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="matplotlib库"><a href="#matplotlib库" class="headerlink" title="matplotlib库"></a>matplotlib库</h4><p>Matplotlib 是 Python 的绘图库。 它可与 NumPy 一起使用，提供了一种有效的 MatLab 开源替代方案。 它也可以和图形工具包一起使用，如 PyQt 和 wxPython。</p><h4 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h4><p>虽然我们可以直接调用APi，但是对于网络原理还是需要必要的了解的。以及对一些名词要有理解<br>我个人是看这位华师的学长的<a href="https://www.zhihu.com/column/ComputerVision">文章</a>，（就是高三的时候学的那些东西）</p><h4 id="xlwings库"><a href="#xlwings库" class="headerlink" title="xlwings库"></a>xlwings库</h4><p>一个处理excal的库，比较方便<br>实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xlwings <span class="hljs-keyword">as</span> xw <span class="hljs-comment"># 载入</span><br><br>output=<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;a.out&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment">#记录保存地址</span><br>wb = xw.Book(<span class="hljs-string">&#x27;1.xlsx&#x27;</span>)<span class="hljs-comment"># 打开excal文档</span><br>sht = wb.sheets[<span class="hljs-number">0</span>] <span class="hljs-comment"># 选择所需操作的sheet</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">12</span>) : <span class="hljs-comment"># 取1到12列</span><br>    Row=<span class="hljs-built_in">chr</span>(i+<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) :<span class="hljs-comment"># 取1到3行</span><br>        Range=<span class="hljs-built_in">str</span>(j)<br>        b = sht[Row+Range].value <span class="hljs-comment"># sht[X]中X格式为‘字母+数字’，如‘B7’</span><br>        print(b,file=output)<br></code></pre></td></tr></table></figure><br>更多操作可以看知乎<a href="https://zhuanlan.zhihu.com/p/237583143">文章</a></p><h3 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h3><p>引用一段Keras官网的话：</p><blockquote><p>Keras 是一个用 Python 编写的高级神经网络 API，它能够以 TensorFlow, CNTK, 或者 Theano 作为后端运行。Keras 的开发重点是支持快速的实验。能够以最小的时延把你的想法转换为实验结果，是做好研究的关键。</p></blockquote><p>Keras 的核心数据结构是 model，一种组织网络层的方式。最简单的模型是 Sequential 顺序模型，它是由多个网络层线性堆叠的模型形式。</p><p>载入Sequential模型<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">from keras.models <span class="hljs-keyword">import</span> <span class="hljs-keyword">Sequential</span><br>model = <span class="hljs-keyword">Sequential</span>()<br></code></pre></td></tr></table></figure></p><hr><p>添加网络层时可以直接使用add函数来叠加<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> keras.layers import Dense<br>model.<span class="hljs-builtin-name">add</span>(Dense(<span class="hljs-attribute">units</span>=64, <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;relu&#x27;</span>, <span class="hljs-attribute">input_dim</span>=100))<br>model.<span class="hljs-builtin-name">add</span>(Dense(<span class="hljs-attribute">units</span>=10, <span class="hljs-attribute">activation</span>=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br></code></pre></td></tr></table></figure></p><hr><p>使用compile 来配置学习过程<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">model<span class="hljs-selector-class">.compile</span>(loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>,optimizer=<span class="hljs-string">&#x27;sgd&#x27;</span>,metrics=<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;accuracy&#x27;</span>]</span>)<br></code></pre></td></tr></table></figure><br>参数:</p><p><strong>optimizer:</strong> 优化器</p><pre><code>optimizer的参数：lr：大或等于0的浮点数，学习率momentum：大或等于0的浮点数，动量参数decay：大或等于0的浮点数，每次更新后的学习率衰减值nesterov：布尔值，确定是否使用Nesterov动量</code></pre><p><strong>loss:</strong>损失函数,可以用自带的,也可以自定义.如果模型有多个输出,可以传入一个losslist,模型降会把这些损失加在一起<br><strong>metrics:</strong> 评价函数,与损失函数类似,只不过评价函数的结果不会用于训练过程中,可以传递已有的评价函数名称,或者传递一个自定义的函数来使用</p><pre><code>自带的评价函数有:binary_accuracy(y_true,y_pred), categorical_accuracy(y_true,y_pred),sparse_categorical_accuracy(y_true,y_pred), top_k_categorical_accuracy(y_true,y_pred,k=5).自定义评价函数应该在编译的时候compile传递进去,该函数需要以(y_true,y_pred)作为输入参数,并返回一个张量作为输出结果.</code></pre><p><strong>loss_weights:</strong>可选项,是一个list或字典,指定不同的损失的权重</p><p><strong>sample_weight_mode:</strong> 如果你需要执行按时间步采样权重（2D 权重），请将其设置为 temporal。 默认为 None，为采样权重（1D）。 如果模型有多个输出，则可以通过传递 mode 的字典或列表，以在每个输出上使用不同的 sample_weight_mode。<br><strong>weighted_metrics:</strong> 在训练和测试期间，由 sample_weight 或 class_weight 评估和加权的度量标准列表。<br><strong>target_tensors:</strong> 默认情况下，Keras 将为模型的目标创建一个占位符，在训练过程中将使用目标数据。 相反，如果你想使用自己的目标张量（反过来说，Keras 在训练期间不会载入这些目标张量的外部 Numpy 数据）， 您可以通过 target_tensors 参数指定它们。 它可以是单个张量（单输出模型），张量列表，或一个映射输出名称到目标张量的字典。<br><strong>kwargs:</strong> 当使用 Theano/CNTK 后端时，这些参数被传入 K.function。 当使用 TensorFlow 后端时，这些参数被传递到 tf.Session.run。</p><p>一些compile的参数<a href="https://blog.csdn.net/sinat_16388393/article/details/93207842">学习</a></p><hr><p>开始训练！<br>使用fit</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># x_train 和 y_train 是 Numpy 数组</span><br>model.fitfit(x_train, y_train, <span class="hljs-attribute">batch_size</span>=None, <span class="hljs-attribute">epochs</span>=1, <span class="hljs-attribute">verbose</span>=1, <span class="hljs-attribute">callbacks</span>=None, <span class="hljs-attribute">validation_split</span>=0.0, <span class="hljs-attribute">validation_data</span>=None, <span class="hljs-attribute">shuffle</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">class_weight</span>=None, <span class="hljs-attribute">sample_weight</span>=None, <span class="hljs-attribute">initial_epoch</span>=0, <span class="hljs-attribute">steps_per_epoch</span>=None, <span class="hljs-attribute">validation_steps</span>=None)<br></code></pre></td></tr></table></figure><p><strong>x_train:</strong> 训练数据的 Numpy 数组（如果模型只有一个输入）， 或者是 Numpy 数组的列表（如果模型有多个输入）。 如果模型中的输入层被命名，你也可以传递一个字典，将输入层名称映射到 Numpy 数组。 如果从本地框架张量馈送（例如 TensorFlow 数据张量）数据，x 可以是 None（默认）。<br><strong>y_train:</strong> 目标（标签）数据的 Numpy 数组（如果模型只有一个输出）， 或者是 Numpy 数组的列表（如果模型有多个输出）。 如果模型中的输出层被命名，你也可以传递一个字典，将输出层名称映射到 Numpy 数组。 如果从本地框架张量馈送（例如 TensorFlow 数据张量）数据，y 可以是 None（默认）。<br><strong>batch_size:</strong> 整数或 None。每次梯度更新的样本数。如果未指定，默认为 32。<br><strong>epochs:</strong> 整数。训练模型迭代轮次。一个轮次是在整个 x 和 y 上的一轮迭代。 请注意，与 initial_epoch 一起，epochs 被理解为 「最终轮次」。模型并不是训练了 epochs 轮，而是到第 epochs 轮停止训练。<br><strong>verbose:</strong> 0, 1 或 2。日志显示模式。 0 = 安静模式, 1 = 进度条, 2 = 每轮一行。<br><strong>callbacks:</strong>一系列可以在训练时使用的回调函数。<br><strong>validation_split:</strong> 0 和 1 之间的浮点数。用作验证集的训练数据的比例。 模型将分出一部分不会被训练的验证数据，并将在每一轮结束时评估这些验证数据的误差和任何其他模型指标。 验证数据是混洗之前 x 和y 数据的最后一部分样本中。<br><strong>validation_data:</strong> 元组 (x_val，y_val) 或元组 (x_val，y_val，val_sample_weights)， 用来评估损失，以及在每轮结束时的任何模型度量指标。 模型将不会在这个数据上进行训练。这个参数会覆盖 validation_split。<br><strong>shuffle:</strong>布尔值（是否在每轮迭代之前混洗数据）或者 字符串 (batch)。 batch 是处理 HDF5 数据限制的特殊选项，它对一个 batch 内部的数据进行混洗。 当 steps_per_epoch 非 None 时，这个参数无效。<br><strong>class_weight:</strong> 可选的字典，用来映射类索引（整数）到权重（浮点）值，用于加权损失函数（仅在训练期间）。 这可能有助于告诉模型 「更多关注」来自代表性不足的类的样本。<br><strong>sample_weight:</strong> 训练样本的可选 Numpy 权重数组，用于对损失函数进行加权（仅在训练期间）。 可以传递与输入样本长度相同的平坦（1D）Numpy 数组（权重和样本之间的 1:1 映射）， 或者在时序数据的情况下，可以传递尺寸为 (samples, sequence_length) 的 2D 数组，以对每个样本的每个时间步施加不同的权重。 在这种情况下，应该确保在 compile() 中指定 sample_weight_mode=”temporal”。<br><strong>initial_epoch:</strong> 整数。开始训练的轮次（有助于恢复之前的训练）。<br><strong>steps_per_epoch:</strong> 整数或 None。 在声明一个轮次完成并开始下一个轮次之前的总步数（样品批次）。 使用 TensorFlow 数据张量等输入张量进行训练时，默认值 None 等于数据集中样本的数量除以 batch 的大小，如果无法确定，则为 1。<br><strong>validation_steps:</strong> 只有在指定了 steps_per_epoch 时才有用。停止前要验证的总步数（批次样本）。</p><p>fit的返回是一个 History 对象。其 History.history 属性是连续 epoch 训练损失和评估值，以及验证集损失和评估值的记录（如果适用）<br>相关keras源码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">History</span>(<span class="hljs-params">Callback</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Callback that records events into a `History` object.</span><br><span class="hljs-string">    This callback is automatically applied to</span><br><span class="hljs-string">    every Keras model. The `History` object</span><br><span class="hljs-string">    gets returned by the `fit` method of models.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_train_begin</span>(<span class="hljs-params">self, logs=<span class="hljs-literal">None</span></span>):</span><br>        self.epoch = []<br>        self.history = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_epoch_end</span>(<span class="hljs-params">self, epoch, logs=<span class="hljs-literal">None</span></span>):</span><br>        logs = logs <span class="hljs-keyword">or</span> &#123;&#125;<br>        self.epoch.append(epoch)<br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> logs.items():<br>            self.history.setdefault(k, []).append(v)<br></code></pre></td></tr></table></figure><br>可以看出History类对象包含两个属性，分别为epoch和history</p><hr><p>evaluate在测试模式下返回模型的误差值和评估标准值。计算是分批进行的。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">evaluate(<span class="hljs-attribute">x</span>=None, <span class="hljs-attribute">y</span>=None, <span class="hljs-attribute">batch_size</span>=None, <span class="hljs-attribute">verbose</span>=1, <span class="hljs-attribute">sample_weight</span>=None, <span class="hljs-attribute">steps</span>=None)<br></code></pre></td></tr></table></figure><br><strong>x:</strong> 测试数据的 Numpy 数组（如果模型只有一个输入）， 或者是 Numpy 数组的列表（如果模型有多个输入）。 如果模型中的输入层被命名，你也可以传递一个字典，将输入层名称映射到 Numpy 数组。<br><strong>y:</strong> 目标（标签）数据的 Numpy 数组，或 Numpy 数组的列表（如果模型具有多个输出）。 如果模型中的输出层被命名，你也可以传递一个字典，将输出层名称映射到 Numpy 数组。<br>batch_size: 整数或 None。每次评估的样本数。如果未指定，默认为 32。<br><strong>verbose:</strong> 0 或 1。日志显示模式。 0 = 安静模式，1 = 进度条。<br><strong>sample_weight:</strong> 测试样本的可选 Numpy 权重数组，用于对损失函数进行加权。 可以传递与输入样本长度相同的扁平（1D）Numpy 数组（权重和样本之间的 1:1 映射）， 或者在时序数据的情况下，传递尺寸为 (samples, sequence_length) 的 2D 数组，以对每个样本的每个时间步施加不同的权重。 在这种情况下，应该确保在 compile() 中指定 sample_weight_mode=”temporal”。<br><strong>steps:</strong> 整数或 None。 声明评估结束之前的总步数（批次样本）。默认值 None。</p><p>返回值是一个标量测试误差（如果模型只有一个输出且没有评估标准） 或标量列表（如果模型具有多个输出 和/或 评估指标）。 属性 model.metrics_names 将提供标量输出的显示标签</p><hr><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>做江苏数学建模省赛时想用神经网络对数据集进行预测而码，结果不尽人意. ..再次记录，等修改<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs dns">import tensorflow as tf<br>from tensorflow import keras<br>from keras.models import Sequential<br>from keras.layers import Dense, Activation<br>from keras.callbacks import ModelCheckpoint<br>import numpy as np<br><br>keras.optimizers.SGD(lr=<span class="hljs-number">0</span>.<span class="hljs-number">01</span>, momentum=<span class="hljs-number">0</span>.<span class="hljs-number">0</span>, decay=<span class="hljs-number">0</span>.<span class="hljs-number">0</span>, nesterov=False)<br>#梯度下降优化器<br><br>output=open(&#x27;a.out&#x27;,&#x27;w&#x27;,<span class="hljs-number">1</span>,&#x27;utf-<span class="hljs-number">8</span>&#x27;) #记录保存地址<br><br>ns=np.array([<span class="hljs-number">90</span>.<span class="hljs-number">42</span>, <span class="hljs-number">5</span>.<span class="hljs-number">616</span>, <span class="hljs-number">26</span>.<span class="hljs-number">41</span>, <span class="hljs-number">4</span>.<span class="hljs-number">216</span>, <span class="hljs-number">6</span>.<span class="hljs-number">837</span>, <span class="hljs-number">28</span>.<span class="hljs-number">18</span>, <span class="hljs-number">72</span>.<span class="hljs-number">84</span>, <span class="hljs-number">31</span>.<span class="hljs-number">58</span>, <span class="hljs-number">5</span>.<span class="hljs-number">353</span>, <span class="hljs-number">25</span>.<span class="hljs-number">83</span>])<br>xs=np.array([[ <span class="hljs-number">70849.02</span>, <span class="hljs-number">64717.58</span>, <span class="hljs-number">2016.886</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3000</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">140583.486</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2431.162</span>, <span class="hljs-number">14798.85</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">17230.012</span>], [ <span class="hljs-number">53042.87</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">32898.43</span>, <span class="hljs-number">3017.841</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4000</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">92959.141</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2016.886</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20492.89</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22509.776</span>], [ <span class="hljs-number">59332.56</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">49087.32</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2309.934</span>, <span class="hljs-number">3020</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">113749.814</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">24685.94</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2318.845</span>, <span class="hljs-number">35198.66</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3000</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">65203.445</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3015.853</span>, <span class="hljs-number">18908.83</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2000</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">23924.683</span>], [ <span class="hljs-number">63356.26</span>, <span class="hljs-number">58102.85</span>, <span class="hljs-number">1789.986</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5000</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">128249.096</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">29048.39</span>, <span class="hljs-number">4903.955</span>, <span class="hljs-number">33952.345</span>], [ <span class="hljs-number">77905.24</span>, <span class="hljs-number">71053.95</span>, <span class="hljs-number">2218.854</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4000</span>.<span class="hljs-number">0</span>, <span class="hljs-number">155178.044</span>], [ <span class="hljs-number">53252.23</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1890</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2482.972</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">57625.202</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7470</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64363.52</span>, <span class="hljs-number">4125.733</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">75959.253</span>], [ <span class="hljs-number">73968.84</span>, <span class="hljs-number">67546.03</span>, <span class="hljs-number">2104.845</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">143619.715</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3110</span>.<span class="hljs-number">85</span>, <span class="hljs-number">0</span>, <span class="hljs-number">52531.42</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55642.27</span>], [ <span class="hljs-number">68946.43</span>, <span class="hljs-number">63056.18</span>, <span class="hljs-number">1963.863</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4000</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">138266.473</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">49153.19</span>, <span class="hljs-number">8314.933</span>, <span class="hljs-number">57468.123</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">43314.34</span>, <span class="hljs-number">3523.842</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3000</span>.<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">49838.182</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">21715.9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2027.372</span>, <span class="hljs-number">31177.86</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">54921.132</span>], [ <span class="hljs-number">10000.0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3017.751</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">49073.83</span>, <span class="hljs-number">0</span>, <span class="hljs-number">62091.581</span>], [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3024.342</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">49381.45</span>, <span class="hljs-number">0</span>, <span class="hljs-number">52405.792</span>]])<br>ys=np.array([ <span class="hljs-number">24</span>.<span class="hljs-number">17</span>, <span class="hljs-number">5</span>.<span class="hljs-number">462</span>, <span class="hljs-number">30</span>.<span class="hljs-number">913</span>, <span class="hljs-number">66</span>.<span class="hljs-number">511</span>, <span class="hljs-number">26</span>.<span class="hljs-number">944</span>, <span class="hljs-number">21</span>.<span class="hljs-number">234</span>, <span class="hljs-number">5</span>.<span class="hljs-number">42</span>, <span class="hljs-number">22</span>.<span class="hljs-number">604</span>, <span class="hljs-number">6</span>.<span class="hljs-number">719</span>, <span class="hljs-number">24</span>.<span class="hljs-number">099</span>, <span class="hljs-number">77</span>.<span class="hljs-number">765</span>, <span class="hljs-number">55</span>.<span class="hljs-number">158</span>, <span class="hljs-number">24</span>.<span class="hljs-number">035</span>, <span class="hljs-number">7</span>.<span class="hljs-number">374</span>, <span class="hljs-number">24</span>.<span class="hljs-number">136</span>, <span class="hljs-number">6</span>.<span class="hljs-number">722</span>, <span class="hljs-number">8</span>.<span class="hljs-number">286</span>, <span class="hljs-number">22</span>.<span class="hljs-number">795</span>, <span class="hljs-number">9</span>.<span class="hljs-number">12,5.869</span>])<br><br><br>model=keras.Sequential()<br>model.add(Dense(<span class="hljs-number">20</span>, input_dim=<span class="hljs-number">10</span>, kernel_initializer=&#x27;random_uniform&#x27;, activation=&#x27;relu&#x27;))<br>model.add(Dense(<span class="hljs-number">8</span>, kernel_initializer=&#x27;random_uniform&#x27;, activation=&#x27;relu&#x27;))<br>model.add(Dense(<span class="hljs-number">1</span>, kernel_initializer=&#x27;uniform&#x27;, activation=&#x27;sigmoid&#x27;))<br># Compile model<br><br>model.compile(loss=&#x27;binary_crossentropy&#x27;, optimizer = tf.keras.optimizers.SGD(lr = <span class="hljs-number">0</span>.<span class="hljs-number">1</span>), metrics=[&#x27;accuracy&#x27;])<br><br>#model.fit(xs,ys,epochs=<span class="hljs-number">5000</span>,callbacks=[checkpoint])<br><br>xxs=[]<br>for i in range(<span class="hljs-number">0</span>,<span class="hljs-number">19</span>):<br>    xxs.append([])<br>    for j in range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>):<br>        xxs[i].append(ns[j]*xs[i][j]/xs[i][<span class="hljs-number">10</span>])<br>    finx=np.array(xxs[i])<br>    model.fit(finx,ys, validation_split=<span class="hljs-number">0</span>.<span class="hljs-number">33</span>, epochs=<span class="hljs-number">10</span>, batch_size=<span class="hljs-number">1</span>, callbacks=checkpoint, verbose=<span class="hljs-number">0</span>)<br><br><br>model.summary() #打印神经网络结构，统计参数数目<br>#print(model.predict([<span class="hljs-number">10</span>.<span class="hljs-number">0</span>]),file=output)<br>#print(model.predict([<span class="hljs-number">20</span>.<span class="hljs-number">0</span>]),file=output)<br>output.close()<br><br><br></code></pre></td></tr></table></figure></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>python</tag>
      
      <tag>tensorflow</tag>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>±1RMQ（约束RMQ）</title>
    <link href="/2021/05/27/%E5%B7%AE1RMQ/"/>
    <url>/2021/05/27/%E5%B7%AE1RMQ/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>±1RMQ是针对特殊的数据(对数组中所有元素都有 <script type="math/tex">|A_i-A_{i+1}|=1</script> )，可以将RMQ $ O(nlogn) $复杂度的预处理优化到 $ O(n)$ 复杂度。</p><p>待更：<a href="https://blog.csdn.net/qq_36909245/article/details/80055114">https://blog.csdn.net/qq_36909245/article/details/80055114</a><br>    <a href="https://kewth.github.io/2019/10/11/RMQ/">https://kewth.github.io/2019/10/11/RMQ/</a><br>笛卡尔树优化过的rmq<br>代码源于<a href="https://www.luogu.com.cn/blog/qwaszx/solution-p3865">洛谷</a></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">int</span> n,m,w[<span class="hljs-number">2000000</span>],lg2[<span class="hljs-number">1500000</span>];<br><span class="hljs-keyword">int</span> pos[<span class="hljs-number">1500000</span>],lst[<span class="hljs-number">1500000</span>],dep[<span class="hljs-number">1500000</span>],id,mm,S,ch[<span class="hljs-number">1500000</span>][<span class="hljs-number">2</span>],<span class="hljs-built_in">stack</span>[<span class="hljs-number">1500000</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LIM_RMQ</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> w[<span class="hljs-number">1500000</span>],bl[<span class="hljs-number">1500000</span>],blo,L[<span class="hljs-number">150000</span>],R[<span class="hljs-number">150000</span>],pos[<span class="hljs-number">10000</span>],val[<span class="hljs-number">150000</span>],minn[<span class="hljs-number">150000</span>],minpos[<span class="hljs-number">150000</span>],t[<span class="hljs-number">1000</span>],n_st;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ST_node</span>&#123;</span><span class="hljs-keyword">int</span> f,id;<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> ST_node &amp;tmp)<span class="hljs-keyword">const</span>&#123;<span class="hljs-keyword">return</span> f&lt;tmp.f;&#125;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">STable</span></span><br><span class="hljs-class">&#123;</span><br>ST_node a[<span class="hljs-number">4</span>][<span class="hljs-number">12</span>];<span class="hljs-comment">//n=1e6的话logn/2只有9...所以放心开</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w[],<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)a[<span class="hljs-number">0</span>][i]=(ST_node)&#123;w[i],i&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=n;i++)<span class="hljs-comment">//st表，不过要同时处理出最小值所在的位置</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j+(<span class="hljs-number">1</span>&lt;&lt;i)<span class="hljs-number">-1</span>&lt;=n;j++)<br>a[i][j]=<span class="hljs-built_in">min</span>(a[i<span class="hljs-number">-1</span>][j],a[i<span class="hljs-number">-1</span>][j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))]);<br>&#125;<br><span class="hljs-function">ST_node <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> len=lg2[r-l+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(a[len][l],a[len][r-(<span class="hljs-number">1</span>&lt;&lt;len)+<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;st[<span class="hljs-number">10000</span>];<span class="hljs-comment">//这里只有sqrt(n)个，也不用开这么大</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">STable_block</span></span><br><span class="hljs-class">&#123;</span><br>ST_node a[<span class="hljs-number">20</span>][<span class="hljs-number">150000</span>];<span class="hljs-comment">//这个占空间最大了吧...不过也只是O(n)的</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">int</span> w[],<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)a[<span class="hljs-number">0</span>][i]=(ST_node)&#123;w[i],i&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j+(<span class="hljs-number">1</span>&lt;&lt;i)<span class="hljs-number">-1</span>&lt;=n;j++)<br>a[i][j]=<span class="hljs-built_in">min</span>(a[i<span class="hljs-number">-1</span>][j],a[i<span class="hljs-number">-1</span>][j+(<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))]);<br>&#125;<br><span class="hljs-function">ST_node <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> len=lg2[r-l+<span class="hljs-number">1</span>];<span class="hljs-comment">//细节，math库的log2函数不能看做O(1)的，要提前处理</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(a[len][l],a[len][r-(<span class="hljs-number">1</span>&lt;&lt;len)+<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;st_block;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)w[i]=a[i];<br>lg2[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)lg2[i]=lg2[i&gt;&gt;<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<span class="hljs-comment">//处理log2</span><br>blo=<span class="hljs-built_in">max</span>(lg2[n]&gt;&gt;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//分块</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)bl[i]=(i<span class="hljs-number">-1</span>)/blo+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=bl[n];i++)L[i]=(i<span class="hljs-number">-1</span>)*blo+<span class="hljs-number">1</span>,R[i]=<span class="hljs-built_in">min</span>(i*blo,n),minn[i]=inf;<br>w[<span class="hljs-number">0</span>]=w[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=bl[n];i++)<br>&#123;<br><span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>,nn=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=L[i];j&lt;=R[i];j++)<br>&#123;<br>t[++nn]=w[j],tmp=tmp&lt;&lt;<span class="hljs-number">1</span>|(w[j]-w[j<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(w[j]&lt;minn[i])minn[i]=w[j],minpos[i]=j;<br>                <span class="hljs-comment">//可以用一个状压来表示本质</span><br>&#125;<br><span class="hljs-keyword">if</span>(!pos[tmp])st[pos[tmp]=++n_st].make(t,nn);<br>val[i]=pos[tmp];<span class="hljs-comment">//记下每个块属于哪一个本质</span><br>&#125;<br>st_block.make(minn,bl[n]);<span class="hljs-comment">//块间rmq</span><br>&#125;<br><span class="hljs-function">ST_node <span class="hljs-title">query_block</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;ST_node t=st[val[id]].query(l-L[id]+<span class="hljs-number">1</span>,r-L[id]+<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> (ST_node)&#123;t.f,t.id+L[id]<span class="hljs-number">-1</span>&#125;;&#125;<br>    <span class="hljs-comment">//实际位置=块左端点+块内查询位置-1，如果你把块内查询从0开始写就可以省略-1</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> bll=bl[l],blr=bl[r];<br><span class="hljs-keyword">if</span>(bll==blr)<span class="hljs-keyword">return</span> query_block(bll,l,r).id;<span class="hljs-comment">//一个块</span><br><span class="hljs-keyword">int</span> ml=query_block(bll,l,R[bll]).id,mr=query_block(blr,L[blr],r).id,mm;<br><span class="hljs-keyword">if</span>(w[ml]&lt;w[mr])mm=ml;<span class="hljs-keyword">else</span> mm=mr;<span class="hljs-comment">//两端零散块</span><br><span class="hljs-keyword">if</span>(bll+<span class="hljs-number">1</span>&lt;=blr<span class="hljs-number">-1</span>)<span class="hljs-comment">//整块</span><br>&#123;<br><span class="hljs-keyword">int</span> mmid=minpos[st_block.query(bll+<span class="hljs-number">1</span>,blr<span class="hljs-number">-1</span>).id];<br><span class="hljs-keyword">if</span>(w[mmid]&lt;w[mm])mm=mmid;<br>&#125;<br><span class="hljs-keyword">return</span> mm;<br>&#125;<br>&#125;a;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> depth)</span></span><br><span class="hljs-function"></span>&#123;<br>lst[u]=++id,pos[id]=u;dep[id]=depth;<span class="hljs-comment">//处理欧拉序列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1</span>;i++)<br><span class="hljs-keyword">if</span>(ch[u][i])<br>&#123;<br>dfs(ch[u][i],depth+<span class="hljs-number">1</span>);<br>pos[++id]=u,dep[id]=depth;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getin</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">char</span> ch=getchar();<br><span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)ch=getchar();<br><span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)x=x*<span class="hljs-number">10</span>+ch<span class="hljs-number">-48</span>,ch=getchar();<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-keyword">int</span> wt[<span class="hljs-number">30</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putout</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(!x)&#123;<span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(x)wt[++l]=x%<span class="hljs-number">10</span>,x/=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(l)<span class="hljs-built_in">putchar</span>(wt[l--]+<span class="hljs-number">48</span>);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">build_tree</span><span class="hljs-params">()</span><span class="hljs-comment">//笛卡尔树</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> top=<span class="hljs-number">1</span>;<span class="hljs-built_in">stack</span>[<span class="hljs-number">1</span>]=S=<span class="hljs-number">1</span>;<span class="hljs-comment">//开始根为1</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">int</span> lst=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(top&amp;&amp;w[i]&gt;w[<span class="hljs-built_in">stack</span>[top]])lst=<span class="hljs-built_in">stack</span>[top--];<br><span class="hljs-keyword">if</span>(lst)ch[i][<span class="hljs-number">0</span>]=lst;<br><span class="hljs-keyword">if</span>(top)ch[<span class="hljs-built_in">stack</span>[top]][<span class="hljs-number">1</span>]=i;<span class="hljs-keyword">else</span> S=i;<br><span class="hljs-built_in">stack</span>[++top]=i;<br>&#125;<br>dfs(S,<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>n=getin(),m=getin();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)w[i]=getin();<br>build_tree();<br>a.make(dep,id);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-keyword">int</span> l=lst[getin()],r=lst[getin()];<br><span class="hljs-keyword">if</span>(l&gt;r)swap(l,r);<span class="hljs-comment">//可能第一次出现的位置是反过来的</span><br>putout(w[pos[a.query(l,r)]]);<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概率论与数理统计</title>
    <link href="/2021/05/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    <url>/2021/05/18/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><pre><code>这里记录了一些关于概率论的学习总结，目的是为了加深记忆以及提升Latex编辑技巧</code></pre><hr><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><pre><code>一些基础的比较重要的但是没啥可说的都放到这里，想到啥写啥。</code></pre><h4 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h4><p>从n个不同的元素中，任取其中m个元素按照一定的顺序排成一列，叫做从n个不同元素中取出m个元素的一个排列。从n个不同的元素中，任取其中m个元素组成的排列的个数，叫做 <strong>从n个不同元素中取出m个元素的排列数</strong>，用符号 $P^m_n或 A^m_n$表示。<br><strong>计算公式 $A^m_n=n(n-1)…(n-m+1)=\frac{n!}{(n-m)!}$. 规定 0!=1;</strong></p><p><strong>注意：</strong><br>    当m = n时，称$A^m_n$为全排列;当m &lt; n时，称$A^m_n$为选排列<br>    全排列$A^n_n=n!$</p><h4 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h4><p>从n个不同的元素中，任取其中m个元素构成一组，叫做从n个不同元素中取出m个元素的一个组合。从n个不同的元素中，任取其中m个元素组成的组合的个数，叫做 <strong>从n个不同元素中取出m个元素的组合数</strong>，用符号$C^{m}_{n}$或$(^m_n)$表示。<br><strong>计算公式 $C^m_n = \frac{A^m_n}{m!}= \frac{n!}{m!(n-m)!}$.</strong></p><p><strong>基本的组合恒等式</strong> </p><script type="math/tex; mode=display">\begin{align*}& C^{r}_{n} = C^{n-r}_n \\& C_{n+1}^{r+1} = C_n^{r+1} + C_{n}^{r} \\& k \times C_{n}^{k}=n\times C^{k-1}_{n-1} \\& \sum_{k=0}^n C^{k}_{n_1} * C^{n-k}_{n_2}=C^{n}_{n_1+n_2} \\& C_{n}^{r} * C_r^m =C_{n}^{m}*C_{n-m}^{r-m} \\& \sum_{k=0}^n C^{k}_{n}=2^{n} \\& \sum_{k=0}^n (-1)^{k} * C^{k}_{n}=0 (由对称性易得)\\& \sum_{k=r}^n C_{k}^{r}=C^{r+1}_{k+1}\end{align*}</script><hr><h3 id="第一章-随机事件与概率"><a href="#第一章-随机事件与概率" class="headerlink" title="第一章 随机事件与概率"></a>第一章 随机事件与概率</h3><pre><code>这一章大多数内容都是高中知识，简单记一下知识点就可以了~~(bushi)~~</code></pre><h4 id="事件之间的关系与运算"><a href="#事件之间的关系与运算" class="headerlink" title="事件之间的关系与运算"></a>事件之间的关系与运算</h4><p><strong>包含</strong> A发生必然导致 B发生. $A \subset B$<br><strong>互斥</strong> A 和 B 不可能同时发生. <script type="math/tex">A \cap B= \emptyset</script><br><strong>独立</strong> 两事件相互独立与两事件互斥二者之间没有必然联系,满足<script type="math/tex">P(A)P(B)=P(AB)</script></p><p class="note note-danger">注意，ABC两两独立推不出来ABC相互独立，即$P(A)P(B)=P(AB);P(B)P(C)=P(BC);P(C)P(A)=P(CA)$无法推出$P(A)P(B)P(C)=P(ABC)$</p><p><strong>并事件(和事件)</strong> A 与 B 至少有一发生. $A \cup B$<br><strong>积事件(交事件)</strong> A 与 B 同时发生. $A \cap B$<br><strong>逆事件(对立事件)</strong> A 和 B 满足 <script type="math/tex">A \cup B = \Omega</script> 且 <script type="math/tex">AB= \emptyset , B= \overline{A}</script><br><strong>差事件</strong> A 发生，B 不发生. <script type="math/tex">A-B=A \cap \overline{B}=A \overline{B}</script></p><hr><p><strong>事件的运算律</strong><br><strong>交换律</strong> <script type="math/tex">A \cap B =B\cap A ; A \cup B =B\cup A</script> ;<br><strong>结合律</strong> <script type="math/tex">A \cup (B \cup C)=(A \cup B)\cup C ; A \cap (B \cap C)=(A \cap B)\cap C</script> ;<br><strong>分配律</strong> <script type="math/tex">A \cup (B \cap C)=(A \cup B)\cap (A \cup C) ; A \cap (B \cup C)=(A \cap B)\cup (A \cap C)</script> ;<br><strong>德摩根律</strong> <script type="math/tex">\overline{A \cup B} = \overline{A} \cap \overline{B} ; \overline{A \cap B} = \overline{A} \cup \overline{B}</script></p><hr><h4 id="奇怪的概型"><a href="#奇怪的概型" class="headerlink" title="奇怪的概型"></a>奇怪的概型</h4><p><strong>古典概型</strong><br>有限元素，可能性相同，概率为$P(A)=\frac{事件A中样本点数目}{样本点总数}$<br>超几何分布 共有N个样本点，其中有D个标记点，从中任取n件，其中恰有k个标记点的概率<br>$P(X=k)=\frac{C^{n-k}_{N-D}C^k_D}{C^n_N}$</p><p><strong>几何概型</strong></p><p>设 $\Omega$ 是欧氏空间的有限区域，样本空间的每个点取到是有可能的，这样的概型为几何概型。</p><p><strong>伯努利概型</strong><br>伯努利试验E：只有两个结果的试验。（例：正反、黑白球、成败等。）<br>n重伯努利试验: n次独立重复的伯努里试验。(相同条件,各次试验每个结果概率不变,各次试验结果独立)<br>定理(二项概率公式)：设事件A在一次实验中出现的概率为p，则在n重伯努利试验中A恰好出现k次的概率为$P_n(k)= C^k_n p^k(1-p)^{n-k} (k=0,1…n)$</p><hr><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p><strong>乘法公式</strong>  由条件概率定义可得$P(AB)=P(B)P(A|B)$<br><strong>全概率公式</strong>  假如 <script type="math/tex">A_1,A_2...A_n</script> 为 <script type="math/tex">\Omega</script> 的一个划分，则对任一随机事件B有 <script type="math/tex">P(B)=\sum_{i=1}^{n}P(A_i)P(B|A_i)</script><br><strong>贝叶斯公式</strong> B为<script type="math/tex">\Omega</script>中的一个事件，<script type="math/tex">A_1,A_2...A_n为\Omega</script>的一个有穷剖分,</p><script type="math/tex; mode=display">P(A_i|B)= \frac{P(A_i) P(B|A_i)}{ \sum^n_{i=1}P(A_i)P(B|A_i)}(i=1,2...n)</script><pre><code>乘法公式是求“几个事件同时发生”的概率；全概率公式可看作是求“最后结果”的概率；贝叶斯公式可看作是已知“最后结果” ，求“原因”的概率.</code></pre><hr><h3 id="第二章-一维随机变量及分布"><a href="#第二章-一维随机变量及分布" class="headerlink" title="第二章 一维随机变量及分布"></a>第二章 一维随机变量及分布</h3><p>随机变量分布函数<script type="math/tex">F(x)=P(X(\omega) \leq x)</script>的性质<br>1.F(x)单调非降<script type="math/tex">F(x_2)-F(x_1)=P(x_1 < X(\omega) < x_2 ) \geq 0</script><br>2.<script type="math/tex">0 \leq F(x) \leq 1, F(- \infty)=lim_{x \rightarrow -\infty}F(x)=0,F(+ \infty)=lim_{x \rightarrow +\infty}F(x)=1</script><br>3.F(x)在任何一点都是右连续的<script type="math/tex">F(x+0)=F(x)</script><br>任何随机变量的额分布满足这一性质(无论是连续还是离散)，具有这些性质的函数必为某一随机变量的分布函数。<br>边沿分布概率函数</p><h4 id="分布类型"><a href="#分布类型" class="headerlink" title="分布类型"></a>分布类型</h4><table class="table table-bordered table-striped table-condensed">        <tr>            <th width=30%>分布类型</th>            <th width=20%>记号</th>            <th width=30%>密度函数</th>            <th width=10%>期望</th>            <th width=10%>方差</th>        </tr>        <tr><td colspan=5 align=center>离散型随机变量的分布</th></tr>        <tr>            <th rowspan=1>伯努利分布/0-1分布</th>            <th>$$X \sim 0-1(p)$$</th>            <th>$$P(x=1)=p$$</th>            <th>$$p$$</th>            <th>$$p(1-p)$$</th>        </tr>        <tr>            <th rowspan=1>二项分布/n重伯努利分布</th>            <th>$$X \sim B(n,p)$$</th>            <th>$$P(X=k)=C_n^k p^k(1-p)^{n-k}$$</th>            <th>$$np$$</th>            <th>$$np(1-p)$$</th>        </tr>        <tr>            <th rowspan=1>几何分布</th>            <th>$$X \sim G(p)$$</th>            <th>$$P(x=k)=p(1-p)^{k-1}$$</th>            <th>$$1/p$$</th>            <th>$$(1-p)/p^2$$</th>        </tr>        <tr>            <th rowspan=1>泊松分布</th>            <th>$$X \sim \pi(\lambda)$$</th>            <th>$$P(x=k)=\frac{\lambda^{k} e^{- \lambda}}{k!}$$</th>            <th>$$\lambda$$</th>            <th>$$\lambda$$</th>        </tr>        <tr><td colspan=5 align=center>连续型随机变量的分布</th></tr>        <tr>            <th rowspan=1>均匀分布</th>            <th>$$X \sim U(a,b)$$</th>            <th>$$f(x)=\frac{1}{b-a} x\in (a,b)$$            $$f(x)=0 其他$$</th>            <th>$$\frac{a+b}{2}$$</th>            <th>$$\frac{(b-a)^2}{12}$$</th>        </tr>        <tr>            <th rowspan=1>指数分布</th>            <th>$$X \sim E(\lambda)$$</th>            <th>$$f(x)=\lambda e^{-\lambda x},x>0$$            $$f(x)=0,其他$$            </th>            <th>$$\frac{1}{\lambda}$$</th>            <th>$$\frac{1}{\lambda^2}$$</th>        </tr>        <tr>            <th rowspan=1>正态分布</th>            <th>$$X \sim N(\mu,\sigma^2)$$</th>            <th>$$f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$$</th>            <th>$$\mu$$</th>            <th>$$\sigma^2$$</th>        </tr>        <tr>            <th rowspan=1>标准正态分布</th>            <th>$$X \sim N(0,1)$$</th>            <th>$\varphi(x)=\frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}$ <br> 正态分布转标准正态分布的公式为$Z=\frac{X-\mu}{\sigma}$</th>            <th>$$0$$</th>            <th>$$1$$</th>        </tr>        <tr>            <th rowspan=1> $$ \mathcal{X}^2分布 $$ </th>            <th>$$Z \sim \mathcal{X}^2(n)$$</th>            <th> 设$(X_1,X_2,...,X_n)$均满足标准正态分布，令$Z=\sum_{i=1}^n X_i^2$，则Z服从的分布为$ \mathcal{X}^2 $ 分布<br>满足$\frac{(n-1)S^2}{\sigma ^2}=\sim \mathcal{X}^2(n-1)$的性质            </th>            <th>$$E \mathcal{X}^2(n)=n$$</th>            <th>$$D \mathcal{X}^2(n)=2n$$</th>        </tr>        <tr>            <th rowspan=1>  t分布  </th>            <th>$$Z \sim t(n)$$</th>            <th> 若$X\sim N(0,1),Y\sim \mathcal{X}^2(n)$，令$Z=\frac{X}{\sqrt{Y}/n}$，则Z服从的分布为t分布             <br>满足$\frac{\overline{X}-\mu}{\frac{S}{\sqrt{n}}}=\sim t(n-1)$的性质</th>            <th>$$EZ=0$$</th>            <th>$$DZ=\frac{n}{n-2}$$</th>        </tr></table><h3 id="第三章-分布函数"><a href="#第三章-分布函数" class="headerlink" title="第三章 分布函数"></a>第三章 分布函数</h3><h4 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h4><p>就是取到该点的概率。<br>没啥可说的</p><h4 id="边缘密度函数"><a href="#边缘密度函数" class="headerlink" title="边缘密度函数"></a>边缘密度函数</h4><p>实际上有很多种算法，举个例子，<br>关于x的边缘密度函数<script type="math/tex">Fx(x)=</script> <script type="math/tex">\begin{cases}  F(x,+\infty)=lim_{y\to \infty}F(x,y) \\ \int_{-\infty}^{x}f(x,y)dy \end{cases}</script><br>也就是对概率密度函数求正积分，对概率分布函数求歪导，就是某一个为变量时求以（它，另一个坐标无穷）为坐标为右上角的区块面积。</p><h3 id="第四章-随机变量的数字特征"><a href="#第四章-随机变量的数字特征" class="headerlink" title="第四章 随机变量的数字特征"></a>第四章 随机变量的数字特征</h3><h4 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h4><p>本质是概率分布的平均值</p><blockquote><p>定义式：<br>离散型：<script type="math/tex">E(X)=\sum_k^n xp_k</script><br>连续型：<script type="math/tex">E(X)=\int_{-\infty}^{\infty}xf(x)dx</script></p></blockquote><p>1.<script type="math/tex">E(c)=c</script>(c是常数)<br>2.<script type="math/tex">E(aX+b)=aE(X)+b</script>(ab是常数)<br>3.<script type="math/tex">E(X+Y)=E(X)+E(Y);E(X-Y)=E(X)-E(Y)</script><br>4.当<script type="math/tex">XY</script>独立时,<script type="math/tex">E(XY)=E(X)E(Y)</script><br>5.<script type="math/tex">(EXY)^2 \leq EX^2 EY^2</script></p><h4 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h4><p>本质是概率分布的离散程度</p><blockquote><p>定义式：<br>离散型：<script type="math/tex">D(X)=\sum_k p_k(X_k-\mu)^2</script><br>连续型：<script type="math/tex">D(X)=\int_{-\infty}^{\infty}(x-\mu)^2f(x)dx</script></p></blockquote><p>1.<script type="math/tex">D(x)=E(X^2)-(E(X))^2=(np)</script><br>2.<script type="math/tex">D(c)=0</script>(c是常数)<br>3.<script type="math/tex">D(aX+b)=a^2E(X)</script>(ab是常数)<br>4.当<script type="math/tex">XY</script>相互独立时,<script type="math/tex">D(\sum (X_i or -X_i))=\sum D(X_i)</script>,注意，无论和或是差的方差，均为方差的和。</p><h4 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h4><p>前提<script type="math/tex">D(x),E(x)</script>存在,呢么就有<script type="math/tex">P(X-E(X)>=\Delta)<= \frac{D(X)}{\Delta^2}</script>。</p><h4 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h4><p>衡量了随机变量XY之间的总体误差<br>由方差引申而来，若XY不独立，就会出现协方差项。</p><blockquote><p>定义式：<br>    离散型：<script type="math/tex">D(X)=\sum_k p_k(X_k-\mu)^2</script><br>    连续型：<script type="math/tex">D(X)=\int_{-\infty}^{\infty}(x-\mu)^2f(x)dx</script></p></blockquote><p>1.<script type="math/tex">Cov(x)=E(XY)-E(X)E(Y)</script><br>由此我们可以知道，方差可以看作是协方差的推广<br>2.<script type="math/tex">Cov(X,Y)=Cov(Y,X)</script><br>3.<script type="math/tex">Cov(aX,bY)=abCov(X,Y)</script>(ab是常数)<br>4.<script type="math/tex">Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)</script><br>5.当<script type="math/tex">XY</script>相互独立时,<script type="math/tex">Cov(X,Y)=0</script><br>6.<script type="math/tex">Cov(X,X)=D(X)</script><br>7.<script type="math/tex">D(X+Y)=D(X)+D(Y)+2Cov(X,Y)</script><br>引申之后可得：<script type="math/tex">D(\sum X_i)=\sum D(X_i)+2\sum \sum_{i < j}Cov(X_i,X_j)</script><br>8.<script type="math/tex">D(aX+bY)=a^2D(X)+b^2D(Y)+2abCov(X,Y)</script><br>9.<script type="math/tex">D(aX-bY)=a^2D(X)+b^2D(Y)-2abCov(X,Y)</script></p><h4 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h4><p>反映了XY这两个变量之间的关系以及相关方向<br>实际上反应的是XY的线性相关程度，也就是说即使<script type="math/tex">\rho=0</script>，也只能说明XY无线性相关关系，但是无法说明XY是否含有曲线相关关系(如<script type="math/tex">X^2+Y^2=1</script>)<br>即：若XY独立，则XY必不相关；若XY不相关，XY则不一定独立。(特例是二维正态分布，对于这个独立就是不相关)<br>定义式：<script type="math/tex">\rho_{XY}=\frac{Cov(X,Y)}{\sqrt{D(X)}{D(Y)}}=\frac{\sigma_{XY}}{\sigma_X \sigma_Y}</script><br>1.<script type="math/tex">|\rho| \leq 1</script><br>2.当XY相互独立时，<script type="math/tex">\rho_{XY}=0</script><br>3.<script type="math/tex">|\rho_{XY}|=1</script>成立的充分必要条件是存在常数<script type="math/tex">ab</script>，使得<script type="math/tex">P(Y=a+bX)=1</script></p><p class="note note-danger">注意，相关系数为零，只能说明XY不相关，无法说明XY独立！！<br>不相关和独立是两个概念。X与Y不相关是指X与Y之间不存在线性关系，不排除X与y之间存在某种曲线关系(如$X^2+Y^2=1$).若X和Y独立，则X与Y一定不相关;反之，若X与Y不相关,则X与Y未必独立.<br>既然是非线性关系，呢么对于 和差方差等于方差和 和 和差期望等于期望和差 来说不相关与独立体现是一样的，因此不相关这两个公式也能适用。<br>以及，（只）对于二维正态分布来说，不相关就是独立（必要充分条件）</p><h4 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h4><p>随机变量关于常数a的k阶矩：<script type="math/tex">E[(X-a)^k]</script>,其中k为正整数。<br>当a=O时的k阶矩称为k阶原点矩，记为<script type="math/tex">v_k= E(X^k)</script><br>当a=E(X)时的k阶矩称为k阶中心矩,记为<script type="math/tex">\mu_k=E[(X-E(X))^k]</script><br>数学期望是随机变量的一阶原点矩;方差是随机变量的二阶中心矩.</p><h5 id="定理-高阶矩存在则必定低阶矩存在"><a href="#定理-高阶矩存在则必定低阶矩存在" class="headerlink" title="定理(高阶矩存在则必定低阶矩存在)"></a>定理(高阶矩存在则必定低阶矩存在)</h5><p>设随机变量X的s阶矩存在，若0 &lt; k &lt; s，则<script type="math/tex">E(X^K)</script>也存在</p><h5 id="定理（中心矩与原点矩的关系"><a href="#定理（中心矩与原点矩的关系" class="headerlink" title="定理（中心矩与原点矩的关系)"></a>定理（中心矩与原点矩的关系)</h5><p>（这是防止公式渲染错误的头文字前缀请忽略）<script type="math/tex">\mu_k=\sum_{j=0}^k C_k^j v_j(-V_1)^{k-j}</script>,<br>（这是防止公式渲染错误的头文字前缀请忽略）<script type="math/tex">v_k=\sum_{j=0}^k C_k^j \mu_j V_1^{k-j}</script>,</p><h3 id="第五章-大数定律和中心极限定律"><a href="#第五章-大数定律和中心极限定律" class="headerlink" title="第五章 大数定律和中心极限定律"></a>第五章 大数定律和中心极限定律</h3><h4 id="切比雪夫不等式-1"><a href="#切比雪夫不等式-1" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h4><p>如果一个随机变量的方差非常小的话，那么这个随机变量取到远离均值$\mu$的概率也是非常小的，这个说实话也非常直观，同样有一个专门的不等式来描述他，就是切比雪夫不等式</p><script type="math/tex; mode=display">P(|X-\mu| \geq \varepsilon) \leq \frac{\sigma^2}{\varepsilon^2}</script><h4 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h4><blockquote><p>指某个随机事件在单次试验中可能发生也可能不发生，但在大量重复实验中往往呈现出明显的规律性，即该随机事件发生的频率会向某个常数收敛，该常数值即该事件发生的概率。<br>就是能用频率近似代替概率；能用样本均值近似代替总体均值得意思。</p></blockquote><p class="note note-danger">大数定律发挥作用，是靠大数对小数的稀释作用。而不是依靠后面的失衡的出现去平衡前期的失衡！！！</p><h5 id="切比雪夫大数定律"><a href="#切比雪夫大数定律" class="headerlink" title="切比雪夫大数定律"></a>切比雪夫大数定律</h5><p>假设<script type="math/tex">\xi_n</script>为一个随机变量序列，<script type="math/tex">E(X)=\mu,D(X)=\sigma^2</script>.如果<script type="math/tex">D(S_n) < o(n^2)</script>,呢么当<script type="math/tex">n \rightarrow \infty,P(\omega:|\frac{1}{n}\sum_{k=1}^n X_i - \frac{1}{n}\sum_{k=1}^n \mu_k|>\varepsilon) \rightarrow 0</script><br>适用条件：<script type="math/tex">D(S_n) < o(n^2)</script></p><h4 id="Levi-Lindeberg定理-中心极限定理"><a href="#Levi-Lindeberg定理-中心极限定理" class="headerlink" title="Levi-Lindeberg定理(中心极限定理)"></a>Levi-Lindeberg定理(中心极限定理)</h4><p>不论<script type="math/tex">X_i</script>属于什么分布类型，<script type="math/tex">\mu=EX_i,\sigma=DX_i \to \sum_{i=1}^n X_i \overset{n\to \infty}{\sim} N(n\mu,n\sigma^2)</script>.<br>呢么，<script type="math/tex">\frac{\sum_{i=1}^n X_i -n\mu}{\sqrt{n}\sigma} \overset{n\to \infty}{\sim} N(0,1)</script>,即<script type="math/tex">lim_{n \to \infty }P \left\{ \frac{\sum_{i=1}^n X_i -n\mu}{\sqrt{n}\sigma} \leq x \right\} =\Phi(x)</script></p><p class="note note-danger">本质上是在说一个随机数期望的分布是按照正态分布的，且与期望值和方差有关</p><h3 id="数理统计"><a href="#数理统计" class="headerlink" title="数理统计"></a>数理统计</h3><h4 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h4><ol><li>联合分布函数：设总体X的分布函数为F(x)，则样本<script type="math/tex">(X_1,X_2,...,X_n)</script>的分布函数为<script type="math/tex">F(X_1,X_2,...,X_n)=\prod_{i=1}^n F(x_i)</script></li><li>联合分布律：设总体X的概率分布律为P(X=x)=p(x)，则样本<script type="math/tex">(X_1,X_2,...,X_n)</script>的分布函数为<script type="math/tex">P(X_1,X_2,...,X_n)=\prod_{i=1}^n p(x_i)</script></li><li>联合分布密度：设总体X的概率密度为f(x)，则样本<script type="math/tex">(X_1,X_2,...,X_n)</script>的分布函数为<script type="math/tex">f(X_1,X_2,...,X_n)=\prod_{i=1}^n f(x_i)</script></li><li>样本均值：<script type="math/tex">\overline{X}=\frac{1}{n}\sum_{i=1}^{n}X_i</script></li><li>样本方差：<script type="math/tex">S_n^2=\frac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^2</script><br>样本标准差：<script type="math/tex">S_n</script></li><li>修正样本方差：<script type="math/tex">S^2=\frac{1}{n-1}\sum_{i=1}^{n}(X_i-\overline{X})^2</script></li><li>样本矩：<br>k阶矩：<script type="math/tex">A_k=\frac{1}{n}\sum_{i=1}^n X_i^k</script><br>k阶中心矩：<script type="math/tex">B_k=\frac{1}{n}\sum_{i=1}^n (X_i-\overline{X})^k</script></li><li>样本k阶原点矩：<script type="math/tex">A_k=\frac{1}{n}\sum_{i=1}^{n}X_i^k</script></li><li>样本k阶中心矩：<script type="math/tex">B_k=\frac{1}{n}\sum_{i=1}^{n}(X_i-\overline{X})^k</script></li></ol><h4 id="抽样分布"><a href="#抽样分布" class="headerlink" title="抽样分布"></a>抽样分布</h4><h5 id="mathcal-X-2分布"><a href="#mathcal-X-2分布" class="headerlink" title="\mathcal{X}^2分布"></a><script type="math/tex">\mathcal{X}^2分布</script></h5><h5 id="t分布"><a href="#t分布" class="headerlink" title="t分布"></a>t分布</h5><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>大学课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>大学基础课程</tag>
      
      <tag>概率论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICPC 2021 银川站游记</title>
    <link href="/2021/05/17/icpc%E9%93%B6%E5%B7%9D2021/"/>
    <url>/2021/05/17/icpc%E9%93%B6%E5%B7%9D2021/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>在机场等飞机，没什么可做的，想起总结还没写，就开始写博客。记录一下这次的icpc银川</code></pre><h2 id="15号"><a href="#15号" class="headerlink" title="15号"></a>15号</h2><p>15号很早就起了床，定了4点40的闹钟。因为教练说过去年有队伍银川站出锅没赶上飞机，于是要求先去东站然后坐城际高铁去机场。我和qy提前先走了，大概一个半小时就到了车站，然后就开始补觉。上车时还出现了小插曲，qy的身份证找不到了没赶上车，不过还好办了张临时身份证并且赶着下一班高铁过来了。没有耽误太多。晕机感并不是呢么强烈，但是也是很恶心的感觉，从河东机场到学校的大巴上也晕乎乎的。<br>我们到学校的时候，热身赛已经开始了，我们赶紧找到了自己的机位开始配置环境看题，热身赛的题目都是很水的，不过评测机一直在卡. . .听说是主办方为了测试评测机压力给D题搞了巨大多组数据，然后评测机就真挂了. . . 我们的鼠标滚轮一直在卡，不过志愿者帮忙给换了一个。<br>去找了以前的同学和学长，见到了lowG11,Mybing,cdcq,Cydiater。cdc还告诉了我们评测机的栈未限制并教了解决方法(我们在隔壁电脑上实验然后成功搞死机了QwQ)。Mybing一点没变，站在门口等人时就直接去找门卫以及志愿者哪儿有好吃的。最后听了司机的建议，我们去了老毛手抓。体验感. . .真的不是很好，羊肉128一斤，几十块的烧卖每人尝了一个就没人吃，Mybing吃了一口臊子面就再不吃了，century点的炒米到最后都没上。大家草草聊了下就散了。<br>回到旅店后学长找我们一起打德州，便去了他们房间，最后又和队友整理了下模板，然后就去睡觉了。</p><h2 id="16号"><a href="#16号" class="headerlink" title="16号"></a>16号</h2><p>早上定了三个闹钟，6点40醒了之后关掉继续睡，直到7点10分才醒，草草洗完头后下楼去吃早餐，早餐很丰盛，吃完之后马上就上了接去学校的的车。到校都8点40了，我们买了几瓶饮料就去座位上待机。比赛开始，题面发下来后队友太急一下子撕开了，结果把密码条撕下来一小块，导致我们有一小段时间在随机试密码。（其实有在问志愿者能不能帮我们查一下，但是志愿者说这是我们自己的原因）。还好最后找到了最后呢一小片，好家伙直接少了三个字母怪不得怎么试也试不出来。<br>登陆上以后，队友分别从前往后以及从后往前看题面，我从中间随机看，刚好看到了E题，题目太长第一眼只能看到呢个大大的烯烃，以及下方的R1R2R3R4四种基团，看了一眼就大胆猜测这是一个判断基团题，再翻一页看到了样例输出就更加确定了想法，于是开始进攻题意. ..但是英语太差，读题太慢，便求救英语好的队友，说这是sb阅读模拟题看一下。刚好他们读出了A，给我说了题意然后我就上去敲A他们继续读E。A虽然是签到但由于我太菜还是调了一会儿，这段时间他们把E读出来后又读了其他题，发现J也是签到。A过之后队友上来打E，然后我再看J，发现队友读的J有点问题。等到队友过了E后我开始上机打J，交了一发Wa了，队友说可能是要乱序，但我再读了一遍题还是没有看出来是要乱序，就在这时候，旁边的队的小姐姐说：“就是空格的问题！”。忽然发现我也没有处理空格，改了再交一发过了，感谢鸽屋咕的小姐姐，让我们没有卡在这种wa上太久。<br>此时的榜大多是这三道签到，队友说他看K可做，我问他们K的题意，虽然他们给我讲了一遍但是我还是没听懂. . .我看一小部分人过了B于是我便看B，让他们一起去研究K了，他们好像有不同的想法，一个队友先上机敲了半小时发现过不了样例发现想法错了，我再次询问K的题意. . .但是还没听太懂。我在B上的进展也很慢，由于给的数值范围1e5导致我一直在想是不是可以放到权值线段树上或者用什么其他的数据结构乱搞一下？但是一一被自己否定。另一个队友敲了他的K也不太行，我又问了一遍题意，总算懂了。感觉这就是显然的trie树，只不过需要记录下每次可以减少的权值，和队友说了自己的想法上去写了. . .但是由于用的板子不是自己的，比较生疏进展缓慢。队友说他有个基于trie的想法就让给他了。打好之后测试了几个样例手推了几组，一起改了会儿过了。<br>此时大概还剩两个半小时，我们看过了好多的B，开始全队攻B，队友说他想试下暴力，便让他上去写了。实在想不出B怎么搞但是确实过的人不少，忽然看到大屏幕的榜学长他们呢队过了G并且B没过，便觉得G可能可做转去了G。此时队友B暴力交了一发WA了，发现是自己思想的问题，也转向G。队友提出了nqlogn的做法，我听不大懂便交给了他，不过感觉时间复杂度可能刚好会被卡。果然，调好交上去T了。队友觉得这种思路可能布对，但是已经就剩20min了，我们连番上阵对这个代码进行常数优化，各种奇技淫巧接连使用，希望能把log给优化掉。结果到最后也没优化过…</p><h2 id="结束了"><a href="#结束了" class="headerlink" title="结束了"></a>结束了</h2><p>回到酒店放完东西后我们出来绕着星海湖走了走(其实是我想带大家去爬小山坡但是呢个公园关门了. . .)。还因为离市区太远了打不到车。打电话找刘神从宾馆打车来救我们，最后去了周记福乐吃羊肉，有一说一比昨天吃的好太多了，茶也很好喝，走的时候我还买了四包(一堆人大概买了有近20包吧)，真的老好喝了。回去后和学长一起德扑和狼人杀。玩到很晚才睡。第二天起的很早，吃完早餐回房间收拾东西，在学长的房间里和qy玩了一会儿元气骑士。大巴来了，我们走了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后卡着铜银线，银尾收场，G题问了下学长是只要倒着推就可以减少log的复杂度. . .果然还是自己的问题，交的罚时有两发也有我的问题，这些都是非智力因素的（一个空格，一个数组少加了0）。实际感觉可以做的更好，排名应该可以更考前，而不是处于这种“银川银尾”的状态。<br>比赛前队友说过银川站牌子多，以银为目标冲一波，结果虽然卡到了银，但是感觉自己可以做的更好，本来是可以让这个“银川银”变成“icpc银”的。比如J大多人都是一发过，这是代码习惯的问题。以及思路还需要开拓，听century说B题CF上有道类似正解dp思想的题，过的人大多是做了呢道吧。确实是很妙的dp，出题人把时间空间都卡的死死的，完全卡过了logn做法。<br>当然，优点也还是有的，比如这次队友英语比较好，没有怎么受题意限制，以及队伍配合确实不错，和队友的思路契合的不错，一起改代码讨论思路绝对比一个人自己思考强(LH他们的队伍好像因为配合的问题出了锅)。ACM始终是一个团队竞技的过程，像我这种单挑能力弱的，一定要和队友配合好才能把能力发挥到最大。以及要练习好英语，做好英文的学习。</p><p>以及，回来的时候真的要晕死在路上. . .以后再也不带这么多东西了</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>比赛</category>
      
      <category>icpc银川</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>icpc</tag>
      
      <tag>游记</tag>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路分析基础学习笔记 二</title>
    <link href="/2021/05/05/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%802/"/>
    <url>/2021/05/05/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><pre><code>这里是一部分动态电路的内容各种分析方法还和静态电路是一样的，只是电流和电压都是动态变化的。本质上还是kvl，kcl，var的应用。</code></pre><p>静态电路的分析<a href="https://linzeyin.github.io/2021/03/23/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%801/">记在了这里</a>,内容有点太多了，所以新开这一页记录动态电路的分析。</p><hr><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="1-电容元件"><a href="#1-电容元件" class="headerlink" title="1.电容元件:"></a><strong>1.电容元件:</strong></h3><p>两块金属板用绝缘介质隔开就构成了一个实际电容器。<br>能够在q－u平面内用一条曲线（称为库伏特性曲线）来描述的二端元件称为电容元件，即电荷q和电压u存在着代数关系。若该曲线是过原点的直线，则称为线性电容元件，否则就称为非线性电容元件。</p><h4 id="电容电压的连续性质和记忆性质"><a href="#电容电压的连续性质和记忆性质" class="headerlink" title="电容电压的连续性质和记忆性质"></a>电容电压的连续性质和记忆性质</h4><p>电容的动态特性：电压有变化时，才有电流。</p><script type="math/tex; mode=display">i_c(t)=C\frac{du_c(t)}{dt}</script><p>任何时刻，通过电容元件的电流与该时刻的电压变化率成正比。如果电容两端加直流电压，则<script type="math/tex">i_c=0</script>，电容元件相当于开路。故电容元件具有隔直流、通交流作用.<br>在实际电路中，通过电容的电流ic总是为有限值，这意味着<script type="math/tex">\frac{du}{dt}</script>必须为有限值，也就是说，电容两端电压<script type="math/tex">u_c</script>必定是时间t的连续函数，而不能跃变。</p><p class="note note-info"><b><font size="2" >注意：电容电流有可能发生跃变。若电容电压在t时刻发生了跃变，则t时刻电容电流为无穷大</font></b></p><p>电容电压对电流有记忆作用。在任一时刻t，电容电压uc是此时刻以前的电流作用的结果，它“记载”了已往的全部历史，所以称电容为记忆元件。相应地，电阻为无记忆元件。<br>电容的电压关系式：<script type="math/tex">u_c(t)=\frac{1}{C} \int_{-\infty}^t i_c(\xi)d\xi</script><br>电容吸收能量：<script type="math/tex">W_C(t)=\frac{1}{2}cu_c^2(t)</script><br>电容是贮能元件，它不消耗能量，也不产生能量，只是吸收和放出能量，实行能量的转换，是无源元件。</p><h4 id="多电容串并联关系"><a href="#多电容串并联关系" class="headerlink" title="多电容串并联关系"></a>多电容串并联关系</h4><p>多电容串联:<script type="math/tex">\frac{1}{C}=\sum \frac{1}{C_i}</script><br>多电容并联:<script type="math/tex">C=\sum C_i</script></p><hr><h3 id="2-电感元件"><a href="#2-电感元件" class="headerlink" title="2.电感元件:"></a><strong>2.电感元件:</strong></h3><p>电感器：将导线绕成线圈的形式，也称为电感线圈。线圈中不含铁磁物质时，称为线性电感线圈<br>在ψ-i平面中能用一条曲线（称韦安特性曲线）来描述的二端元件称为电感元件。当曲线为过原点的直线时,称为线性电感元件。<br>定义式：ψ(t)＝LI(t)</p><h4 id="电感电流的连续性质和记忆性质"><a href="#电感电流的连续性质和记忆性质" class="headerlink" title="电感电流的连续性质和记忆性质"></a>电感电流的连续性质和记忆性质</h4><p>电感的动态特性：电流有变化时，才有电压。具有通直流、阻交流作用，在直流稳态电路中，电感可视作短路。<br>电感电流的连续性（又称电感的惯性）：若电容电压有界，则电感电流不跃变。</p><p class="note note-info"><b><font size="2" >注意：电感电压有可能发生跃变。若电感电流在t0时刻发生了跃变，则t0时刻电感电压为无穷大</font></b></p><p>电感电流具有记忆性和连续性:<script type="math/tex">i(t)=i(t_0)+\frac{1}{L}\int_{t_0}^t u(\xi)d\xi</script><br>在<script type="math/tex">t_1-t_2</script>时间内，电感贮存的能量为：<script type="math/tex">W_L(t_1,t_2)=\frac{1}{2}Li_l^2(t_2)-\frac{1}{2}Li_l^2(t_1)=W_L(t_2)-W_L(t_1)</script><br>电感在任一时间t时的贮能为：<script type="math/tex">W_L(t)=\frac{1}{2}Li_l^2(t)</script></p><h4 id="多电感串并联关系"><a href="#多电感串并联关系" class="headerlink" title="多电感串并联关系"></a>多电感串并联关系</h4><p>多电感串联:<script type="math/tex">L=\sum L_i</script><br>多电感并联:<script type="math/tex">\frac{1}{L}=\sum \frac{1}{L_i}</script></p><hr><h3 id="3-一阶电路"><a href="#3-一阶电路" class="headerlink" title="3.一阶电路"></a><strong>3.一阶电路</strong></h3><p>动态元件的电流与电压的约束关系是导数与积分关系，因此根据KCL、KVL和元件的VAR所建立的电路方程是以电流、电压为变量的微分方程或微分—积分方程。如果电路中的无源元件都是线性时不变的，那么动态电路方程是线性常系数微分方程。<strong><em>如果电路中只有一个动态元件，则所得的是一阶微分方程，相应的电路称为一阶电路 。</em></strong></p><h4 id="一阶非齐次方程的求解"><a href="#一阶非齐次方程的求解" class="headerlink" title="一阶非齐次方程的求解"></a>一阶非齐次方程的求解</h4><p>这一部分牵扯到高数知识，推导所需latex公式较为繁琐，故在此直接给出结论。<br><img src="/img/postpictures/sadgfdhbgfnhgfvc.png" alt="大概就是这样"></p><h4 id="零状态响应"><a href="#零状态响应" class="headerlink" title="零状态响应"></a>零状态响应</h4><p>若电路原始状态为零，则电路中响应称为零状态响应，零状态响应仅由电源产生。<br>可以推出零状态相应动态原件的电流时间的关系函数，推导公式省略，这里直接给出结论。<br>一阶RC电路的零状态响应：<script type="math/tex">U_c=U_s(1-e^{-\frac{t}{RC}});i=C\frac{du_c}{dt}=\frac{U_s}{R}e^{-\frac{t}{RC}}</script><br>一阶RL电路的零状态响应：<script type="math/tex">U_L=L\frac{di_L}{dt}=U_se^{-\frac{R}{L} t};i=\frac{U_s}{R}(1-e^{-\frac{R}{L} t})=i_l(\infty)(1-e^{-\frac{R}{L} t})</script></p><h4 id="零输入响应"><a href="#零输入响应" class="headerlink" title="零输入响应"></a>零输入响应</h4><p>无源（独立源）一阶电路，产生响应的原因是电路的初始贮能，这种响应称为一阶电路的零输入响应。<br>初始值可以通过分析换路前电路（稳态）求出<script type="math/tex">U_C(0_-),I_L(0_-)</script>,根据换路定理这两个量不变得到<script type="math/tex">U_C(0_+),I_L(0_+)</script>，然后求的所需要的<script type="math/tex">(0_+)</script>值。</p><h5 id="RC电路的零输入响应"><a href="#RC电路的零输入响应" class="headerlink" title="RC电路的零输入响应"></a>RC电路的零输入响应</h5><p>响应的原因是<script type="math/tex">U_C(0_-)</script>，其中R为电容C两端的等效电阻：<script type="math/tex">U_C(t)=U_C(0^+)e^{-\frac{t}{RC}}</script><br>时间常数RC决定了响应衰减的快慢，RC越大响应衰减的越慢，反之衰减的越快。<br>由于电容相当于是电压源，因此在其他原件均为线性原件的基础上，RC电路任意支路的零输入响应的形式为<script type="math/tex">f(t)=f(0^+)e^{-\frac{t}{RC}}</script><br>整个过程电阻消耗的电能等于电容的原始储能<script type="math/tex">W_R=\frac{1}{2}CU_0^2</script>。</p><h5 id="RL电路的零输入响应"><a href="#RL电路的零输入响应" class="headerlink" title="RL电路的零输入响应"></a>RL电路的零输入响应</h5><p>响应的原因是<script type="math/tex">I_L(0_-)</script>，其中R为电感C两端的等效电阻：<script type="math/tex">I_L(t)=I_L(0^+)e^{-\frac{tR}{L}},U_L(t)=L\frac{di_L}{dt}=-RI_0e^{-\frac{tR}{L}}</script><br>时间常数<script type="math/tex">\frac{L}{R}</script>决定了过渡时间的快慢，<script type="math/tex">\frac{L}{R}</script>越大过渡时间越长，反之衰减的越快。<br>整个过程电阻消耗的电能等于电感的原始储能<script type="math/tex">W_R=\frac{1}{2}Li_0^2</script>。</p><h4 id="暂态和稳态"><a href="#暂态和稳态" class="headerlink" title="暂态和稳态"></a>暂态和稳态</h4><p>微分方程通解中的齐次方程解又称为 <strong>固有响应（natural response）</strong> 分量，它的模式与输入无关，也就是说，不论是什么样的输人，这一分量一般具有<script type="math/tex">Ke^{st}</script>的形式，只是K的具体数值一般与输入有关。这一分量的变化方式（如按指数规律变化，变化的快慢等）完全由电路本身所确定，具体说，是由特征根S所确定的，输入仅仅影响这一分量的大小。在有损耗的电路中，这一分量是随着时间的增长而衰减到零的，在这种情况下，这一分量又可称为 <strong>暂态响应（transient respose）</strong> 分量。 微分方程通解中的特解又称为 <strong>强制响应（forceced response）</strong> 分量，其形式一般与输入形式相同。如强制响应为常量或周期函数，则这一分量又可称为 <strong>稳态响应（steady state respone）</strong><br>三要素公式中的无穷时间量就是稳态响应量，含有时间的量就是暂态响应量。</p><hr><h3 id="4-二阶电路"><a href="#4-二阶电路" class="headerlink" title="4.二阶电路"></a><strong>4.二阶电路</strong></h3><p>当电路中包含有两个独立的动态元件时，描述电路的方程是二阶线性常系数微分方程。这就是二阶电路，在这种电路中，给定的初始条件有两个，</p><h4 id="RLC串联二阶电路的零输入响应"><a href="#RLC串联二阶电路的零输入响应" class="headerlink" title="RLC串联二阶电路的零输入响应"></a>RLC串联二阶电路的零输入响应</h4><p>它们由储能元件的初始值决定，初始状态情况有三种：<script type="math/tex">\begin{cases}  1.U_C(0)=U_0,I_L(0)=0 \\ 2.U_C(0)=0,I_L(0)=I_0 \\ 3.U_C(0)=0,I_L(0)=0   \end{cases}</script><br>经过数学分析（比较繁琐这里暂不给出），由电路自身性质可以将电压情况分为四种：过阻尼，临界阻尼，欠阻尼和零阻尼。<br><img src="/img/postpictures/asfgabcxzrttrjtyses.png" alt="四种图像"><br><strong>过阻尼：</strong> <script type="math/tex">R>2\sqrt{\frac{L}{C}}</script> 特征根为两个不相等的负实根<br><img src="/img/postpictures/asdfsdgfdhbcxvbtr.png" alt="过阻尼"><br><strong>临界阻尼：</strong> <script type="math/tex">R=2\sqrt{\frac{L}{C}}</script> 特征根为两个相等的负实根,<script type="math/tex">u_c,i_L</script> 波形图与过阻尼情况类似。<br><strong>欠阻尼：</strong> <script type="math/tex">R<2\sqrt{\frac{L}{C}}</script> 特征根为一对共轭复根,<script type="math/tex">u_c,i_L</script> 均是幅值按指数规律衰减的正弦函数，实际上是两个储能原件的能量相互转化。<br><strong>零阻尼：</strong> <script type="math/tex">R=0</script> 特征根为两个不相等的负实根，相当于电路没有电阻消耗电能，能量转化能一直继续下去。</p><p><img src="/img/postpictures/safdsgvrhtytefgzsd.png" alt="听老师说考试时候会给出，需要会用"></p><h4 id="RLC串联二阶电路的全响应"><a href="#RLC串联二阶电路的全响应" class="headerlink" title="RLC串联二阶电路的全响应"></a>RLC串联二阶电路的全响应</h4><p>电路响应由电源和电路的原始储能共同产生。<br>电路的全响应由对应齐次微分方程的通解与微分方程的特解之和组成<script type="math/tex">U_C(t)=U_{Ch}(t)+U_{Cp}(t)</script>,电路的固有频率为<script type="math/tex">S_{1,2}=-\frac{R}{2L}±\sqrt{(\frac{R}{2L})^2 - \frac{1}{LC}}</script>。<br><strong>当电路的固有频率s1!=s2时，对应齐次微分方程的通解为<script type="math/tex">U_ch(t)=K_1e^{s_1t}+K_2e^{s_2t}</script>。微分方程特解为<script type="math/tex">u_{cp}(t)=U_S</script>,<script type="math/tex">U_C(t)=U_{Ch}(t)+U_{Cp}(t)=K_1e^{s_1t}+K_2e^{s_2t}+U_S</script>。</strong><br>已知初始条件<script type="math/tex">U_C(0),\frac{dU_c(t)}{dt}|_{t=0}=\frac{i_C(0)}{C}</script>，可以得到<script type="math/tex">\begin{cases}  U_C(0)=K_1+K_2+U_S \\  \frac{dU_c(t)}{dt}|_{t=0}=K_1 S_1+K_2 S_2=\frac{i_C(0)}{C}  \end{cases}</script>，求解这两个方程得到常数<script type="math/tex">K_{1,2}</script>后即可得到<script type="math/tex">U_C(t)</script> </p><h4 id="GLC并联电路的分析"><a href="#GLC并联电路的分析" class="headerlink" title="GLC并联电路的分析"></a>GLC并联电路的分析</h4><p>是RLC串联电路的对偶电路,特征根为<script type="math/tex">S_{1,2}=-\frac{G}{2C}±\sqrt{(\frac{G}{2C})^2 - \frac{1}{LC}}</script><br>实际上是<br><strong>过阻尼：</strong> <script type="math/tex">G>2\sqrt{\frac{C}{L}}</script><br><strong>临界阻尼：</strong> <script type="math/tex">G=2\sqrt{\frac{C}{L}}</script><br><strong>欠阻尼：</strong> <script type="math/tex">G<2\sqrt{\frac{C}{L}}</script><br><strong>零阻尼：</strong> <script type="math/tex">G=0</script><br>对偶电路，实际上和RLC的是差不多的。</p><h3 id="5-正弦电流电路"><a href="#5-正弦电流电路" class="headerlink" title="5.正弦电流电路"></a><strong>5.正弦电流电路</strong></h3><p>激励和响应均为同频率的正弦量的线性电路（正弦稳态电路）称为正弦电路或交流电路。正弦信号是一种基本信号，任何非正弦周期信号可以分解为按正弦规律变化的分量。<br>正弦量计算实际上是对动态元件计算的一个简化（我理解上的），因为由于正弦函数求导求积分的性质，可以杜绝解繁琐的微分方程，可以将电路中的电流电压等要素统一使用正弦量来表示。</p><h4 id="正弦量的三要素"><a href="#正弦量的三要素" class="headerlink" title="正弦量的三要素"></a>正弦量的三要素</h4><p>正弦量表达式为：<script type="math/tex">i(t)=I_m cos(\omega t+\phi)</script> (不对，这明明是余弦为啥老师ppt上说是正弦？)</p><blockquote><p>(1) 幅值 (振幅、最大值)<script type="math/tex">I_m</script>:反映正弦量变化幅度的大小。<br>(2) 角频率<script type="math/tex">\omega</script>:相位变化的速度，反映正弦量变化快慢。<script type="math/tex">\omega=2\pi f=\frac{2\pi}{T}</script><br>(3) 初相位<script type="math/tex">\phi</script>:反映正弦量的计时起点，常用角度表示</p></blockquote><h4 id="相量法表示"><a href="#相量法表示" class="headerlink" title="相量法表示"></a>相量法表示</h4><p>正弦稳态电路中，各个电压、电流相应与激励均为同频率的正弦波，因此正弦波的三特征可以降为两特征,即<strong>振幅和相位</strong>。<br>以电压举例子：即<script type="math/tex">U(t)=U_m cos(\omega t+\phi)</script>可以表示为<script type="math/tex">U(t)=Re[U_m e^{j(\omega t+\theta)}]=Re[U_m e^{j\omega t}e^{j\theta}]</script>,由于<script type="math/tex">e^{j\theta}</script>为一常数,因此可与Um合并,合并后的常量用<script type="math/tex">\dot{U_m}</script>来表示,<script type="math/tex">U(t)=Re[\dot{U_m}e^{j\omega t}]=Re[\dot{U_m}\angle (\omega t)]</script><br>.<script type="math/tex">\dot{U_m}</script>被称为振幅相量。<br>我们相当于是虚构了一个函数<script type="math/tex">F(t)</script>，使得<script type="math/tex">F(t)=I_me^{j\phi}e^{j\omega t}=\dot{I_m}e^{j\omega t}</script><br>注意，用相量表示正弦量时，只有相量实部有具体物理含义，相量整体实际上是无物理含义的。(实际上可以将相量整体理解成一个数据和时间的混合量，虚部用来表示该数据的延后/提前程度)<br>并且取整Re[f(x)]不受微分积分的限制，可以跨过微分积分符号直接微分积分里面的函数。</p><p class="note note-info"><b><font size="2" >相量法表示的优点：<br>把时域问题变为复数问题；<br>把微积分方程的运算变为复数方程运算；<br>可以把直流电路的分析方法直接用于交流电路。</font></b></p><h4 id="电路元件的相量模型"><a href="#电路元件的相量模型" class="headerlink" title="电路元件的相量模型"></a>电路元件的相量模型</h4><p><strong>电阻</strong>:<br>时域方程:<script type="math/tex">u(t)=Ri(t)</script><br>相量形式方程:<script type="math/tex">\dot{U}=R\dot{I}</script><br>电阻并没有改变电流和电压的相位。只存在幅值的线性关系。<br>在相量域内ui重合。<br><strong>电感</strong>:<br>时域方程:<script type="math/tex">u(t)=L\frac{di}{dt}</script><br>相量形式方程:<script type="math/tex">\dot{U}=j\omega L\dot{I}</script><br>电感改变了电流和电压的相位,<script type="math/tex">u</script>超前<script type="math/tex">i (\frac{\pi}{2})</script>弧度. <script type="math/tex">u</script>与<script type="math/tex">i</script>幅值之比等于<script type="math/tex">\omega L</script>。只存在幅值的线性关系。<script type="math/tex">\omega L</script>反映电感对正弦电流的阻碍作用，这一阻碍作用随着电源频率的升高而增大。<br>在相量域u在i前90°<br><strong>电容</strong>:<br>时域方程:<script type="math/tex">i(t)=C\frac{du}{dt}</script><br>相量形式方程:<script type="math/tex">\dot{I}=j\omega C\dot{U}</script><br>电容改变了电流和电压的相位,<script type="math/tex">u</script>滞后<script type="math/tex">i (\frac{\pi}{2})</script>弧度. <script type="math/tex">u</script>与<script type="math/tex">i</script>幅值之比等于<script type="math/tex">\frac{\omega}{C}</script>。只存在幅值的线性关系。<script type="math/tex">\frac{\omega}{C}</script>反映电容对正弦电流的阻碍作用，这一阻碍作用随着电源频率的升高而减小。<br>在相量域u在i后90°</p><h4 id="不含独立源的单口网络端口的相量形式"><a href="#不含独立源的单口网络端口的相量形式" class="headerlink" title="不含独立源的单口网络端口的相量形式"></a>不含独立源的单口网络端口的相量形式</h4><p>网络<script type="math/tex">N_0</script>是正弦稳态电路中不含独立源的线性单口网络，<br>其电压为：<script type="math/tex">u=\sqrt{2}*Ucos(\omega t+\theta_u)</script><br>其电流为：<script type="math/tex">i=\sqrt{2}*Icos(\omega t+\theta_i)</script><br>用VAR写，就是：<script type="math/tex">\dot{U}=Z \dot{I}</script><br>写成实数方程为：<script type="math/tex">U=|Z|I,\theta_u=\theta_i+\theta_z</script><br>还可以写成导纳形式：<script type="math/tex">\dot{I}=Y \dot{U}</script><br>写成实数方程为：<script type="math/tex">I=|Y|U,\theta_i=\theta_Y+\theta_u</script><br>正弦稳态电路中网络端口特性由ZY来反应。    </p><h3 id="6-阻抗导纳"><a href="#6-阻抗导纳" class="headerlink" title="6.阻抗导纳"></a>6.阻抗导纳</h3><p>阻抗可以类比电阻，导纳可以类比电导</p><h4 id="阻抗"><a href="#阻抗" class="headerlink" title="阻抗"></a>阻抗</h4><p>设网络<script type="math/tex">N_0</script>是正弦稳态电路中不含独立源的线性单口网络.<br>定义<script type="math/tex">z=\frac{\dot{U}}{\dot{I}}</script>。称 Z 为网络 <script type="math/tex">N_0</script> 的输入阻抗（又称等效阻抗或简称为阻抗）<br>模<script type="math/tex">|Z|=\frac{U}{I}</script>,说明电压与电流间的大小关系.<br>幅角 <script type="math/tex">\phi_z=\theta_u-\theta_i</script>,表示电压电流的相位差.<br><strong>实部R－为等效电阻，代表电路的等效热损耗；</strong><br><strong>虚部X－等效电抗，表等效电、磁场能量存储。</strong><br><img src="/img/postpictures/asfssdvxctejhe.png" alt="三者关系可以用阻抗三角形来表示"><br><strong>阻抗 Z 既表达了电压与电流二者之间的有效值关系，也指出了二者之间的相位关系，因而全面地反映了电路的正弦稳态性能</strong><br>阻抗相位大于0，U超前于I，电路为感性<br>阻抗相位小于0，U滞后于I，电路为容性<br>阻抗相位等于0，U与I同相，电路为阻性</p><h4 id="RLC原件的阻抗"><a href="#RLC原件的阻抗" class="headerlink" title="RLC原件的阻抗"></a>RLC原件的阻抗</h4><p>电阻的感抗就是电阻<script type="math/tex">Z_R=R</script><br>电感的电抗（感抗）<script type="math/tex">Z_L=j\omega L=jX_L</script>,<script type="math/tex">X_L</script>也称为感抗。<script type="math/tex">X_L=\omega L,X_L>0</script><br>电容的电抗（容抗）<script type="math/tex">Z_C=-j\frac{1}{\omega C}=jX_C</script>,<script type="math/tex">X_C</script>也称为容抗。<script type="math/tex">X_C=-\frac{1}{\omega C},X_C<0</script></p><h4 id="导纳"><a href="#导纳" class="headerlink" title="导纳"></a>导纳</h4><p>网络<script type="math/tex">N_0</script>是正弦稳态电路中不含独立源的线性单口网络，其电压和电流分别为：<br>定义<script type="math/tex">Y=\frac{\dot{I}}{\dot{U}}</script>。称 Y 为网络 <script type="math/tex">N_0</script> 的输入阻抗（又称等效阻抗或简称为阻抗）<br>模<script type="math/tex">|Y|=\frac{I}{U}=\frac{1}{|Z|}</script>,说明电压与电流间的大小关系.单位为西门子。<br>导纳相位大于0，U滞后于I，电路为容性<br>导纳相位小于0，U超前于I，电路为感性<br>导纳相位等于0，U与I同相，电路为阻性</p><h4 id="RLC原件的导纳"><a href="#RLC原件的导纳" class="headerlink" title="RLC原件的导纳"></a>RLC原件的导纳</h4><p>电导的导纳就是电导<script type="math/tex">Y_R=G</script><br>电感的电纳（感纳）<script type="math/tex">Y_L=-j\frac{1}{\omega L}=jB_L</script>,<script type="math/tex">B_L</script>也称为感纳。<script type="math/tex">B_L=-\frac{1}{\omega L}</script><br>电容的电纳（容纳）<script type="math/tex">Y_C=j\omega C=jB_C</script>,<script type="math/tex">B_C</script>也称为容纳。<script type="math/tex">B_C=\omega C</script></p><h3 id="7-动态电路中的功率和能量"><a href="#7-动态电路中的功率和能量" class="headerlink" title="7.动态电路中的功率和能量"></a>7.动态电路中的功率和能量</h3><h4 id="元件的功率和能量关系"><a href="#元件的功率和能量关系" class="headerlink" title="元件的功率和能量关系"></a>元件的功率和能量关系</h4><p>电流电压基本关系式：<script type="math/tex">U_R=Ri_R,U_L(t)=L\frac{di_L}{dt},I_C(t)=C\frac{du_C}{dt};</script><br>功率能量关系式：<script type="math/tex">p(t)=u(t)i(t)=\frac{dW(t)}{dt};w(t)=\int^t_{-\infty} p(t)dt=\int^t_{-\infty} uidt=</script> <script type="math/tex">\begin{cases}  \frac{1}{2}Li^2(t) \\\\ \frac{1}{2}Cu^2(t) \end{cases}</script><br><strong>电阻原件</strong><br>电阻电源电压关系：<script type="math/tex">u(t)=U_m cos(\omega t+\phi_u);i(t)=I_m cos(\omega t+\phi_i)</script><br>瞬时功率为：<script type="math/tex">p(t)=ui=UI[1+cos2 (\omega t+\phi_u)]</script>，恒大于0，故电阻只吸收能量。<br>平均功率为：<script type="math/tex">P=\frac{1}{2}U_mI_m=I^2R</script>,这里的UI为有效值，平均功率也称为有功功率，简称为功率。</p><p class="note note-success"><b><font size="2" >对有功功率与无功功率的一些想法<br>在交流电路中，由电源供给负载的电功率有两种；一种是有功功率，一种是无功功率。有功功率是保持用电设备正常运行所需的电功率，也就是将电能转换为其他形式能量的功率。这一部分能量是做我们所需要的功的<br>无功功率比较抽象，它不做功是用于电路内电场与磁场的交换，并用来在电气设备中建立和维持磁场的电功率，电场能和磁场能大多数情况我们无法直接使用，因此只存在电磁的相互转换，没有（对我们需要的地方）做功。<br>无功功率决不是无用功率！！他的作用很大。通常从发电机和高压输电线供给的无功功率，远远满足不了负荷的需要，所以在电网中要设置一些无功补偿装置来补充无功功率，以保证用户对无功功率的需要，这样用电设备才能在额定电压下工作。<br>也可以这么理解，由于动态原件的作用导致电流和电压之间拥有了相位差，导致功率因数无法到达1，我们可以通过改变其相位来使其功率因数接近1，改变相位的方式就是通过无功功率(增加动态原件减小相位差)<br></font></b></p><p><strong>电感原件</strong><br>电感电源电压关系：<script type="math/tex">u_L(t)=U_{Lm} cos \omega t;i_L(t)=I_{Lm} cos(\omega t -90°)=I_{Lm}sin \omega t</script><br>瞬时功率为：<script type="math/tex">p(t)=U_{Lm}I_{Lm}cos \omega t sin \omega t=U_LI_Lsin2 \omega t</script>。<br>在一个周期内的平均功率为0,平均储能为：<script type="math/tex">W_L=\frac{1}{4}LI^2_{Lm}=\frac{1}{2}LI_L^2</script>。<br><strong>电容原件</strong><br>电容电源电压关系：<script type="math/tex">u_C(t)=U_{Cm} cos \omega t;i_C(t)=I_{Cm} cos(\omega t +90°)=-I_{Cm}sin \omega t</script><br>瞬时功率为：<script type="math/tex">p(t)=-U_{Cm}I_{Cm}cos \omega t sin \omega t=-U_CI_Csin2 \omega t</script>。<br>在一个周期内的平均功率为0,平均储能为：<script type="math/tex">W_L=\frac{1}{4}CU^2_{Cm}=\frac{1}{2}CU_C^2</script>。</p><p><strong>无功功率</strong> <script type="math/tex">Q_L=U_LI_L,Q_C=-U_CI_C;</script></p><p><strong>可以看出：只有电阻的平均功率大于零，而电感和电容的平均功率等于零。以后提到的平均功率简称为功率，是指电路中电阻消耗的功率，或指电源提供的功率，也称为有功功率。常说的功率都是指平均功率。</strong><br><strong>电容和电感不消耗也不再生能量，它只是从电源处吸收能量，贮存起来，在下一个时间再向外放出能量，它与电源进行能量的交换，无功功率则反映了这种交换的最大值及交换规模。</strong></p><p class="note note-primary"><b><font size="2" >关于单口网络计算功率的一些Tips:<br>1.在求单口网络的功率能量时可以把单口网络当作一个原件，求单口网络的阻抗，网络消耗的功率等于端钮上电流有效值平方乘阻抗的实部。<br>2.单口网络中只有电阻消耗功率，所有电阻消耗功率的总和即为单口网络的功率。<br>3.单口网络平均功率守恒。单口网络从外电路吸收的总平均功率等于该网络内部各元件吸收的平均功率之和。<br>4.由R、L、C 组成的单口网络，网络吸收的总平均功率等于网络内各电阻元件平均功率之和<br></font></b></p><h4 id="视在功率和功率因数"><a href="#视在功率和功率因数" class="headerlink" title="视在功率和功率因数"></a>视在功率和功率因数</h4><p><strong>视在功率（表观功率）</strong>：指端口电压、电流有效值的乘积，反映了电气设备的容量或提供功率的最大值，电源设备的容量一般用视在功率表示。<br>定义： S＝UI 单位为 伏安（VA）<br><strong>功率因数</strong>；由于电流电压相位差的存在，导致实际中的<script type="math/tex">P=UIcos\phi=UI\lambda</script>达到不了S。我们设<script type="math/tex">\lambda=cos\phi=\frac{P}{S}</script>,称其为网络N的功率因数。</p><p>若 <script type="math/tex">\lambda>0</script>，则网络 N 吸收电能。<br>若 <script type="math/tex">\lambda<0</script>，则网络 N 产生电能，N 中必含有源元件。<br>若网络 N 中无独立源，则$\phi$为该网络的阻抗角。<br>若网络N中仅含 R、L、C ，则必有$\lambda$&gt; 0，即</p><hr><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><h3 id="换路定理"><a href="#换路定理" class="headerlink" title="换路定理"></a>换路定理</h3><p class="note note-info"><b><font size="2" >换路瞬间，若电容电流保持为有限值，则电容电压（电荷）换路前后保持不变。<br>换路瞬间，若电感电压保持为有限值，则电感电流（磁链）换路前后保持不变。</font></b></p><p class="note note-success"><b><font size="3" >电容电流和电感电压为有限值是换路定律成立的条件<br>换路定律反映了能量不能跃变。</font></b></p><hr><h2 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h2><h3 id="一阶电路的分解方法"><a href="#一阶电路的分解方法" class="headerlink" title="一阶电路的分解方法"></a>一阶电路的分解方法</h3><p class="note note-info"><b><font size="3" >将一阶电路分为电阻网络 N1 和动态元件两部分。<br>将 N1 用戴维南定理化简，得简单一阶电路.<br>求解简单一阶电路，得 $u_c(t)$ 或 $i_L(t)$ 。<br>回到原电路，将电容用一电压源(其值为 $u_c$ )置换，或将电感用一电流源(其值为 $i_L$ )置换，求出电路其余变量</font></b></p><h3 id="零输入相应初始状态条件的确定"><a href="#零输入相应初始状态条件的确定" class="headerlink" title="零输入相应初始状态条件的确定"></a>零输入相应初始状态条件的确定</h3><p class="note note-info"><b><font size="3" >根据换路前的电路求出原始状态 $u_c(t_{0-})$ 和 $i_L(t_{0-})$。<br>依据换路定则确定初始状态 $u_c(t_{0＋})$ 和 $i_L(t_{0＋})$<br>作出 $t_{0＋}$ 时刻的等效电路，使用如下替换方法<br>每一电感用一电流源替换，其值为 $i_L(t_{0＋})$；<br>每一电容用一电压源替换，其值为 $u_c(t_{0＋})$；<br>对 $t_{0＋}$ 等效电路求解，求出所需初始电流和电压。</font></b></p><h3 id="三要素法分析一阶电路"><a href="#三要素法分析一阶电路" class="headerlink" title="三要素法分析一阶电路"></a>三要素法分析一阶电路</h3><p>三要素分别是<strong>初始值<script type="math/tex">f(0+)</script>，稳态值<script type="math/tex">f(\infty)</script>，时间常数<script type="math/tex">RC,L/R</script></strong>（原本应该是“tao”这个字符的，但是好像不是希腊字母不知道latex中怎么打.. .就用TAO代替 ）<br>三要素公式：<script type="math/tex">f(t)=[f(0+)-f(\infty)]e^{\frac{t}{TAO}}+f(\infty)</script><br>使用前提为一阶电路，适用于所有支路电压和电流。<br>就是用叠加定理+动态原件的分析得出的。</p><hr><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>大学课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>大学基础课程</tag>
      
      <tag>电路分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等数学</title>
    <link href="/2021/05/03/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    <url>/2021/05/03/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><pre><code>直面自己的失败，请。</code></pre><hr><h3 id="第一章-空间解析几何"><a href="#第一章-空间解析几何" class="headerlink" title="第一章 空间解析几何"></a>第一章 空间解析几何</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol><li>向量的方向角与方向余弦：非零向量a与三条坐标轴的夹角称为向量a的方向角，<script type="math/tex">a(a_x,a_y,a_z)</script>可以用它与三个坐标轴的夹角<script type="math/tex">\alpha , \beta, \gamma</script>来表示它的方向，称<script type="math/tex">\alpha , \beta, \gamma</script>为向量a的方向角，其余弦<script type="math/tex">cos\alpha , cos\beta, cos\gamma</script>称为a的方向余弦。</li><li>向量的向量积： 设a和b是两个向量，则定义他们的向量积为<script type="math/tex">c=a\times b</script>，数值上等于<script type="math/tex">|c|=|a||b|sin\theta</script>，方向垂直于a和b所确定的平面，指向按右手法则从a转向b来确定。</li><li>平面束：空间中通过同一条直线的所有平面的集合成为有轴平面束，这条直线成为平面束的轴。</li></ol><p class="note note-info">平面束表示本质上是表示直线的两平面的线性组合，这种表示方法给我们了一个可以通过直线表示通过该直线的平面的方式。</p><ol><li>曲面的一般方程为一个三元方程<script type="math/tex">F(x,y,z)=0</script>，曲线的一般方程为两个曲面的交线，即<script type="math/tex">\begin{cases}  F(x,y,z)=0 \\ G(x,y,z)=0 \end{cases}</script><br> 这里应该开始介绍一些曲面，等待更新。</li></ol><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ol><li>平面的方程：<br> 点法式：<script type="math/tex">A(x-x_0)+B(y-y_0)+C(z-z_0)=0</script><br> 三点式：<script type="math/tex">\left| \begin{array}{cccc} x-x_1 & y-y_1 & z-z_1 \\\\ x_2-x_1 & y_2-y_1 & z_2-z_1 \\\\ x_3-x_1 & y_3-y_1 & z_3-z_1 \end{array} \right|=0</script><br> 一般式：<script type="math/tex">Ax+By+Cz+D=0</script></li><li>两平面夹角余弦：<script type="math/tex">cos\theta=\frac{|A_1A_2+B_1B_2+C_1C_2|}{\sqrt{A_1^2+B_1^2+C_1^2}\sqrt{A_2^2+B_2^2+C_2^2}}</script></li><li>点<script type="math/tex">P_0</script>到平面的距离：<script type="math/tex">d=\frac{|Ax_0+By_0+Cz_0+D|}{\sqrt{A^2+B^2+C^2}}</script></li><li>直线的方程<br> 一般方程: <script type="math/tex">\begin{cases}  A_1x+B_1y+C_1z+D_1=0 \\\\ A_2x+B_2y+C_2z+D_2=0 \end{cases}</script><br> 对称式/点向式方程：<script type="math/tex">\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}=t</script><br> 参数方程：<script type="math/tex">\begin{cases}  x=x_0+mt \\ y=y_0+nt \\ z=z_0+pt \end{cases}</script><br> 两点式方程：<script type="math/tex">\frac{x-x_1}{x_2-x_1}=\frac{y-y_1}{y_2-y_1}=\frac{z-z_1}{z_2-z_1}</script></li><li><p>点<script type="math/tex">P_0</script>到直线的距离：<script type="math/tex">d=\frac{|s \times \overset{ \to }{ P_0 P } | }{|s|}</script></p><p class="note note-danger">注意，分子上为叉积</p></li><li><p>平面束方程：<script type="math/tex">(A_1x+B_1y+C_1z+D_1)+\lambda(A_2x+B_2y+C_2z+D_2)=0</script></p></li></ol><h3 id="第二章-多元函数微分学"><a href="#第二章-多元函数微分学" class="headerlink" title="第二章 多元函数微分学"></a>第二章 多元函数微分学</h3><h4 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h4><ol><li>多元函数的极限：当点<script type="math/tex">P\to P_0</script>时，函数<script type="math/tex">f(P)</script>以A为极限的充要条件是点P以任何途径趋近于点<script type="math/tex">P_0</script>时，函数<script type="math/tex">f(P)</script>都无限趋近于<script type="math/tex">A</script>。需要指出的是，<script type="math/tex">lim_{\overset{x\to x_0}{y\to y_0}}f(x,y)</script>为二重极限，<script type="math/tex">lim_{x\to x_0}lim_{y\to y_0}f(x,y)</script>为二次极限。二重极限是xy同时不分先后趋近，而二次极限本质上还是一次函数的极限。</li><li><p>偏导数：设函数<script type="math/tex">z=f(x,y)</script>在点<script type="math/tex">(x_0,y_0)</script>的某领域内有定义。如果<script type="math/tex">\frac{df(x,y_0)}{dx}|_{x=x_0}=lim_{h\to 0}\frac{f(x_0+h,y_0)-f(x_0,y_0)}{h}</script>存在，则称此极限为函数<script type="math/tex">z=f(x,y)</script>在点<script type="math/tex">(x_0,y_0)</script>处对x的偏导数。对y也同理。</p><p class="note note-info">多元函数的偏导存在只能保证点(x,y)沿平行于坐标轴的直线$x=x_0,y=y_0$趋于点$(x_0,y_0)$时极限存在，因为偏导的本质只是在平行于x轴y轴方向上进行了求导</p></li><li><p>高阶偏导数：对于多元函数来说，若其一阶偏导数仍是关于每个自变量的函数，并且一阶偏导数对每个自变量的偏导数也存在，则说这个多元函数具有二阶偏导数。混合偏导数相等，和求导次序无关。<br><img src="/img/postpictures/jklgjlkgjh297.jpg" alt=""></p></li><li><p>方向导数：如果函数<script type="math/tex">f(x,y)</script>在点<script type="math/tex">P(x_0,y_0)</script>处可微分，呢么函数在该点沿任意方向l的方向导数存在且有：<script type="math/tex">\frac{\partial f}{\partial l}|_{(x_0,y_0)}=f_x(x_0,y_0)cos\alpha+f_u(x_0,y_0)cos\beta</script>,其中<script type="math/tex">cos\alpha.cos\beta</script>是方向l1的方向余弦。</p></li><li><p>梯度：函数在某一点沿哪一方向增加的最快。由方向导数的定义易得，当向量与梯度方向一致时方向导数最大，即<script type="math/tex">\theta</script>方向导数和函数偏导组成的向量的夹角为0时最大。梯度的概念在任意维度的函数都存在，比如在一维函数中就是导数。</p></li><li><p>多元函数的极值：函数在此点的各个偏导均为0(必要条件)；设函数<script type="math/tex">z=f(x,y)</script>在点<script type="math/tex">(x_0,y_0)</script>的某邻域内连续且有一阶及二阶连续偏导数，又<script type="math/tex">f_x(x_0,y_0)=0,f_y(x_0,y_0)=0</script>,令<script type="math/tex">f_xx(x_0,y_0)=A,f_xy(x_0,y_0)=B,f_yy(x_0,y_0)=C</script>,则设<script type="math/tex">\Delta=AC-B^2</script>,则当<script type="math/tex">\Delta > 0</script>时具有极值，且A<0时有最大值，A>0是有最小值。当<script type="math/tex">\Delta < 0</script>时无极值。<script type="math/tex">\Delta = 0</script>时无法通过这种方法确定<br>最值的话就是将函数的所有驻点的函数值进行比较，从而找到最值。</p></li><li><p>条件极值 拉格朗日乘数法：要找函数<script type="math/tex">z=f(x,y)</script>在附加条件<script type="math/tex">\phi(x,y)=0</script>下的可能极值点，可以先作出拉格朗日函数<script type="math/tex">L(x,y)=f(x,y)+\lambda \phi(x,y)</script>，其中<script type="math/tex">\lambda</script>为参数，求其对x与y的一阶偏导数，并使其为零，然后与方程<script type="math/tex">\phi(x,y)=0</script>联立起来：<script type="math/tex">\begin{cases}  f_x(x,y)+\lambda \phi_x(x,y)=0 \\ f_y(x,y)+\lambda \phi_y(x,y)=0 \\ \phi(x,y)=0 \end{cases}</script><br>由这个方程解出<script type="math/tex">x,y,\lambda</script>，这样得到的<script type="math/tex">(x,y)</script>就是函数<script type="math/tex">f(x,y)</script>在附加条件<script type="math/tex">\phi(x,y)=0</script>下的可能极值点，这个方法可以推广至自变量多于两个而条件多余1个的情况。</p></li></ol><h4 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h4><ol><li>全微分在近似计算中的应用：<script type="math/tex">f(x+\Delta x,y+\Delta y)=f(x,y)+f_x(x,y)\Delta x + f_y(x,y)\Delta y</script></li><li>多元函数求导的链式法则：<script type="math/tex">\frac{dw}{dt}=\sum_{i-1}^n \frac{\partial w}{\partial x_i} \frac{dx_i}{dt}</script></li><li>隐函数微分法：对于在某点领域拥有连续偏导数的函数<script type="math/tex">F(x,y)=0</script>来说，其隐函数导数为：<script type="math/tex">\frac{dy}{dx}=-\frac{F_x}{F_y}</script></li><li>空间曲线的参数方程：<script type="math/tex">\begin{cases}  x=\phi(t) \\ y=\omega(t) , t \in [\alpha,\beta]\\ z=\theta(t) \end{cases}</script>,该曲线在点<script type="math/tex">M(x_0,y_0,z_0)</script>处的切线方程为：<script type="math/tex">\frac{x-x_0}{\phi'(t_0)}=\frac{y-y_0}{\omega'(t_0)}=\frac{z-z_0}{\theta'(t_0)}</script>,法平面方程为：<script type="math/tex">(x-x_0)\phi'(t_0)+(y-y_0)\omega'(t_0)+(z-z_0)\theta'(t_0)=0</script></li><li>曲面在点<script type="math/tex">M(x_0,y_0,z_0)</script>处的的切平面方程为：<script type="math/tex">F_x(x_0,y_0,z_0)(x-x_0)+F_y(x_0,y_0,z_0)(y-y_0)+F_z(x_0,y_0,z_0)(z-z_0)=0</script>,在点<script type="math/tex">M(x_0,y_0,z_0)</script>处的法线方程为：<script type="math/tex">\frac{(x-x_0)}{F_x(x_0,y_0,z_0)}=\frac{(y-y_0)}{F_y(x_0,y_0,z_0)}=\frac{(z-z_0)}{F_z(x_0,y_0,z_0)}</script></li></ol><h3 id="第三章-重积分"><a href="#第三章-重积分" class="headerlink" title="第三章 重积分"></a>第三章 重积分</h3><pre><code>一些基础的东西(比如一些一重积分可以类推的中值定理估值定理)就不在此赘述了，大一下主要学习的是二重积分的转化</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>二重积分不是二次积分，二重积分一般不能直接求的结果，大多都需转化为一重积分进行求解。</li><li>坐标系之间的转化：<br>直角坐标系转极坐标系 <script type="math/tex">\begin{cases}  x= r cos \theta \\ y=r sin \theta \end{cases}</script> ,此时<script type="math/tex">\iint_{\Omega} f(x,y)dxdy=\iint_{\Omega} f(r cos \theta ,r sin \theta)rdrd \theta</script><br>直角坐标系转柱坐标系 <script type="math/tex">\begin{cases}  x= r cos \theta \\ y=r sin \theta \\ z=z \end{cases}</script> ,此时<script type="math/tex">\iiint_{\Omega} f(x,y,z)dv=\iiint_{\Omega} f(r cos \theta ,r sin \theta,z)rdrd \theta dz</script><br>直角坐标系转球坐标系 <script type="math/tex">\begin{cases}  x=\rho sin \phi cos \theta \\ y=\rho sin \phi sin \theta \\ z=\rho cos \theta \end{cases}</script> ,此时<script type="math/tex">\iiint_{\Omega} f(x,y,z)dv=\iiint_{\Omega} f( \rho sin \phi cos \theta ,\rho sin \phi sin \theta, \rho cos \theta) \rho^2 sin\phi d\rho d\theta d\phi</script></li></ol><h4 id="公式-2"><a href="#公式-2" class="headerlink" title="公式"></a>公式</h4><ol><li>求曲面面积：<script type="math/tex">A=\iint_D \sqrt{1+(\frac{\partial z}{\partial x})^2+(\frac{\partial z}{\partial y})^2}dxdy</script>。这个是第一型曲面积分。</li><li>求质心：<script type="math/tex">(\overline{x},\overline{y},\overline{z})=(\frac{1}{区域面积S}\iint_D xd\sigma,\frac{1}{区域面积S}\iint_D yd\sigma,\frac{1}{区域面积S}\iint_D zd\sigma)</script>，其中<script type="math/tex">d\sigma</script>为面积微元。</li><li><p>第一类曲线积分：<script type="math/tex">\oint_L f(x,y,z) ds</script>,其中ds为弧长微元，f(x,y,z)为线密度，计算时可以将自变量用参数方程表示并带入。<script type="math/tex">\oint_L f(x,y,z) ds=\int_{\alpha}^{\beta} f(x(t),y(t),z(t))\sqrt{x^{'2}(t)+y^{'2}(t)}dt</script><br><img src="/img/postpictures/adfgfdhyfgjuykiulfh.png" alt=""></p></li><li><p>第一类曲面积分：<script type="math/tex">\iint_{\sum} f(x,y,z) ds</script>,其中ds为面积微元，f(x,y,z)为区块密度，计算时可以使<script type="math/tex">Z=g(x,y);ds=\sqrt{1+z_x^{'2}+z_y^{'2}}dxdy</script>并带入。<script type="math/tex">\iint_{\sum} f(x,y,z) ds=\iint_{D_{xy}} f(x,y,g(x,y))\sqrt{1+z_x^{'2}+z_y^{'2}}dxdy</script>,然后再使用二重积分计算的方法计算。<strong>将曲面的方程代入被积函数的目的和意义是把被积函数化为二元函数</strong></p></li><li>第二类曲线积分:<script type="math/tex">\int_L P(x,y)dx+Q(x,y)dy</script>,相当于变力<script type="math/tex">f(x,y)=(P(x,y),Q(x,y))</script>沿曲线L做的功.我们可以将所有x和y都转化成参数形式变为，即<script type="math/tex">\int_L \vec{f}(x,y)*d \vec{r}=\int_L P(x,y)dx+Q(x,y)dy=\int_{\alpha}^{\beta}[P(x(t),y(t))x'(t)+Q(x(t),y(t))y'(t)]dt</script>.三维空间曲线的情况也可以推广。<br><img src="/img/postpictures/shtjytjkiuloijhbgyw.png" alt=""></li><li><p>第二类曲面积分:第二类曲面积分有些复杂，它是针对<strong>有向曲面</strong>所作的一个积分(这里的有向是指非封闭曲面的上或下，左或右侧；或是封闭曲面的内或外侧)，有向曲面的侧是由曲面法向量的指向决定的。<br><img src="/img/postpictures/asdfsdgvfdshwretgre.png" alt="大概是这样"><br>可以将第二类曲面积分看作通过单位面积的流量计算<script type="math/tex">\iint_{\sum}P(x,y,z)dydz+Q(x,y,z)dzdx+R(x,y,z)dxdy=\iint \vec{f}{P}*\vec{n_0}dS=\iint \vec{f}{P}*d\vec{S}</script>，其中<script type="math/tex">dydz,dzdx,dxdy</script>分别表示dS在坐标面<script type="math/tex">yoz,xoz,xoy</script>的投影。</p><script type="math/tex; mode=display">\begin{split}\iint_{\sum}P(x,y,z)dydz+Q(x,y,z)dzdx+R(x,y,z)dxdy  \\=\iint_{D_{xy}}(P(x,y,z(x,y))(-z_x)+Q(x,y,z(x,y))(-z_y)+R(x,y,z(x,y)))dxdy 上下面，上正下负\\=\iint_{D_{xy}}(P(x(y,z),y,z)+Q(x(y,z),y,z)(-x_y)+R(x(y,z),y,z)(-x_z))dydz 前后面，前正后负\\=\iint_{D_{xy}}(P(x,y(x,z),z)(-y_x)+Q(x,y(x,z),z)(-x_y)+R(x,y(x,z),z)(-y_z))dzdz 左右面,右正左负\\\end{split}</script></li><li><p>格林公式：<script type="math/tex">\iint_D(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y})dxdy=\oint_L Pdx+Qdy</script><br><img src="/img/postpictures/dshgtryjtygkdgh.png" alt=""></p></li><li>高斯公式：<script type="math/tex">{\iiint}_{\omega}(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z})dxdydz=\iint_{\sum} Pdydz+Qdzdx+Rdxdy</script><br><img src="/img/postpictures/fdashgrtjuykiukliuldsfg.png" alt=""></li></ol><h3 id="第四章-级数"><a href="#第四章-级数" class="headerlink" title="第四章 级数"></a>第四章 级数</h3><p>级数，就是说无穷多个数相加在一起，也称作无穷级数。<br>记作：<script type="math/tex">\sum_{n=1}^{\infty}u_n=u_1+u_2+...+u_n+...</script>.<br>令<script type="math/tex">S(n)=\sum_{n=1}^{\infty}u_n</script>,若<script type="math/tex">lim_{n \to \infty}S(n)=A</script>极限存在，则级数收敛。反之级数发散。<br><img src="/img/postpictures/sdgfdbtyntydysrgsnf.png" alt="一些相关性质"></p><p>常用参照级数：<br>几何级数<script type="math/tex">\sum_{n=0}^{\infty} aq^n</script> <script type="math/tex">\begin{cases}  |q|<1 级数收敛 \\ |q|>1 级数发散 \end{cases}</script><br>调和级数<script type="math/tex">\sum_{n=1}^{\infty} \frac{1}{n}</script>为发散的，对于级数<script type="math/tex">\sum_{n=1}^{\infty} \frac{1}{n^p}</script> <script type="math/tex">\begin{cases}  |p|>1 级数收敛 \\ |p| <= 1 级数发散 \end{cases}</script></p><p>对于级数收敛的研究思路总共有两个。齐次由于是趋于极限，所以在讨论是否收敛时，我们只需要知道后半部分是否收敛就好，在做题时就是要明白n比式子中的任何参数都大。<br>第二点要明白的就是由于收敛的必要条件是通项的极限为零，结合极限的保号性我们可以知道存在一个N，当n&gt;N,通项小于1，在做题时直接把通项当成小于1来对待就好。<br><strong>第一个思路：部分和单调有界</strong><br>在级数中我们将极限存在叫做级数收敛，所以我们可以通过判断部分和数列是否收敛来判断级数是否收敛，而我们知道当数列单调有界时，数列必收敛，所以由此引出研究级数是否收敛的第一个思路：部分和单调有界。<br>有一种情况比较特殊的是，当我们知道部分和本来就单调时，我们只需证明有界就好，正项级数就是这种情况，而且只要证明部分和小于某个数就代表级数收敛。<br><strong>第一个思路：利用通项</strong><br>但是上一个在应用时有太多局限性，而且并不方便，由此我们想到能否直接通过通项来直接判断是否收敛。进而我们为了讨论方便就对级数进行划分类型，分为正项，交错项，任意项每一种都有各自的验敛方法，而且主义该各方法只对其对应的类型有效，所以作级数的第一步就是<strong>分类</strong><br>正项级数：比值法和根值法，在极限值小于1时收敛，大于1时发散，等于1时该方法失效，此时可以通过通项大于零或者极限不为零判断是发散的，而且考试时十有八九在等于1时都是发散的；<br>比较法及其极限形式，已知收敛的级数指向的级数都收敛，发散的背向的级数发散，极限形式本身就是一个比较法，因为高阶无穷小，到后半部分一定是小于低级无穷小，而高阶比低阶就是0，低阶比高阶就是无穷，比值为常数时，就代表两个级数敛散性相同。由后面这个敛散相同，我们可以知道只要我们能找到通项在趋于0时的等价无穷小，并且我们知道这个无穷小的敛散性，那么我们就可以将敛散性判断转化为找等价无穷小的问题了，而等价无穷小又和泰勒公式是一脉相承的，所以可以借助泰勒公式来寻找等价无穷小。这其中比较常用的已知敛散性的级数就是p级数，所以就直接把<script type="math/tex">\frac{1}{n}</script>当成x就好，同时这个还有一个好处由于有比较法的存在对于如<script type="math/tex">sinx-2x</script>我们不能直接把<script type="math/tex">sinx</script>等价为x的情况时，我们可以利用不等式<script type="math/tex">sinx < x</script>，来使<script type="math/tex">sinx-2x < x</script>，间接就达到直接带入的目的了。（注意这个方法适用的前提是该级数是正项级数。）<br>常用放缩关系：<script type="math/tex">sin x < x < tan x,\frac{1}{x+1} < ln(x+1) < x (x>0),e^x>=x+1,x-1>=ln x (x>0)</script><br>计算级数通项极限：<script type="math/tex">阶乘 \to 比值法,指数 \to 根值法,初等函数 \to 极限法,这时可利用等价无穷小</script><br><strong>交错级数</strong><br>交错级数的验敛比较容易，分三步走，判断是交错级数，计算通项极限，做差或做商判断数列是否单调不增。注意交错级数的收敛要说明是条件收敛还是绝对收敛。<br>另外交错级数由于是一正一负，所以经常会用到裂项相消法，同时利用这个方法也可以证明部分和有界，这一个要注意，但要注意这个有一个前提就是通项的极限必须是零。<br>其实对于交错级数也是可以利用泰勒公式进行判断，但是一定要展开到<script type="math/tex">x^2</script>，之后进行判断收敛的依据和上面不一样，这里是<strong>利用收敛加减收敛还是收敛，收敛加减发散是发散，发散加减发散就无法判断，因此要分开各项单独判断。</strong><br>同时在判断是交错级数之后，要做的就是提出<script type="math/tex">(-1)^n</script>,而且尽可能让式子中只有一个<script type="math/tex">(-1)^n</script>，当<script type="math/tex">(-1)^n</script>在函数内部，如<script type="math/tex">ln(1+(-1)^nx)</script>时，要用泰勒展开式将其拆开后才能拿出来。常见的还有三角函数，根号，这两种一个采用角变换，一个采用平方差<br>这里还有可以再拉上一个知识点，就是中值定理，因为是相邻两项的差，常用的思路就是把导数的最值代替建立不等式，证明绝对收敛。<br>交错级数基本上都是要用到，收敛+收敛=收敛，发散+收敛=发散（发散+发散=不定），所以应该对其进行拆分<br><strong>任意项级数</strong><br>由于级数绝对收敛原函数也收敛，所以直接转化为正项级数，如果正项级数发散，那么就只能用夹逼准则或部分和单调有界进行判断了。<br>至此我们分好了类，并说明白了各自的应用，总结来说就是正项方法多，但是交错考法灵活，涉及多个知识点，任意项就是跑龙套的。<br>插播一点计算小思路：由于收敛级数的四则运算中并没有乘法，所以考试特爱考这个，这题对于正项级数来说有一个计算思路就是先确定各部分中是否有收敛的，如果有，则判断剩余部分是否小于1，注意要有n非常大的思想。另外夹逼准则在这个知识点的应用思路：就是把所有不随n变化的项尽可能删掉。特别是常数项。还有就是对于p级数要和其交错级数形式区别开，其交错形式只要是p&gt;0就收敛了。而且这个p级数经常用来举反例，比较典型就是调和级数。p级数的记忆：p=0时为常数1，发散，所有<script type="math/tex">p<=1</script>发散</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>大学课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>大学基础课程</tag>
      
      <tag>高等数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无内鬼，来点大物知识点</title>
    <link href="/2021/04/27/%E6%97%A0%E5%86%85%E9%AC%BC%EF%BC%8C%E6%9D%A5%E7%82%B9%E5%A4%A7%E7%89%A9%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/04/27/%E6%97%A0%E5%86%85%E9%AC%BC%EF%BC%8C%E6%9D%A5%E7%82%B9%E5%A4%A7%E7%89%A9%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><blockquote><p>大物感觉也没啥十分超脱于高中物理的点，感觉就是以高中物理为主，然后用微积分知识填补一下高中物理所掌握不住的盲区。这里就记录一些需要掌握的知识点。</p></blockquote><hr><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="需要新掌握的单位量"><a href="#需要新掌握的单位量" class="headerlink" title="需要新掌握的单位量"></a>需要新掌握的单位量</h4><p>角速度 <script type="math/tex">\alpha</script> 弧度每二次方秒 <script type="math/tex">rad*s^{-2},s^{-2}</script><br>转速度 <script type="math/tex">n</script> 转每秒 <script type="math/tex">r*s^{-1}</script><br>力矩 <script type="math/tex">M</script> 牛顿米 <script type="math/tex">N*m</script><br>转动惯量 <script type="math/tex">J</script> 千克二次方米 <script type="math/tex">kg*m^2</script><br>角动量 <script type="math/tex">L</script> 千克二次方米每秒 <script type="math/tex">kg*m^2*s^{-1}</script><br>劲度系数 <script type="math/tex">k</script> 牛顿每米 <script type="math/tex">N*m^{-1}</script><br>真空电容率 <script type="math/tex">\epsilon_0</script> 法拉每米 <script type="math/tex">F*m^{-1}</script></p><p>目前学了这么多大概</p><hr><h3 id="质点运动学"><a href="#质点运动学" class="headerlink" title="质点运动学"></a>质点运动学</h3><p>高中学的那些东西…不过出题恶心程度翻了数倍<br>记录一下公式</p><blockquote><p>定义式<br>$\overline{v}=\frac{\Delta r}{\Delta t},v=\frac{dr}{dt}$<br>$\overline{a}=\frac{\Delta v}{\Delta t},a=\frac{dv}{dt}$<br>$\omega=\frac{d\theta}{dt},v=r\omega$<br>$\alpha =\frac{d\omega}{dt}=\frac{d^2\theta}{dt^2}$</p></blockquote><hr><blockquote><p>匀速率圆周运动<br>$a=a_n=r\omega^2e_n$<br>$d\theta=\omega dt$<br>$\theta=\theta_0+\omega t$</p></blockquote><hr><blockquote><p>匀变速率圆周运动<br>$a=a_1+a_n=r\alpha e_1 + r\omega^2e_n$<br>$\omega=\omega_0+\alpha t$<br>$\theta=\theta_0+\omega_0 t+\frac{1}{2}\alpha t^2$<br>$\omega^2=\omega_0^2+2\alpha(\theta-\theta_0)$</p></blockquote><h3 id="牛顿运动定理"><a href="#牛顿运动定理" class="headerlink" title="牛顿运动定理"></a>牛顿运动定理</h3><p>还是记录公式为主，因为主要是高中的玩意儿</p><blockquote><p>定义式<br>$p=mv$<br>$F=m\frac{dp}{dt}=\frac{d(mv)}{dt}=ma$<br>重力为P，重力加速度为g：$g=\frac{P}{m}=\frac{Gm_E}{r^2}$<br>功率<script type="math/tex">P=\frac{dW}{dt}=F*\frac{dr}{dt}=F*v</script></p></blockquote><h3 id="动量守恒定律和能量守恒定律"><a href="#动量守恒定律和能量守恒定律" class="headerlink" title="动量守恒定律和能量守恒定律"></a>动量守恒定律和能量守恒定律</h3><blockquote><p>定义式<br>$F=\frac{dp}{dt}$ </p></blockquote><hr><blockquote><p>动量守恒定律：$p=\sum_{i-1}^n m_iv_i=常矢量$<br>动能定理：<script type="math/tex">dW=F*dr</script><br>弹力做功：<script type="math/tex">dW=-kxdx</script><br>变力做功：<script type="math/tex">W=\oint_l F*dr</script><br>引力势能：<script type="math/tex">E_p=-G\frac{m'm}{r}</script><br>弹性势能：<script type="math/tex">E_p=\frac{kx^2}{2}</script></p></blockquote><hr><blockquote><p>确立质心:<script type="math/tex">r_c=\frac{\sum^n_{i=1}m_ir_i}{m'}</script></p></blockquote><h3 id="刚体转动和流体流动"><a href="#刚体转动和流体流动" class="headerlink" title="刚体转动和流体流动"></a>刚体转动和流体流动</h3><p>角速度的方向由右手定则确定，右手四指弯曲方向和刚体转动方向一致，此时拇指方向为角速度矢量方向。</p><blockquote><p>切向加速度：$a_1=r\alpha$<br>法向加速度：$a_n=r\omega^2$</p></blockquote><p>力矩：力的大小和力臂(转轴到力作用线的垂直距离)的乘积就是力对转轴的力矩，公式：$M=Fd=Frsin\theta$<br>力矩的方向也由右手定则确定，四肢弯曲方向是力臂通过小于180度的角θ转向力的方向，此时拇指的方向就是力矩的方向<br>转动定理：刚体绕轴转动时，刚体的角加速度与它所受的合外力矩成正比，与刚体的转动惯量成反比。<br>转动惯量：描述刚体在转动中的惯性大小的物理量，对标的是质量m，与以下三个因素有关：刚体的体密度、刚体的几何形状、转轴的位置。<br>平行轴定理：设通过刚体质心的轴线为$z_c$轴，刚体相对于这个轴线的转动惯量为$J_c$，如果有另一轴线$z$与通过质心的轴线$z_c$平行，可以证明刚体对通过$z$的转动惯量为$J_z=J_c+md^2$，式中m为刚体的质量，d为两平行轴之间的距离。可以看出，刚体对通过质心轴线的转动惯量最小。<br>角动量：设有一质量为m的质点位于空间直角坐标系中，该点相对于原点O的位矢为r，并具有速度v(即动量为$p=mv$)。我们定义，质点m对原点O的角动量为$L=r \times p = mr \times v=rmvsin\theta$(其中所有乘号全为向量乘，即叉乘)<br>质点的角动量定理：设质量为m的质点，在合力F的作用下，其运动方程为$F=\frac{d(mv)}{dt}$,由此易得：$M=\frac{dL}{dt}$，该式表明作用于质点的合力对参考点O的力矩，等于质点对该点O的角动量随时间的变化率。<br>角动量守恒：当质点所受对参考点O的和力矩为零时，质点对该参考点O的角动量为一常矢量。</p><blockquote><p>刚体定轴转动的角动量$L=J\omega$</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>大学课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>大学基础课程</tag>
      
      <tag>大学物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状压DP Codeforces 1234F</title>
    <link href="/2021/04/26/%E7%8A%B6%E5%8E%8B_%5BCodeforces1234F%5DYet%20Another%20Substring%20Reverse/"/>
    <url>/2021/04/26/%E7%8A%B6%E5%8E%8B_%5BCodeforces1234F%5DYet%20Another%20Substring%20Reverse/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>You are given a string s consisting only of first 20 lowercase Latin letters (‘a’, ‘b’, …, ‘t’).<br>Recall that the substring <script type="math/tex">s[l;r]</script> of the string s is the string slsl+1…sr. For example, the substrings of “codeforces” are “code”, “force”, “f”, “for”, but not “coder” and “top”.<br>You can perform the following operation no more than once: choose some substring <script type="math/tex">s[l;r]</script> and reverse it (i.e. the string <script type="math/tex">s_ls_{l+1}…s_r</script> becomes <script type="math/tex">s_rs_{r−1}…s_l</script>).<br>Your goal is to maximize the length of the maximum substring of s consisting of distinct (i.e. unique) characters.<br>The string consists of distinct characters if no character in this string appears more than once. For example, strings “abcde”, “arctg” and “minecraft” consist of distinct characters but strings “codeforces”, “abacaba” do not consist of distinct characters.</p></blockquote><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><ul><li>The only line of the input contains one string s consisting of no more than <script type="math/tex">10^6</script> characters ‘a’, ‘b’, …, ‘t’ (first 20 lowercase Latin letters).</li></ul><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><ul><li>Print one integer — the maximum possible length of the maximum substring of s consisting of distinct characters after reversing no more than one its substring.</li></ul><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>abcdeefc</p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>6</p></blockquote><h3 id="中文题意"><a href="#中文题意" class="headerlink" title="中文题意"></a>中文题意</h3><p>你有一个字符串，里面的字符全是0~20(a~t)以内的小写字母，你可以通过旋转一段区间的方式把它变成一个新的字符串，我们这里对旋转的定义是将一段区间的<script type="math/tex">s_ls_{l+1}…s_r</script> 变成 <script type="math/tex">s_rs_{r−1}…s_l</script>。问你只能旋转一次，使得新字符串中的不含相同字符的合法子串(这里对合法子串的定义是连续的一段区间串)最长，输出最长的长度。</p><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>yxh学长给新生拉的div3水题. . .竟然没想起来咋搞<br>由于可以通过旋转操作把一段连续的区间和另一段拼合，呢么我们可以简化一下模型，即问源字符串两段没有重合字符的合法子串的和的最长长度。<br>由于数据范围给的很小，0~20这就是写在脑门子上的状压。<br>不过当时在测试的时候想的是通过<script type="math/tex">f_{i,j}</script>来记录第i个数往后推j个数的字符占有状态。但是想不出状态转移方程，便不了了之。<br>正解是通过<script type="math/tex">f_i</script>来表示一段合法字符串字母占有状态为i时，在原串中可以找的到的字串的最长长度。<br>这种记录方法很妙，因为我们实际上再找一个状态i的子串和其他与它不冲突的子串时，一些不冲突的子串是目标不冲突子串的子集，枚举他们是没有比较意义的。因此我们直接将每一个子串都向以它为子集的字串提交贡献，假如可以提供贡献就会被以它为子集的字串记录(怎么有种树的感觉，儿子向父亲提交状态)。因此我们对状态为i的串，我们可以通过它的互补串<script type="math/tex">maxn-i</script>来快速得出它在原串中最大互补的子串。最后答案就是每种状态i和其互补态的长度和的最大值。<br>感觉这个状态转移的很妙，这是一种类似状态树的玩意，父集合可以代表所有子状态中最优的，然后通过父集合再向父父集合传递贡献从而降低了时间复杂度。<br>以及学了一些状压技巧。<br>具体见代码。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,a[<span class="hljs-number">1000100</span>],b[<span class="hljs-number">1100100</span>]=&#123;&#125;;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> c[<span class="hljs-number">30</span>],maxn,ans=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">char</span> ch1[<span class="hljs-number">1000100</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,ch1+<span class="hljs-number">1</span>);<br>    n=<span class="hljs-built_in">strlen</span>(ch1+<span class="hljs-number">1</span>);<br>    c[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;maxn=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)c[i]=c[i<span class="hljs-number">-1</span>]&lt;&lt;<span class="hljs-number">1</span>,maxn&lt;&lt;=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,nowzhuang,j;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>,nowzhuang=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">20</span>&amp;&amp;i+j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((c[ch1[i+j]-<span class="hljs-string">&#x27;a&#x27;</span>]&amp;nowzhuang))<span class="hljs-keyword">break</span>;<br>            nowzhuang|=c[ch1[i+j]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            b[nowzhuang]=j+<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//cout&lt;&lt;nowzhuang&lt;&lt;&#x27; &#x27;;</span><br>        &#125;<span class="hljs-comment">//cout&lt;&lt;endl;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;maxn;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">20</span>;j++)<br>            <span class="hljs-keyword">if</span>(i&amp;c[j])<br>                b[i]=<span class="hljs-built_in">max</span>(b[i],b[i^c[j]]);<br>    <span class="hljs-comment">//cout&lt;&lt;maxn&lt;&lt;endl;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;maxn;i++)<br>    &#123;<br>        <span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span><br>        <span class="hljs-comment">//if(b[i]+b[maxn-i-1]&gt;ans)cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;b[i]&lt;&lt;endl;</span><br>        ans=<span class="hljs-built_in">max</span>(ans,b[i]+b[maxn-i<span class="hljs-number">-1</span>]);<br>    &#125;<span class="hljs-comment">//cout&lt;&lt;endl;</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>DP</tag>
      
      <tag>状压DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间DP入门&amp;&amp;四边形不等式优化石子合并</title>
    <link href="/2021/04/25/%E5%8C%BA%E9%97%B4DP_%E5%85%A5%E9%97%A8%E9%A2%98_%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/"/>
    <url>/2021/04/25/%E5%8C%BA%E9%97%B4DP_%E5%85%A5%E9%97%A8%E9%A2%98_%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>在一个圆形操场的四周摆放 N 堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。<br>试设计出一个算法,计算出将 N 堆石子合并成 1 堆的最小得分和最大得分。</p></blockquote><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><ul><li>数据的第 1 行是正整数 N，表示有 N 堆石子。</li><li>第 2 行有 N 个整数，第 i 个整数 a_i 表示第 i 堆石子的个数。</li></ul><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><ul><li>输出共 2 行，第 1 行为最小得分，第 2 行为最大得分。</li></ul><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>4<br>4 5 9 4</p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>43<br>54</p></blockquote><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><blockquote><p><script type="math/tex">O(n^3)</script>的暴力就不说了，写这道题主要是想记录一下四边形不等式优化。</p></blockquote><h3 id="四边形不等式优化"><a href="#四边形不等式优化" class="headerlink" title="四边形不等式优化"></a>四边形不等式优化</h3><p>关于四边形不等式优化，大概是针对类似<script type="math/tex">f_{i,j}=min(f_{i,k}+f_{k+1,j}+C_{i,j})</script>或者<script type="math/tex">f_{i,j}=min(f_{i-1,k-1}+C_{k,j})</script>这种状态转移方程，其中的k可以用不等式缩小范围而不用一个一个枚举k，从而将复杂度降低.</p><p>第一个式子是石子合并的模型，第二个式子是求分段花费的模型。<br>首先是四边形不等式使用的条件，即<script type="math/tex">C_{i,j}</script>要首先满足四边形不等式条件以及单调性条件。</p><hr><h4 id="四边形不等式条件："><a href="#四边形不等式条件：" class="headerlink" title="四边形不等式条件："></a>四边形不等式条件：</h4><p>两个交错区间的<script type="math/tex">C_{i,j}</script>和，小于等于 小区间与大区间的<script type="math/tex">C_{i,j}</script>和</p><h4 id="单调性条件："><a href="#单调性条件：" class="headerlink" title="单调性条件："></a>单调性条件：</h4><p>小区间的<script type="math/tex">C_{i,j}</script>，小于等于 大区间的<script type="math/tex">C_{i,j}</script>。<br><img src="/img/postpictures/asfafdwsf.png" alt="这俩大概是这样"></p><hr><p>只要满足这两个条件，就能使用四边形不等式优化。<br>不过一般也很难证明性质，可以考场上打表，要是和四边形不等式打出来的表一样就可以大概率认为它符合四边形不等式。</p><h4 id="min和max的区别"><a href="#min和max的区别" class="headerlink" title="min和max的区别"></a>min和max的区别</h4><p>min是指类似 <script type="math/tex">f_{i,j}=min(f_{i,k}+f_{k+1,j}+C_{i,j})</script>或者<script type="math/tex">f_{i,j}=min(f_{i-1,k-1}+C_{k,j})</script>的，max就是指 <script type="math/tex">f_{i,j}=max(f_{i,k}+f_{k+1,j}+C_{i,j})</script>或者<script type="math/tex">f_{i,j}=max(f_{i-1,k-1}+C_{k,j})</script> 这种类型的状态转移方程。<br>假如把min改成max，呢么由于判断条件变了需要将使用的条件也变一下。<br>即求最大值时的条件为<script type="math/tex">C_{i,j'}+C_{i',j} \geq C_{i,j} +C_{i',j'}</script>  这玩意叫反四边形不等式<br>还有 <script type="math/tex">C_{i',j} \geq C_{i,j'}</script>  这是需要满足的新单调性：小区间的值大于等于大区间的值。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><p>用一个二维数组<script type="math/tex">s_{i,j}</script>记录一个区间最优决策点，如果<script type="math/tex">f_{i,j}</script>满足四边形不等式，呢么<script type="math/tex">s_{i,j-1} \leq s_{i,j} \leq s_{i+1,j}</script></p><p>这个是石子合并的代码。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>long long n,a[<span class="hljs-number">20010</span>],b[<span class="hljs-number">210</span>][<span class="hljs-number">210</span>],c[<span class="hljs-number">210</span>],e[<span class="hljs-number">210</span>][<span class="hljs-number">210</span>],minn=<span class="hljs-number">10000000000</span>ll,maxx=<span class="hljs-number">-1</span>,smi[<span class="hljs-number">210</span>][<span class="hljs-number">210</span>];<br>int main()<br>&#123;<br>    //freopen(<span class="hljs-string">&quot;a.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br>    //freopen(<span class="hljs-string">&quot;a.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br>    memset(b,<span class="hljs-number">10</span>,sizeof(b));<br>    cin&gt;&gt;n;<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];<br>    for(int i=n+<span class="hljs-number">1</span>;i&lt;=n*<span class="hljs-number">2</span>;i++)a[i]=a[i-n];<br>    n*=<span class="hljs-number">2</span>;<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)b[i][i]=<span class="hljs-number">0</span>,smi[i][i]=i,c[i]=c[i<span class="hljs-number">-1</span>]+a[i];<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n/<span class="hljs-number">2</span>;i++)<br>    &#123;<br>        for(int j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            e[j][i+j]=max(e[j][j+i<span class="hljs-number">-1</span>],e[j+<span class="hljs-number">1</span>][j+i])+c[i+j]-c[j<span class="hljs-number">-1</span>];<br>            <span class="hljs-comment">/*注意这句，</span><br><span class="hljs-comment">              求最大值不能用四边形不等式，</span><br><span class="hljs-comment">              因为最大值不满足单调性，</span><br><span class="hljs-comment">              但最大值有一个性质，</span><br><span class="hljs-comment">              即总是在两个端点的最大者中取到。</span><br><span class="hljs-comment">            */</span><br>            for(int z=smi[j][i+j<span class="hljs-number">-1</span>];z&lt;=smi[j+<span class="hljs-number">1</span>][i+j];z++)<br>                if(b[j][z]+b[z+<span class="hljs-number">1</span>][i+j]+c[i+j]-c[j<span class="hljs-number">-1</span>]&lt;b[j][i+j])<br>                &#123;<br>                    b[j][i+j]=b[j][z]+b[z+<span class="hljs-number">1</span>][i+j]+c[i+j]-c[j<span class="hljs-number">-1</span>];<br>                    smi[j][i+j]=z;<br>                &#125;<br>        &#125;<br>    &#125;<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)minn=min(minn,b[i][i+n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]);<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)maxx=max(maxx,e[i][i+n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]);<br>    cout&lt;&lt;minn&lt;&lt;endl&lt;&lt;maxx&lt;&lt;endl;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>DP</tag>
      
      <tag>区间DP</tag>
      
      <tag>区间问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡塔兰数</title>
    <link href="/2021/04/22/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0/"/>
    <url>/2021/04/22/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>卡塔兰数是数论中的一种特殊数列，可以看作是组合数的拓展数列<br>数列前面几项是这样：1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670,129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640…</p><p>递推的公式有：</p><script type="math/tex; mode=display">\begin{align*}& f(n)= \sum^{n-1}_{i=0} f(i)*f(n-i-1) \\\\& f(n)= \frac{f(n-1)*f(4*n-2)}{n+1} \\\\& f(n)= \frac{C^n_{2n}}{n+1} \\\\& f(n)= C^n_{2n}-C^{n-1}_{2n} \\\\\end{align*}</script><hr><p>适用卡塔兰数的一些模型：</p><p><strong>1多0序列个数：</strong> 有一个长度为$2n$的$01$序列，其中$1,0$各$n$个，要求数列的前k$(k∈[1,2n])$个数中，1的个数不少于0。合法的序列个数就是卡塔兰数的第n项。<br><strong>给定节点数目的二叉树形态：</strong> 一棵n个节点的二叉树的形态总数，就是卡特兰数的第n项<br><strong>矩阵连乘：</strong>  $ P = a_1×a_2×a_3×……×a_n $，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，其括号化的方案数目就是卡塔兰数的第n项。<br><strong>出栈次序：</strong> 一个栈(无穷大)的进栈序列为$1，2，3，…n$，其不同的出栈序列的数目就是卡塔兰数的第n项。<br><strong>凸多边形三角划分：</strong> 在一个边数为n的凸多边形中，通过若干条互不相交的对角线把这个多边形划分成了若干个三角形。不同划分的方案数就是卡塔兰数的第n项。<br>拓展一下，也可以变成在圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数。<br><strong>n对括号正确匹配数目：</strong> 给定n对括号并将括号正确配对的字符串(也就是最终字符串合法)数为卡塔兰数的第n项。<br><strong>不穿对角线路径：</strong> 在一个n×n格点网络中，一条从左下角走到右上角的不越过对角线的单调路径的数目为卡塔兰数的第n项。<br><strong>阶梯填充：</strong> 一个高度为n的阶梯状图形(网格对角线的上半部分)用长宽任意的矩形来完美填充，方案个数为卡塔兰数的第n项。</p><hr><p>递推代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt; </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>,h[<span class="hljs-number">1000010</span>],inv[<span class="hljs-number">1000010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    h[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)<br>            h[i]=(h[i]+h[j]*h[i-j<span class="hljs-number">-1</span>])%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    h[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)inv[i]=(mod-(mod/i))*inv[mod%i]%mod;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)h[i]=(h[i<span class="hljs-number">-1</span>]*(<span class="hljs-number">4</span>*i<span class="hljs-number">-2</span>)*inv[i+<span class="hljs-number">1</span>])%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-comment">//init1();</span><br>    init2();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<span class="hljs-built_in">cout</span>&lt;&lt;h[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>数论</tag>
      
      <tag>规律</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SCOI2005互不侵犯</title>
    <link href="/2021/04/13/%E7%8A%B6%E5%8E%8B_%5BSCOI2005%5D%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/"/>
    <url>/2021/04/13/%E7%8A%B6%E5%8E%8B_%5BSCOI2005%5D%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。</p></blockquote><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><ul><li>只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）</li></ul><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><ul><li>所得的方案数</li></ul><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>3 2</p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>16</p></blockquote><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>状态压缩入门题目，洛谷的题单都这样吗？<br>感觉写状压的一个好处是只要思路对了，过了样例大概率就能A了(可能是目前做的题太水了)<br>就是正常的状压思路，hang[i][j][z]表示第i行状态为j已经有了z个国王可行的方案数，然后每一步递推时把上一行可以和谐共存的状态都加上即可。<br>思路没啥好说的，代码也加上了注释应该能看懂。<br>不过中间由于没有考虑<strong>状态压缩需要枚举的状态其实是0~maxn-1</strong>的，结果稍微多调了一会儿，需要记住。以及把行间判错<strong>封装成函数</strong>确实更方便了。以后或许可以考虑自己实现一些基础结构的封装作为模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,k,d[<span class="hljs-number">20</span>],Kingnum[<span class="hljs-number">10010</span>],hang[<span class="hljs-number">15</span>][<span class="hljs-number">610</span>][<span class="hljs-number">101</span>],maxn=<span class="hljs-number">1</span>,sum=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">panduanhanghefa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> zhuangtai)</span><span class="hljs-comment">//判断这一行行内状态是否合法</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> flag=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(zhuangtai&amp;d[i])<br>            <span class="hljs-keyword">if</span>((zhuangtai&amp;d[i+<span class="hljs-number">1</span>])||(zhuangtai&amp;d[i<span class="hljs-number">-1</span>]))&#123;flag=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">panduanliehefa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> zhuangtai1,<span class="hljs-keyword">int</span> zhuangtai2)</span><span class="hljs-comment">//判断这一行和上一行是否同时合法</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> flag=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(zhuangtai1&amp;d[i])<br>            <span class="hljs-keyword">if</span>((zhuangtai2&amp;d[i])||(zhuangtai2&amp;d[i+<span class="hljs-number">1</span>])||(zhuangtai2&amp;d[i<span class="hljs-number">-1</span>]))&#123;flag=<span class="hljs-literal">false</span>;<span class="hljs-keyword">break</span>;&#125;<br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<span class="hljs-keyword">int</span> aa[<span class="hljs-number">90</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zhuangtaishuchu</span><span class="hljs-params">(<span class="hljs-keyword">int</span> zhuangtai)</span><span class="hljs-comment">//输出状态，打表用的</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;zhuangtai&lt;&lt;<span class="hljs-string">&quot;&amp;&amp;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=zhuangtai;i;i/=<span class="hljs-number">2</span>)aa[++aa[<span class="hljs-number">0</span>]]=i%<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=aa[<span class="hljs-number">0</span>];i&gt;=<span class="hljs-number">1</span>;i--)<span class="hljs-built_in">cout</span>&lt;&lt;aa[i];<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    aa[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span><br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)maxn*=<span class="hljs-number">2</span>;<span class="hljs-comment">//确定状态范围</span><br>    d[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)d[i]=d[i<span class="hljs-number">-1</span>]&lt;&lt;<span class="hljs-number">1</span>;<span class="hljs-comment">//预处理出判断每一位是否为一的辅助数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxn;i++)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j;j/=<span class="hljs-number">2</span>)Kingnum[i]+=j%<span class="hljs-number">2</span>;<span class="hljs-comment">//预处理出状态i所包含的国王数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;maxn;i++)<span class="hljs-comment">//预处理出第一行的情况</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(!panduanhanghefa(i))<span class="hljs-keyword">continue</span>;<br>        hang[<span class="hljs-number">1</span>][i][Kingnum[i]]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<span class="hljs-comment">//枚举行</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;maxn;j++)<span class="hljs-comment">//枚举当前行状态</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(!panduanhanghefa(j))<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//合理剪枝</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j1=<span class="hljs-number">0</span>;j1&lt;maxn;j1++)<span class="hljs-comment">//枚举上一行状态</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(!panduanhanghefa(j1))<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//合理剪枝</span><br>                <span class="hljs-keyword">if</span>(!panduanliehefa(j,j1))<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//合理剪枝</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> z=<span class="hljs-number">0</span>;z&lt;=k;z++)<span class="hljs-comment">//枚举含有多少个国王</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(z&lt;Kingnum[j])<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//合理剪枝</span><br>                    hang[i][j][z]+=hang[i<span class="hljs-number">-1</span>][j1][z-Kingnum[j]];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;maxn;j++)sum+=hang[n][j][k];<span class="hljs-comment">//所有第n行的状态只要满足国王数为k就加到答案上。</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>DP</tag>
      
      <tag>状压DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>luogu3092 [USACO13NOV]No Change G</title>
    <link href="/2021/04/12/%E7%8A%B6%E5%8E%8B_No%20Change/"/>
    <url>/2021/04/12/%E7%8A%B6%E5%8E%8B_No%20Change/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>约翰到商场购物，他的钱包里有K(1 &lt;= K &lt;= 16)个硬币，面值的范围是1..100,000,000。<br>约翰想按顺序买 N个物品(1 &lt;= N &lt;= 100,000)，第i个物品需要花费ci块钱，(1 &lt;= c(i) &lt;= 10,000)。<br>在依次进行的购买N个物品的过程中，约翰可以随时停下来付款，每次付款只用一个硬币，支付购买的内容是从上一次支付后开始到现在的这些所有物品（前提是该硬币足以支付这些物品的费用）。不幸的是，商场的收银机坏了，如果约翰支付的硬币面值大于所需的费用，他不会得到任何找零。<br>请计算出在购买完N个物品后，约翰最多剩下多少钱。如果无法完成购买，输出-1。</p></blockquote><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><ul><li>Line 1: Two integers, K and N.</li><li>Lines 2..1+K: Each line contains the amount of money of one of FJ’s coins.</li><li>Lines 2+K..1+N+K: These N lines contain the costs of FJ’s intended purchases. </li></ul><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><ul><li>Line 1: The maximum amount of money FJ can end up with, or -1 if FJ cannot complete all of his purchases.</li></ul><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>3 6<br>12<br>15<br>10<br>6<br>3<br>3<br>2<br>3<br>7 </p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>12</p></blockquote><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>状态压缩入门题目<br>观察数据范围可知，我们可以枚举硬币的使用状态来获得不同种方式购买可以剩余的最大钱数。<br>根据题意可知，每一步操作相关的除了硬币的使用外还有购买区间的价值总和。<br>因此我们定义e[i]表示状态为i的硬币使用状态可以得到的最多商品数，状态转移方程为$e[i]=max(e[j]+num_{i,j})\quad(j=i\oplus 2^{k},k=(1,n))$<br>其中${num_i,j}$表示从状态j加上第k个硬币转移到的状态i可以增加的商品数目。<br>我们可以用二分来快速在当前区间(e[j],n)内找到加入该硬币后可以获得的商品个数。由于商品购买区间是连续的，所以我们可以先预处理出前缀和，然后二分时用前缀和处理出区间商品个数来查找。<br>最后找出可以包含第n个商品的状态，若是没有一个e达到n呢就输出-1，选取出来包含n的计算剩下的硬币钱数，最后取最大值输出即可</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;bits/stdc++.h&gt;</span><br>using namespace std;<br><span class="hljs-keyword">int</span> k,n,c[<span class="hljs-number">100010</span>],e[<span class="hljs-number">100010</span>],coin[<span class="hljs-number">70000</span>],d[<span class="hljs-number">20</span>];<br>long long maxn=<span class="hljs-number">1</span>,<span class="hljs-string">q[100010]</span>,maxx=-<span class="hljs-number">1</span>,sum,coinnum=<span class="hljs-number">0</span>;<br>inline <span class="hljs-keyword">int</span> er(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>,ll=l;<br>    <span class="hljs-keyword">while</span>(l+<span class="hljs-number">1</span>&lt;r)<br>    &#123;<br>        mid=(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">q[mid]</span>-<span class="hljs-string">q[ll]</span>&gt;coin[i])r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (((<span class="hljs-string">q[r]</span>-<span class="hljs-string">q[ll]</span>)&lt;=coin[i])?r:l);<br>&#125;<br><span class="hljs-keyword">int</span> main()<br>&#123;<br>    //freopen(<span class="hljs-string">&quot;a.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br>    //freopen(<span class="hljs-string">&quot;a.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br>    scanf(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;k,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;coin[i]),coinnum+=coin[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;c[i]);<span class="hljs-string">q[i]</span>=<span class="hljs-string">q[i-1]</span>+c[i];&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=k;i++)maxn*=<span class="hljs-number">2</span>;<br>    d[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=k;i++)d[i]=d[i-<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxn;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)<br>            <span class="hljs-keyword">if</span>(i&amp;d[j])  <br>                e[i]=max(e[i],er(e[i^d[j]],n,j));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxn;i++)<br>    &#123;<br>        sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(e[i]==n)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)<br>                <span class="hljs-keyword">if</span>(i&amp;d[j])sum+=coin[j];<br>            maxx=max(maxx,coinnum-sum);<br>        &#125;<br>    &#125;cout&lt;&lt;maxx&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>DP</tag>
      
      <tag>状压DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP刷题柱</title>
    <link href="/2021/04/11/DP%20%E5%88%B7%E9%A2%98%E6%9F%B1/"/>
    <url>/2021/04/11/DP%20%E5%88%B7%E9%A2%98%E6%9F%B1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>之前其实是没怎么系统学过的，单纯就是见到了某些题目，发现自己会就写，不会就看题解。由于dp主要还是思路，所以题解看懂了就会觉得自己会了，但实际上经过这一段时间的练习发现我的思维上还有很多需要补全的点，所以开贴记录并练习。</p></blockquote><hr><h3 id="背包DP"><a href="#背包DP" class="headerlink" title="背包DP"></a>背包DP</h3><hr><h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><h4 id="Luogu1880-石子合并-四边形不等式优化"><a href="#Luogu1880-石子合并-四边形不等式优化" class="headerlink" title="Luogu1880 石子合并 四边形不等式优化"></a>Luogu1880 石子合并 四边形不等式优化</h4><p><a href="https://linzeyin.github.io/2021/04/25/%E5%8C%BA%E9%97%B4DP_%E5%85%A5%E9%97%A8%E9%A2%98_%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/">链接</a></p><hr><h3 id="优化DP"><a href="#优化DP" class="headerlink" title="优化DP"></a>优化DP</h3><hr><h3 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h3><hr><h3 id="插头DP"><a href="#插头DP" class="headerlink" title="插头DP"></a>插头DP</h3><hr><h3 id="树型DP"><a href="#树型DP" class="headerlink" title="树型DP"></a>树型DP</h3><h4 id="CJOJ-2171-最大利润"><a href="#CJOJ-2171-最大利润" class="headerlink" title="CJOJ 2171 最大利润"></a>CJOJ 2171 最大利润</h4><p><a href="https://linzeyin.github.io/2017/07/26/%E6%A0%91%E5%BD%92_%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/">链接</a></p><hr><h3 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h3><h4 id="luogu3092-USACO13NOV-No-Change-G"><a href="#luogu3092-USACO13NOV-No-Change-G" class="headerlink" title="luogu3092 [USACO13NOV]No Change G"></a>luogu3092 [USACO13NOV]No Change G</h4><p><a href="https://linzeyin.github.io/2021/04/12/%E7%8A%B6%E5%8E%8B_No%20Change/">链接</a></p><h4 id="luogu1896-SCOI2005-互不侵犯"><a href="#luogu1896-SCOI2005-互不侵犯" class="headerlink" title="luogu1896 [SCOI2005]互不侵犯"></a>luogu1896 [SCOI2005]互不侵犯</h4><p><a href="https://linzeyin.github.io/2021/04/13/%E7%8A%B6%E5%8E%8B_%5BSCOI2005%5D%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AF/">链接</a></p><h4 id="Codeforces-1234F"><a href="#Codeforces-1234F" class="headerlink" title="Codeforces 1234F"></a>Codeforces 1234F</h4><p><a href="https://linzeyin.github.io/2021/04/26/%E7%8A%B6%E5%8E%8B_%5BCodeforces1234F%5DYet%20Another%20Substring%20Reverse/">链接</a></p><hr><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算几何学习(待完善)</title>
    <link href="/2021/04/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/04/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今日补完了昆明站赛站，自告奋勇接下了两题结果卡在了计算几何上，以为自己有着模板就直接上了，结果一直卡在段错误，因此决定这周进行计算几何专题的专门练习。<br>其实这些内容在寒假也学了一些，当时主要是入了计算机图形学的坑，玩OpenGL的时候顺便补了点计几。当时也找到了很多的blog进行学习，并且学习了大佬的代码风格(因为感觉这样写好棒).这里的内容主要还是把平常的几何知识封装以下，所以除了一些思维上的新东西应该都只有板子。</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="建点"><a href="#建点" class="headerlink" title="建点"></a>建点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LD double</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Vector Point</span><br><span class="hljs-keyword">const</span> LD eps=<span class="hljs-number">1e-8</span>;<span class="hljs-comment">//精度差</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dcmp</span><span class="hljs-params">(LD a)</span></span>&#123;<span class="hljs-keyword">return</span> a&lt;-eps?<span class="hljs-number">-1</span>:(a&gt;eps?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);&#125;<span class="hljs-comment">//处理精度</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> LD <span class="hljs-title">ABS</span><span class="hljs-params">(LD a)</span></span>&#123;<span class="hljs-keyword">return</span> a*dcmp(a);&#125;<span class="hljs-comment">//取绝对值</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>&#123;</span><span class="hljs-comment">//名字是点，但实际上向量也是一样的用法</span><br>    LD x,y;Point(LD X=<span class="hljs-number">0</span>,LD Y=<span class="hljs-number">0</span>)&#123;x=X,y=Y;&#125;<span class="hljs-comment">//为点赋初值</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>,&amp;x,&amp;y);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf %.2lf\n&quot;</span>,x,y);&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><h4 id="模长"><a href="#模长" class="headerlink" title="模长"></a>模长</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline LD <span class="hljs-constructor">Len(Vector <span class="hljs-params">a</span>)</span>&#123;return sqrt(<span class="hljs-constructor">Dot(<span class="hljs-params">a</span>,<span class="hljs-params">a</span>)</span>);&#125;<br></code></pre></td></tr></table></figure><h4 id="点积-amp-amp-叉积"><a href="#点积-amp-amp-叉积" class="headerlink" title="点积&amp;&amp;叉积"></a>点积&amp;&amp;叉积</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">inline LD Dot(Vector <span class="hljs-selector-tag">a</span>,Vector <span class="hljs-selector-tag">b</span>)&#123;return <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.x</span>*<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.x</span>+<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.y</span>*<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.y</span>;&#125;//点积<br>inline LD Cro(Vector <span class="hljs-selector-tag">a</span>,Vector <span class="hljs-selector-tag">b</span>)&#123;return <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.x</span>*<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.y-a</span><span class="hljs-selector-class">.y</span>*<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.x</span>;&#125;//叉积<br></code></pre></td></tr></table></figure><h4 id="求法线"><a href="#求法线" class="headerlink" title="求法线"></a>求法线</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Vector <span class="hljs-constructor">Normal_line(Vector <span class="hljs-params">a</span>)</span> &#123;double len=<span class="hljs-constructor">Len(<span class="hljs-params">a</span>)</span>;return <span class="hljs-constructor">Vector(-<span class="hljs-params">a</span>.<span class="hljs-params">y</span><span class="hljs-operator">/</span><span class="hljs-params">len</span>,<span class="hljs-params">a</span>.<span class="hljs-params">x</span><span class="hljs-operator">/</span><span class="hljs-params">len</span>)</span>;&#125;<span class="hljs-comment">//求向量A的单位法线</span><br></code></pre></td></tr></table></figure><h4 id="求夹角"><a href="#求夹角" class="headerlink" title="求夹角"></a>求夹角</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">inline LD Angle(Vector <span class="hljs-selector-tag">a</span>,Vector <span class="hljs-selector-tag">b</span>) &#123;return acos(Dot(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>)/len(<span class="hljs-selector-tag">a</span>)/len(<span class="hljs-selector-tag">b</span>));&#125;<br></code></pre></td></tr></table></figure><h3 id="位置变换"><a href="#位置变换" class="headerlink" title="位置变换"></a>位置变换</h3><h4 id="向量位移重载运算符直接加减-amp-amp-数乘"><a href="#向量位移重载运算符直接加减-amp-amp-数乘" class="headerlink" title="向量位移重载运算符直接加减&amp;&amp;数乘"></a>向量位移重载运算符直接加减&amp;&amp;数乘</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Vector operator+(Vector a,Vector b)&#123;return <span class="hljs-constructor">Vector(<span class="hljs-params">a</span>.<span class="hljs-params">x</span>+<span class="hljs-params">b</span>.<span class="hljs-params">x</span>,<span class="hljs-params">a</span>.<span class="hljs-params">y</span>+<span class="hljs-params">b</span>.<span class="hljs-params">y</span>)</span>;&#125;<br>inline Vector operator-(Vector a,Vector b)&#123;return <span class="hljs-constructor">Vector(<span class="hljs-params">a</span>.<span class="hljs-params">x</span>-<span class="hljs-params">b</span>.<span class="hljs-params">x</span>,<span class="hljs-params">a</span>.<span class="hljs-params">y</span>-<span class="hljs-params">b</span>.<span class="hljs-params">y</span>)</span>;&#125;<br>inline Vector operator*(Vector a,LD b)&#123;return <span class="hljs-constructor">Vector(<span class="hljs-params">a</span>.<span class="hljs-params">x</span><span class="hljs-operator">*</span><span class="hljs-params">b</span>,<span class="hljs-params">a</span>.<span class="hljs-params">y</span><span class="hljs-operator">*</span><span class="hljs-params">b</span>)</span>;&#125;<br></code></pre></td></tr></table></figure><h4 id="点-amp-amp-向量旋转"><a href="#点-amp-amp-向量旋转" class="headerlink" title="点&amp;&amp;向量旋转"></a>点&amp;&amp;向量旋转</h4><p>将向量顺时针旋转$\theta$角度(点的话是绕原点旋转)，相当于乘上了个旋转矩阵。<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sas">inline Point turn_P(Point a,LD theta)&#123;//点A\向量A顺时针旋转theta(弧度)<br>    LD <span class="hljs-meta">x</span>=a.<span class="hljs-meta">x</span><span class="hljs-meta">*cos(</span>theta)+a.y<span class="hljs-meta">*sin(</span>theta);<br>    LD y=-a.<span class="hljs-meta">x</span><span class="hljs-meta">*sin(</span>theta)+a.y<span class="hljs-meta">*cos(</span>theta);<br>    <span class="hljs-meta">return</span><span class="hljs-meta"> Point(</span><span class="hljs-meta">x</span>,y);<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="点绕点旋转"><a href="#点绕点旋转" class="headerlink" title="点绕点旋转"></a>点绕点旋转</h4><p>点绕点旋转，实际上可以看作是先平移坐标系把中心点平移到原点的位置，然后点绕原点旋转后再平移回去<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sas">inline Point turn_PP(Point a,Point b,LD theta)&#123;//将点A绕点B顺时针旋转theta(弧度)<br>    LD <span class="hljs-meta">x</span>=(a.<span class="hljs-meta">x</span>-b.<span class="hljs-meta">x</span>)<span class="hljs-meta">*cos(</span>theta)+(a.y-b.y)<span class="hljs-meta">*sin(</span>theta)+b.<span class="hljs-meta">x</span>;<br>    LD y=-(a.<span class="hljs-meta">x</span>-b.<span class="hljs-meta">x</span>)<span class="hljs-meta">*sin(</span>theta)+(a.y-b.y)<span class="hljs-meta">*cos(</span>theta)+b.y;<br>    <span class="hljs-meta">return</span><span class="hljs-meta"> Point(</span><span class="hljs-meta">x</span>,y);<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="点与线"><a href="#点与线" class="headerlink" title="点与线"></a>点与线</h3><h4 id="判断点是否在线段上"><a href="#判断点是否在线段上" class="headerlink" title="判断点是否在线段上"></a>判断点是否在线段上</h4><p>点若在线段上，呢么其与线段上两端点的夹角为180度，其叉积为0，点积不大于0<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> pan<span class="hljs-constructor">_PL(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//判断点P是否在线段AB上</span><br>    <span class="hljs-keyword">if</span>(a==b)return <span class="hljs-literal">false</span>;<span class="hljs-comment">//AB重合，线段不存在</span><br>    return !dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>,<span class="hljs-params">b</span>-<span class="hljs-params">a</span>)</span>)&amp;&amp;dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>,<span class="hljs-params">p</span>-<span class="hljs-params">b</span>)</span>)&lt;=<span class="hljs-number">0</span>;<span class="hljs-comment">//注意，根据icpc2021昆明i题发现，由于求交点时本身就会产生精度误差，使用叉积来判断向量平行不再放宽精度则会放大此误差，因此假如已经确定点在线段所在的直线上后可以根据需要去除第一个条件 </span><br>    <span class="hljs-comment">//return dcmp(Dot(p-a,p-b))&lt;=0; </span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="判断点是否在直线上"><a href="#判断点是否在直线上" class="headerlink" title="判断点是否在直线上"></a>判断点是否在直线上</h4><p>点若在直线上，呢么就只剩下与直线上任意两其他点的叉积为0，无点积约束<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> pan<span class="hljs-constructor">_PL_(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//判断点P是否在线段AB上</span><br>    return !dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>,<span class="hljs-params">b</span>-<span class="hljs-params">a</span>)</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="点到线段AB距离"><a href="#点到线段AB距离" class="headerlink" title="点到线段AB距离"></a>点到线段AB距离</h4><p>假如点与线段的垂线不在线段上，返回与最近的端点之间的距离。若是在线段上，呢么用与两端点围成三角形的面积除以底边长来算，运用了两向量叉积的数值等于两向量组成的平行四边形的面积的性质。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> operator==(Point a,Point b)&#123;return !dcmp(a.x-b.x)&amp;&amp;!dcmp(a.y-b.y);&#125;<span class="hljs-comment">//判断点的相等</span><br>inline LD dis<span class="hljs-constructor">_PL(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//点P到线段AB距离</span><br>    <span class="hljs-keyword">if</span>(a==b)return <span class="hljs-constructor">Len(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>)</span>;<span class="hljs-comment">//AB重合</span><br>    Vector x=p-a,y=p-b,z=b-a;<br>    <span class="hljs-keyword">if</span>(dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">x</span>,<span class="hljs-params">z</span>)</span>)&lt;<span class="hljs-number">0</span>)return <span class="hljs-constructor">Len(<span class="hljs-params">x</span>)</span>;<span class="hljs-comment">//P距离A更近</span><br>    <span class="hljs-keyword">if</span>(dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">y</span>,<span class="hljs-params">z</span>)</span>)&gt;<span class="hljs-number">0</span>)return <span class="hljs-constructor">Len(<span class="hljs-params">y</span>)</span>;<span class="hljs-comment">//P距离B更近</span><br>    return <span class="hljs-constructor">Abs(Cro(<span class="hljs-params">x</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Len(<span class="hljs-params">z</span>)</span>);<span class="hljs-comment">//面积除以底边长</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="点到直线AB距离"><a href="#点到直线AB距离" class="headerlink" title="点到直线AB距离"></a>点到直线AB距离</h4><p>到直线的距离就不用判断端点了<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> operator==(Point a,Point b)&#123;return !dcmp(a.x-b.x)&amp;&amp;!dcmp(a.y-b.y);&#125;<span class="hljs-comment">//判断点的相等</span><br>inline LD dis<span class="hljs-constructor">_PL_(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//点P到线段AB距离</span><br>    <span class="hljs-keyword">if</span>(a==b)return <span class="hljs-constructor">Len(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>)</span>;<span class="hljs-comment">//AB重合</span><br>    Vector x=p-a,y=p-b,z=b-a;<br>    return <span class="hljs-constructor">Abs(Cro(<span class="hljs-params">x</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Len(<span class="hljs-params">z</span>)</span>);<span class="hljs-comment">//面积除以底边长</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="返回点到直线AB的垂足"><a href="#返回点到直线AB的垂足" class="headerlink" title="返回点到直线AB的垂足"></a>返回点到直线AB的垂足</h4><p>求出垂足到a，a到b的长度的比例，然后加到a点上即可。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Point <span class="hljs-constructor">Foot_PL(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//点P到直线AB的垂足</span><br>    Vector x=p-a,y=p-b,z=b-a;<br>    LD len1=<span class="hljs-constructor">Dot(<span class="hljs-params">x</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Len(<span class="hljs-params">z</span>)</span>,len2=-<span class="hljs-number">1.0</span>*<span class="hljs-constructor">Dot(<span class="hljs-params">y</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Len(<span class="hljs-params">z</span>)</span>;<span class="hljs-comment">//分别计算AP,BP在AB,BA上的投影</span><br>    return a+z*(len1/(len1+len2));<span class="hljs-comment">//点A加上向量AF</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="返回点P关于AB的对称点"><a href="#返回点P关于AB的对称点" class="headerlink" title="返回点P关于AB的对称点"></a>返回点P关于AB的对称点</h4><p>将点p到垂足的距离延长一倍即可<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">inline Point Symmetry_PL(Point <span class="hljs-selector-tag">p</span>,Point <span class="hljs-selector-tag">a</span>,Point <span class="hljs-selector-tag">b</span>)&#123;//点<span class="hljs-selector-tag">P</span>关于直线AB的对称点<br>    return <span class="hljs-selector-tag">p</span>+(Foot_PL(<span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>)-<span class="hljs-selector-tag">p</span>)*<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="线与线"><a href="#线与线" class="headerlink" title="线与线"></a>线与线</h3><h4 id="求两直线交点"><a href="#求两直线交点" class="headerlink" title="求两直线交点"></a>求两直线交点</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Point cross<span class="hljs-constructor">_LL(Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>,Point <span class="hljs-params">c</span>,Point <span class="hljs-params">d</span>)</span>&#123;<span class="hljs-comment">//两直线AB,CD的交点</span><br>    Vector x=b-a,y=d-c,z=a-c;<br>    return a+x*(<span class="hljs-constructor">Cro(<span class="hljs-params">y</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Cro(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span>);<span class="hljs-comment">//点A加上向量AF</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判断直线AB与线段CD是否相交"><a href="#判断直线AB与线段CD是否相交" class="headerlink" title="判断直线AB与线段CD是否相交"></a>判断直线AB与线段CD是否相交</h4><p>实际上就是看直线与线段所在的直线交点是否在线段上<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> pan<span class="hljs-constructor">_cross_L_L(Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>,Point <span class="hljs-params">c</span>,Point <span class="hljs-params">d</span>)</span>&#123;<span class="hljs-comment">//判断直线AB与线段CD是否相交</span><br>    return pan<span class="hljs-constructor">_PL(<span class="hljs-params">cross_LL</span>(<span class="hljs-params">a</span>,<span class="hljs-params">b</span>,<span class="hljs-params">c</span>,<span class="hljs-params">d</span>)</span>,c,d);<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="判断两线段是否相交"><a href="#判断两线段是否相交" class="headerlink" title="判断两线段是否相交"></a>判断两线段是否相交</h4><p>若是端点在另一条直线上直接返回true，不在的话根据叉积的性质来判定，一个线段两端点端点和另一个线段的两端点组成的向量叉积假如符号相同的话就代表在同一侧.<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> pan<span class="hljs-constructor">_cross_LL(Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>,Point <span class="hljs-params">c</span>,Point <span class="hljs-params">d</span>)</span>&#123;<span class="hljs-comment">//判断两线段AB,CD是否相交</span><br>    <span class="hljs-keyword">if</span>(pan<span class="hljs-constructor">_PL(<span class="hljs-params">a</span>,<span class="hljs-params">c</span>,<span class="hljs-params">d</span>)</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span>pan<span class="hljs-constructor">_PL(<span class="hljs-params">b</span>,<span class="hljs-params">c</span>,<span class="hljs-params">d</span>)</span><span class="hljs-operator">||</span>pan<span class="hljs-constructor">_PL(<span class="hljs-params">c</span>,<span class="hljs-params">a</span>,<span class="hljs-params">b</span>)</span><span class="hljs-operator">||</span>pan<span class="hljs-constructor">_PL(<span class="hljs-params">d</span>,<span class="hljs-params">a</span>,<span class="hljs-params">b</span>)</span>)return <span class="hljs-literal">true</span>;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">LD</span> c1=<span class="hljs-constructor">Cro(<span class="hljs-params">b</span>-<span class="hljs-params">a</span>,<span class="hljs-params">c</span>-<span class="hljs-params">a</span>)</span>,c2=<span class="hljs-constructor">Cro(<span class="hljs-params">b</span>-<span class="hljs-params">a</span>,<span class="hljs-params">d</span>-<span class="hljs-params">a</span>)</span>;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">LD</span> d1=<span class="hljs-constructor">Cro(<span class="hljs-params">d</span>-<span class="hljs-params">c</span>,<span class="hljs-params">a</span>-<span class="hljs-params">c</span>)</span>,d2=<span class="hljs-constructor">Cro(<span class="hljs-params">d</span>-<span class="hljs-params">c</span>,<span class="hljs-params">b</span>-<span class="hljs-params">c</span>)</span>;</span><br><span class="hljs-pattern-match">    return dcmp(c1)<span class="hljs-operator">*</span>dcmp(c2)&lt;0<span class="hljs-operator">&amp;&amp;</span>dcmp(d1)<span class="hljs-operator">*</span>dcmp(d2)&lt;0;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="点与多边形"><a href="#点与多边形" class="headerlink" title="点与多边形"></a>点与多边形</h3><h4 id="判断点是否在任意多边形内"><a href="#判断点是否在任意多边形内" class="headerlink" title="判断点是否在任意多边形内"></a>判断点是否在任意多边形内</h4><p>使用射线法，时间复杂度为O(n)。<br>射线法（Ray casting algorithm）是一种判断点是否在多边形内部的一种简单方法。即从该点做一条射线，计算它跟多边形边界的交点个数，如果交点个数为奇数，那么点在多边形内部，否则点在多边形外部。<br>附上<a href="http://blog.sina.com.cn/s/blog_86186c970102ybwn.html">简单易懂的证明以及细节</a><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">PIP</span><span class="hljs-params">(Point *P,<span class="hljs-keyword">int</span> n,Point a)</span></span>&#123;<span class="hljs-comment">//射线法判断点A是否在任意多边形P[]以内</span><br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;LD tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">int</span> j=i&lt;n?i+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(pan_PL(a,P[i],P[j]))<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//点在多边形上</span><br>        <span class="hljs-keyword">if</span>(a.y&gt;=<span class="hljs-built_in">min</span>(P[i].y,P[j].y)&amp;&amp;a.y&lt;<span class="hljs-built_in">max</span>(P[i].y,P[j].y))<span class="hljs-comment">//纵坐标在该线段两端点之间</span><br>            tmp=P[i].x+(a.y-P[i].y)/(P[j].y-P[i].y)*(P[j].x-P[i].x),cnt+=dcmp(tmp-a.x)&gt;<span class="hljs-number">0</span>;<span class="hljs-comment">//交点在A右方</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt&amp;<span class="hljs-number">1</span>;<span class="hljs-comment">//返回2表明在多边形边上，返回1代表在多边形内，返回0代表在多边形外</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="判断点是否在凸多边形内"><a href="#判断点是否在凸多边形内" class="headerlink" title="判断点是否在凸多边形内"></a>判断点是否在凸多边形内</h4><p>使用二分法，时间复杂度为O(logn)<br>首先选择多边形其中一个点为起点，连接其它点作射线，将整个凸多边形分为多个小三角形。然后在射线围成的区域里判断点到底是在左半边还是右半边，最后确定的区域肯定会在一个三角形内。之后判断这个点是否在这个三角形内即可。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">int</span> judge(Point a,Point L,Point R)&#123;<span class="hljs-comment">//判断AL是否在AR右边</span><br>    return dcmp(<span class="hljs-constructor">Cro(L-<span class="hljs-params">a</span>,R-<span class="hljs-params">a</span>)</span>)&gt;<span class="hljs-number">0</span>;<span class="hljs-comment">//必须严格以内</span><br>&#125;<br>inline <span class="hljs-built_in">int</span> <span class="hljs-constructor">PIP_(Point <span class="hljs-operator">*</span>P,Re <span class="hljs-params">n</span>,Point <span class="hljs-params">a</span>)</span>&#123;<span class="hljs-comment">//二分法判断点A是否在凸多边形P以内</span><br>    <span class="hljs-comment">//点按逆时针给出</span><br>    <span class="hljs-keyword">if</span>(judge(P<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>,a,P<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>)<span class="hljs-pattern-match"><span class="hljs-operator">||</span>judge(<span class="hljs-constructor">P</span>[1],<span class="hljs-constructor">P</span>[n],a))return 0;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>在<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_2</span>]或<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_n</span>]外</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span>(pan<span class="hljs-constructor">_PL(<span class="hljs-params">a</span>,P[1],P[2])</span><span class="hljs-operator">||</span>pan<span class="hljs-constructor">_PL(<span class="hljs-params">a</span>,P[1],P[<span class="hljs-params">n</span>])</span>)return 2;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>在<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_2</span>]或<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_n</span>]上</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">Re</span> l=2,r=n-1;</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>二分找到一个位置pos使得<span class="hljs-constructor">P</span>[1]<span class="hljs-constructor">_A</span>在<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_pos</span>],<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_(<span class="hljs-params">pos</span>+1)</span>]之间</span><br><span class="hljs-pattern-match">        <span class="hljs-constructor">Re</span> mid=l+r+1&gt;&gt;1;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span>(judge(<span class="hljs-constructor">P</span>[1],<span class="hljs-constructor">P</span>[mid],a))l=mid;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">else</span> r=mid-1;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span>(judge(<span class="hljs-constructor">P</span>[l],a,<span class="hljs-constructor">P</span>[l+1]))return 0;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>在<span class="hljs-constructor">P</span>[pos<span class="hljs-constructor">_(<span class="hljs-params">pos</span>+1)</span>]外</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span>(pan<span class="hljs-constructor">_PL(<span class="hljs-params">a</span>,P[<span class="hljs-params">l</span>],P[<span class="hljs-params">l</span>+1])</span>)return 2;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>在<span class="hljs-constructor">P</span>[pos<span class="hljs-constructor">_(<span class="hljs-params">pos</span>+1)</span>]上</span><br><span class="hljs-pattern-match">    return 1;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="线与多边形"><a href="#线与多边形" class="headerlink" title="线与多边形"></a>线与多边形</h3><h4 id="判断线段是否在任意多边形内"><a href="#判断线段是否在任意多边形内" class="headerlink" title="判断线段是否在任意多边形内"></a>判断线段是否在任意多边形内</h4><p>用射线法判断两端点是否在多边形内，之后再判断线段和多边形的其他线段是否有交点。</p><h4 id="判断线段是否在任意多边形内-1"><a href="#判断线段是否在任意多边形内-1" class="headerlink" title="判断线段是否在任意多边形内"></a>判断线段是否在任意多边形内</h4><p>只需要判断两端点都在多边形内即可，不过再返回都为2时(及线段两端点都在多边形上)，需要进行特判看是否线段在多边形上。</p><h3 id="多边形相关"><a href="#多边形相关" class="headerlink" title="多边形相关"></a>多边形相关</h3><h4 id="判断任意两个多边形是否相离"><a href="#判断任意两个多边形是否相离" class="headerlink" title="判断任意两个多边形是否相离"></a>判断任意两个多边形是否相离</h4><p>属于不同多边形的任意两边都不相交 且一个多边形上的任意点都不被另一个多边形所包含。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">int</span> judge<span class="hljs-constructor">_PP(Point <span class="hljs-operator">*</span>A,<span class="hljs-params">int</span> <span class="hljs-params">n</span>,Point <span class="hljs-operator">*</span>B,<span class="hljs-params">int</span> <span class="hljs-params">m</span>)</span>&#123;<span class="hljs-comment">//【判断多边形A与多边形B是否相离】 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i1=<span class="hljs-number">1</span>;i1&lt;=n;++i1)&#123;<br>        <span class="hljs-built_in">int</span> j1=i1&lt;n?i1+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i2=<span class="hljs-number">1</span>;i2&lt;=m;++i2)&#123;<br>            <span class="hljs-built_in">int</span> j2=i2&lt;m?i2+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(pan<span class="hljs-constructor">_cross_LL(A[<span class="hljs-params">i1</span>],A[<span class="hljs-params">j1</span>],B[<span class="hljs-params">i2</span>],B[<span class="hljs-params">j2</span>])</span>)return <span class="hljs-number">0</span>;<span class="hljs-comment">//两线段相交</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-constructor">PIP(B,<span class="hljs-params">m</span>,A[<span class="hljs-params">i1</span>])</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span><span class="hljs-constructor">PIP(A,<span class="hljs-params">n</span>,B[<span class="hljs-params">i2</span>])</span>)return 0;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>点包含在内</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">    return 1;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure></p><h4 id="求任意多边形面积"><a href="#求任意多边形面积" class="headerlink" title="求任意多边形面积"></a>求任意多边形面积</h4><p>使用鞋带定理(Shoelace formula) ，用来求任意多边形面积,这里是<a href="https://zhuanlan.zhihu.com/p/110025234">证明</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> LD <span class="hljs-title">P_Area</span><span class="hljs-params">(Point *P,Re n)</span></span>&#123;<span class="hljs-comment">//鞋带定理求任意多边形P的面积</span><br>    LD S=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)S+=Cro(P[i],P[i&lt;n?i+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> S/<span class="hljs-number">2.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="求圆的面积并"><a href="#求圆的面积并" class="headerlink" title="求圆的面积并"></a>求圆的面积并</h4><p>首先得学习一下<a href="https://blog.csdn.net/xyz32768/article/details/81392369">自适应辛普森法</a>，这是一种用二次函数来逼近曲线的一种方法(有点像泰勒，怪)，不过肯定是有精度误差的，因此需要将积分区域减少以减少误差。</p><h5 id="自适应辛普森法"><a href="#自适应辛普森法" class="headerlink" title="自适应辛普森法"></a>自适应辛普森法</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">inline LD f(LD x)<br>&#123;<br>    /*函数表达式*/<br>&#125;<br>inline LD simpson(LD l,LD <span class="hljs-built_in">r</span>)<br>&#123;<br>    LD mid=(l+<span class="hljs-built_in">r</span>)/<span class="hljs-number">2.0</span>;<br>    <span class="hljs-keyword">return</span> (f(l)+<span class="hljs-number">4.0</span>*f(mid)+f(<span class="hljs-built_in">r</span>))*(<span class="hljs-built_in">r</span><span class="hljs-literal">-l</span>)/<span class="hljs-number">6.0</span>;<br>&#125; <br>inline LD solve(LD l,LD <span class="hljs-built_in">r</span>,LD eps)<br>&#123;<br>    LD mid=(l+<span class="hljs-built_in">r</span>)/<span class="hljs-number">2.0</span>;<br>    LD s=simpson(l,<span class="hljs-built_in">r</span>),<span class="hljs-built_in">sl</span>=simpson(l,mid),sr=simpson(mid,<span class="hljs-built_in">r</span>);<br>    <span class="hljs-keyword">if</span>(dcmp(<span class="hljs-built_in">sl</span>+sr<span class="hljs-literal">-s</span>)) <span class="hljs-keyword">return</span> (<span class="hljs-built_in">sl</span>+sr+(<span class="hljs-built_in">sl</span>+sr<span class="hljs-literal">-s</span>));//注意，这里对精度要求较高，可能需要更改dcmp的精度范围<br>    <span class="hljs-keyword">return</span> solve(l,mid,eps/<span class="hljs-number">2.0</span>)+solve(mid,<span class="hljs-built_in">r</span>,eps/<span class="hljs-number">2.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>(哇，博客园一直在审核，好多东西都搜不到，待更。)</p><h5 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h5><p>扫描线好像求⚪的面积并很难搞，只不过和自适应辛普森差不多都是求面积的所以先放到一块，交给你了！后来的林泽音。(　ﾟ 3ﾟ)</p><h4 id="三角形面积并"><a href="#三角形面积并" class="headerlink" title="三角形面积并"></a>三角形面积并</h4><p>跟⚪的面积并大概差不多？只不过都是直线应该用扫描线更好一点？(・ω・)</p><h3 id="圆相关"><a href="#圆相关" class="headerlink" title="圆相关"></a>圆相关</h3><h4 id="给点求圆"><a href="#给点求圆" class="headerlink" title="给点求圆"></a>给点求圆</h4><p>拥有初中学历的人都知道，三点才能确定一个圆。<br>好像可以暴力带入公式啥的，不过太麻烦了就先旷过。<br>拥有初中学历的人还知道，圆的圆心在任意两条不平行弦的垂直平分线的交点上。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">struct</span> <span class="hljs-built_in">Circle</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Point</span> <span class="hljs-built_in">O</span><span class="hljs-operator">;</span><span class="hljs-variable">LD</span> <span class="hljs-variable">r</span><span class="hljs-operator">;</span><span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">LD</span> <span class="hljs-variable">R</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">O</span><span class="hljs-operator">=</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">r</span><span class="hljs-operator">=</span><span class="hljs-variable">R</span><span class="hljs-operator">;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">;</span><br><span class="hljs-variable">inline</span> <span class="hljs-built_in">Circle</span> <span class="hljs-variable">getcircle</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">A</span><span class="hljs-operator">,</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span><span class="hljs-built_in">Point</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-operator">//</span>三点确定一圆向量垂心法<br>    <span class="hljs-built_in">Point</span> <span class="hljs-variable">P1</span><span class="hljs-operator">=</span><span class="hljs-punctuation">(</span><span class="hljs-variable">A</span><span class="hljs-operator">+</span><span class="hljs-variable">B</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-number">0.5</span><span class="hljs-operator">,</span><span class="hljs-variable">P2</span><span class="hljs-operator">=</span><span class="hljs-punctuation">(</span><span class="hljs-variable">A</span><span class="hljs-operator">+</span><span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-number">0.5</span><span class="hljs-operator">;</span><br>    <span class="hljs-built_in">Point</span> <span class="hljs-built_in">O</span><span class="hljs-operator">=</span><span class="hljs-type">cross_LL</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P1</span><span class="hljs-operator">,</span><span class="hljs-variable">P1</span><span class="hljs-operator">+</span><span class="hljs-built_in">Normal</span><span class="hljs-punctuation">(</span><span class="hljs-variable">B</span><span class="hljs-operator">-</span><span class="hljs-variable">A</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-variable">P2</span><span class="hljs-operator">,</span><span class="hljs-variable">P2</span><span class="hljs-operator">+</span><span class="hljs-built_in">Normal</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-operator">-</span><span class="hljs-variable">A</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>    <span class="hljs-variable">return</span> <span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span><span class="hljs-variable">Len</span><span class="hljs-punctuation">(</span><span class="hljs-variable">A</span><span class="hljs-operator">-</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><h4 id="最小覆盖圆算法"><a href="#最小覆盖圆算法" class="headerlink" title="最小覆盖圆算法"></a>最小覆盖圆算法</h4><p>使用随机增量法，把点全部打乱然后用同样的方法添加<br>用随机化降低不完全枚举造成有影响后果的概率以达到降低复杂度的目的. . .印象中上一个这个干的算法好像是Pollard_Rho因数分解。<br>具体说明在<a href="https://www.luogu.com.cn/blog/boshi/solution-p1742">这里</a><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">struct</span> <span class="hljs-built_in">Circle</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Point</span> <span class="hljs-built_in">O</span><span class="hljs-operator">;</span><span class="hljs-variable">LD</span> <span class="hljs-variable">r</span><span class="hljs-operator">;</span><span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">LD</span> <span class="hljs-variable">R</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">O</span><span class="hljs-operator">=</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">r</span><span class="hljs-operator">=</span><span class="hljs-variable">R</span><span class="hljs-operator">;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">;</span><br><span class="hljs-variable">inline</span> <span class="hljs-variable">int</span> <span class="hljs-variable">PIC</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Circle</span> <span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">a</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">return</span> <span class="hljs-variable">dcmp</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Len</span><span class="hljs-punctuation">(</span><span class="hljs-variable">a</span><span class="hljs-operator">-</span><span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">)</span><span class="hljs-operator">-</span><span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-variable">r</span><span class="hljs-punctuation">)</span><span class="hljs-operator">&lt;=</span><span class="hljs-number">0</span><span class="hljs-operator">;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">//</span>判断点<span class="hljs-variable">A</span>是否在圆<span class="hljs-built_in">C</span>内<br><span class="hljs-variable">inline</span> <span class="hljs-variable">void</span> <span class="hljs-built_in">Random</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-operator">*</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-built_in">Re</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Re</span> <span class="hljs-variable">i</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">;</span><span class="hljs-variable">i</span><span class="hljs-operator">&lt;=</span><span class="hljs-variable">n</span><span class="hljs-operator">;++</span><span class="hljs-variable">i</span><span class="hljs-punctuation">)</span><span class="hljs-variable">swap</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">rand</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">%</span><span class="hljs-variable">n</span><span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">//</span>随机一个排列<br><span class="hljs-variable">inline</span> <span class="hljs-built_in">Circle</span> <span class="hljs-variable">MinCover</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-operator">*</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-built_in">Re</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-operator">//</span>求点集<span class="hljs-variable">P</span>的最小覆盖圆<br>    <span class="hljs-built_in">Random</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><span class="hljs-built_in">Circle</span> <span class="hljs-built_in">C</span><span class="hljs-operator">=</span><span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>    <span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-variable">int</span> <span class="hljs-variable">i</span><span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-operator">;</span><span class="hljs-variable">i</span><span class="hljs-operator">&lt;=</span><span class="hljs-variable">n</span><span class="hljs-operator">;++</span><span class="hljs-variable">i</span><span class="hljs-punctuation">)</span><span class="hljs-variable">if</span><span class="hljs-punctuation">(</span><span class="hljs-operator">!</span><span class="hljs-variable">PIC</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-built_in">C</span><span class="hljs-operator">=</span><span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>        <span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-variable">int</span> <span class="hljs-variable">j</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">;</span><span class="hljs-variable">j</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">i</span><span class="hljs-operator">;++</span><span class="hljs-variable">j</span><span class="hljs-punctuation">)</span><span class="hljs-variable">if</span><span class="hljs-punctuation">(</span><span class="hljs-operator">!</span><span class="hljs-variable">PIC</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-built_in">O</span><span class="hljs-operator">=</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-operator">+</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-number">0.5</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-variable">r</span><span class="hljs-operator">=</span><span class="hljs-variable">Len</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span><span class="hljs-operator">-</span><span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>            <span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-variable">int</span> <span class="hljs-variable">k</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">;</span><span class="hljs-variable">k</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">j</span><span class="hljs-operator">;++</span><span class="hljs-variable">k</span><span class="hljs-punctuation">)</span><span class="hljs-variable">if</span><span class="hljs-punctuation">(</span><span class="hljs-operator">!</span><span class="hljs-variable">PIC</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">k</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">C</span><span class="hljs-operator">=</span><span class="hljs-variable">getcircle</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">k</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-variable">return</span> <span class="hljs-built_in">C</span><span class="hljs-operator">;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="凸包相关"><a href="#凸包相关" class="headerlink" title="凸包相关"></a>凸包相关</h3><h4 id="给点集求凸包"><a href="#给点集求凸包" class="headerlink" title="给点集求凸包"></a>给点集求凸包</h4><p>我学习的博客上说是Graham扫描法，但是他实际上给的是Andrew算法的代码…<br>感觉Andrew要比Graham要简单，就只介绍下Andrew吧。<br>首先先按按照x优先的顺序排序（坐标从小到大），之后易知第一个点和最后一个点肯定是在凸包上。求凸包时需要扫描一遍所有点，遇到比栈顶向量右边的就替换栈顶向量，左边的直接入栈。 扫描到头会发现. . .这种算法只会算出一半的凸包，呢就反过来再来一遍，也就是第一遍算下凸包，第二遍算上凸包。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> cmp1(Vector a,Vector b)&#123;return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;;<span class="hljs-comment">//按坐标排序</span><br>inline <span class="hljs-built_in">int</span> <span class="hljs-constructor">ConvexHull(Point <span class="hljs-operator">*</span>P,<span class="hljs-params">int</span> <span class="hljs-params">n</span>,Point <span class="hljs-operator">*</span><span class="hljs-params">cp</span>)</span>&#123;<span class="hljs-comment">//cp存的是凸包元素</span><br>    sort(P+<span class="hljs-number">1</span>,P+n+<span class="hljs-number">1</span>,cmp1);<br>    <span class="hljs-built_in">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">while</span>(t&gt;<span class="hljs-number">1</span>&amp;&amp;dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>-1],P[<span class="hljs-params">i</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>-1])</span>)&lt;=<span class="hljs-number">0</span>)--t;<span class="hljs-comment">//假如P[i]此时在栈顶两点组成直线的的右边，呢么此时栈顶两点就必不可能是凸包上的点。</span><br>        cp<span class="hljs-literal">[<span class="hljs-operator">++</span><span class="hljs-identifier">t</span>]</span>=P<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> St=t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;--i)&#123;<br>        <span class="hljs-keyword">while</span>(t&gt;St&amp;&amp;dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>-1],P[<span class="hljs-params">i</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>-1])</span>)&lt;=<span class="hljs-number">0</span>)--t;<br>        cp<span class="hljs-literal">[<span class="hljs-operator">++</span><span class="hljs-identifier">t</span>]</span>=P<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    &#125;<br>    return --t;<span class="hljs-comment">//要减一</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h4><p>旋转卡壳，本质是用凸包上的直线做平行线去找到对踵点，然后由于凸包的壕多性质都可以用对踵点来获得，所以可以用这个算法求很多东西：凸包直径(两点距离最长)，凸包的宽(两点距离最短)，凸包间的最大/小距离，凸多边形最小面积外接矩形，凸多边形最小周长外接矩形<br>比较细的讲解可以学习自<a href="https://blog.csdn.net/pi9nc/article/details/11715227">这篇博文</a></p><h5 id="求凸包直径-宽"><a href="#求凸包直径-宽" class="headerlink" title="求凸包直径/宽"></a>求凸包直径/宽</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">double maxAns=<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[2]-<span class="hljs-params">cp</span>[1])</span>,minAns=<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[2]-<span class="hljs-params">cp</span>[1])</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">3</span>;i&lt;=cnt;++i)&#123;<br>    <span class="hljs-keyword">while</span>(dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>],<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>])</span>-<span class="hljs-constructor">Cro(<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>],<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>+1]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>])</span>)&lt;<span class="hljs-number">0</span>)j=j&lt;cnt?j+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<span class="hljs-comment">//找到对踵点。注意是&lt;0，如果写&lt;=0的话可能会被两个点的数据卡掉</span><br>    maxAns=max(maxAns,max(<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>])</span>,<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>+1])</span>));<span class="hljs-comment">//求凸包直径</span><br>    minAns=min(minAns,min(<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>])</span>,<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>+1])</span>));<span class="hljs-comment">//求凸包的宽</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="求面积最小矩形覆盖"><a href="#求面积最小矩形覆盖" class="headerlink" title="求面积最小矩形覆盖"></a>求面积最小矩形覆盖</h5><p>主要思路和基本的旋转卡壳差不多，但是要同时旋转三个点，以及定了矩形框架后用交线来<br>打好的<a href="https://paste.ubuntu.com/p/tVfRkNW5BB/">代码</a>本来是交给<a href="https://www.luogu.com.cn/problem/P3187">luogu</a>的. . .但是一直40pts还不给看数据，怀疑是莫得spj的问题但是有spj的BZOJ也早就凉了，所以到现在还莫得过，所以先把锅推给莫得spj，自己先用着代码。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">double minArea=<span class="hljs-number">10000000.0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">2</span>,z=<span class="hljs-number">2</span>,k=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;<br><span class="hljs-keyword">while</span>(dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>-<span class="hljs-constructor">Cro(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>)&gt;<span class="hljs-number">0</span>)j=j&lt;n?j+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>-<span class="hljs-constructor">Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>)&gt;<span class="hljs-number">0</span>)z=z&lt;n?z+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<span class="hljs-comment">//找到宽</span><br>k=(i==<span class="hljs-number">1</span>)?j:k;<br><span class="hljs-keyword">while</span>(dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>-<span class="hljs-constructor">Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>)&gt;<span class="hljs-number">0</span>)k=k&lt;n?k+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<span class="hljs-comment">//找到宽</span><br>        LD dis=<span class="hljs-constructor">Len(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>,kuan,gao;<br>        LD l=<span class="hljs-constructor">Abs(Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>/dis);<br>LD r=<span class="hljs-constructor">Abs(Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>/dis);<br>        LD h=<span class="hljs-constructor">Abs(Cro(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>])</span>/dis);<br>gao=<span class="hljs-constructor">Abs(<span class="hljs-params">h</span>)</span>;kuan=<span class="hljs-constructor">Abs(<span class="hljs-params">r</span>+<span class="hljs-params">l</span>-<span class="hljs-params">dis</span>)</span>;<br><span class="hljs-keyword">if</span>(gao*kuan&lt;minArea)<br>        &#123;<br><span class="hljs-comment">//cout&lt;&lt;gao&lt;&lt;&#x27; &#x27;&lt;&lt;kuan&lt;&lt;&#x27; &#x27;&lt;&lt;minArea&lt;&lt;endl;</span><br>            minArea=gao*kuan;<br>            Square<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>=cross<span class="hljs-constructor">_LL(<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>]+<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>]+Normal_line(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>);<br>            Square<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>=cross<span class="hljs-constructor">_LL(<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>]+<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>]+Normal_line(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>);<br>            Square<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>=cross<span class="hljs-constructor">_LL(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>]+Normal_line(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>);<br>            Square<span class="hljs-literal">[<span class="hljs-number">4</span>]</span>=cross<span class="hljs-constructor">_LL(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>]+Normal_line(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>);<br>            <span class="hljs-comment">//保证逆时针的存点</span><br>        &#125;<br>&#125;<br>printf(<span class="hljs-string">&quot;%.5lf\n&quot;</span>,minArea);<br></code></pre></td></tr></table></figure></p><h5 id="求周长最小矩形覆盖"><a href="#求周长最小矩形覆盖" class="headerlink" title="求周长最小矩形覆盖"></a>求周长最小矩形覆盖</h5><p>面积最小都算出来了，周长最小也是很简单的，就是每次判断一下l+r的大小就行。<br>代码几乎还是上面的就不搞了</p><h4 id="求半平面交"><a href="#求半平面交" class="headerlink" title="求半平面交"></a>求半平面交</h4><p>半平面是指一条直线会把一个平面分成两个部分，其中任意一个部分都是一个半平面，通一般情况下我们需要的是直线左边的半平面。<br>半平面交就是若干半平面的交集，多边形各边的半平面交就是多边形的核（一个可以看到多边形的任何一个角落的区域）<br>具体写法在<a href="https://www.cnblogs.com/chenxiaoran666/p/HalfPlaneIntersection.html">这里</a><br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">struct <span class="hljs-type">Line</span>&#123;<br>    <span class="hljs-type">Point</span> a,b;LD k;Line(<span class="hljs-type">Point</span> A=<span class="hljs-type">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-type">Point</span> B=<span class="hljs-type">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))&#123;a=A,b=B,k=atan2(b.y-a.y,b.x-a.x);&#125;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(const <span class="hljs-type">Line</span> &amp;O)const&#123;<span class="hljs-keyword">return</span> dcmp(k-O.k)?dcmp(k-O.k)&lt;<span class="hljs-number">0</span>:judge(O.a,O.b,a);&#125;//<br>&#125;L[N],Q[N];<br><span class="hljs-keyword">inline</span> <span class="hljs-type">Point</span> <span class="hljs-keyword">cross</span>(<span class="hljs-type">Line</span> L1,<span class="hljs-type">Line</span> L2)&#123;<span class="hljs-keyword">return</span> cross_LL(L1.a,L1.b,L2.a,L2.b);&#125;//获取直线L1,L2的交点 <br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> judge(<span class="hljs-type">Line</span> L,<span class="hljs-type">Point</span> a)&#123;<span class="hljs-keyword">return</span> dcmp(Cro(a-L.a,L.b-L.a))&gt;<span class="hljs-number">0</span>;&#125;//判断点a是否在直线L的右边<br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> halfcut(<span class="hljs-type">Line</span> *L,Re n,<span class="hljs-type">Point</span> *P)&#123;//【半平面交】 <br>    sort(L+<span class="hljs-number">1</span>,L+n+<span class="hljs-number">1</span>);Re m=n;n=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(Re i=<span class="hljs-number">1</span>;i&lt;=m;++i)<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>||dcmp(L[i].k-L[i<span class="hljs-number">-1</span>].k))L[++n]=L[i];<br>    Re h=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(Re i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">while</span>(h&lt;t&amp;&amp;judge(L[i],<span class="hljs-keyword">cross</span>(Q[t],Q[t<span class="hljs-number">-1</span>])))<span class="hljs-comment">--t;//当队尾两个直线交点不是在直线L[i]上或者左边时就出队</span><br>        <span class="hljs-keyword">while</span>(h&lt;t&amp;&amp;judge(L[i],<span class="hljs-keyword">cross</span>(Q[h],Q[h+<span class="hljs-number">1</span>])))++h;//当队头两个直线交点不是在直线L[i]上或者左边时就出队<br>        Q[++t]=L[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(h&lt;t&amp;&amp;judge(Q[h],<span class="hljs-keyword">cross</span>(Q[t],Q[t<span class="hljs-number">-1</span>])))<span class="hljs-comment">--t;</span><br>    <span class="hljs-keyword">while</span>(h&lt;t&amp;&amp;judge(Q[t],<span class="hljs-keyword">cross</span>(Q[h],Q[h+<span class="hljs-number">1</span>])))++h;<br>    n=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(Re i=h;i&lt;=t;++i)P[++n]=<span class="hljs-keyword">cross</span>(Q[i],Q[i&lt;t?i+<span class="hljs-number">1</span>:h]);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="球"><a href="#球" class="headerlink" title="球"></a>球</h3><h4 id="球缺"><a href="#球缺" class="headerlink" title="球缺"></a>球缺</h4><p>球被平面截下的一部分叫做球缺。截面叫做球缺的底面，垂直于截面的直径被截后，剩下的线段长叫做球缺的高(H)。<br>球缺曲面部分的面积（球冠面积）：<script type="math/tex">S=2\pi RH</script><br>球缺体积公式:<script type="math/tex">V=\frac{\pi}{3}(3R-H)H^2</script></p><h4 id="球的体积并"><a href="#球的体积并" class="headerlink" title="球的体积并"></a>球的体积并</h4><p>就是两个球的体积和减去两球被截面所截的球缺体积</p><h3 id="好玩的东西"><a href="#好玩的东西" class="headerlink" title="好玩的东西"></a>好玩的东西</h3><h4 id="求平面最近点对"><a href="#求平面最近点对" class="headerlink" title="求平面最近点对"></a>求平面最近点对</h4><p>平面上有n个二维坐标点，求最近的点对。<br>朴素想法肯定是n方比较，但是神奇的分治保证了可以递归处理问题，使得复杂度达到O(nlognlogn)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> inf = <span class="hljs-number">1e20</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100005</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">double</span> x, y;<br>&#125;<span class="hljs-built_in">point</span>[maxn];<br><span class="hljs-keyword">int</span> n, mpt[maxn];<br><span class="hljs-comment">//以x为基准排序</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmpxy</span><span class="hljs-params">(Point a,Point b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.x!=b.x)<span class="hljs-keyword">return</span> a.x &lt; b.x;<br>    <span class="hljs-keyword">return</span> a.y&lt;b.y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmpy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">point</span>[a].y &lt; <span class="hljs-built_in">point</span>[b].y;&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a &lt; b ? a : b;&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((<span class="hljs-built_in">point</span>[i].x-<span class="hljs-built_in">point</span>[j].x)*(<span class="hljs-built_in">point</span>[i].x-<span class="hljs-built_in">point</span>[j].x)+(<span class="hljs-built_in">point</span>[i].y-<span class="hljs-built_in">point</span>[j].y)*(<span class="hljs-built_in">point</span>[i].y-<span class="hljs-built_in">point</span>[j].y));&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Closest_Pair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> d=inf;<br>    <span class="hljs-keyword">if</span>(left == right)<span class="hljs-keyword">return</span> d;<br>    <span class="hljs-keyword">if</span>(left+<span class="hljs-number">1</span>==right)<span class="hljs-keyword">return</span> dis(left, right);<br>    <span class="hljs-keyword">int</span> mid=(left+right)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">double</span> d1=Closest_Pair(left,mid);<br>    <span class="hljs-keyword">double</span> d2=Closest_Pair(mid+<span class="hljs-number">1</span>,right);<br>    d = <span class="hljs-built_in">min</span>(d1, d2);<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//分离出宽度为d的区间</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;=right;i++)<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(<span class="hljs-built_in">point</span>[mid].x-<span class="hljs-built_in">point</span>[i].x)&lt;=d)<br>        mpt[k++] = i;<br>    sort(mpt, mpt + k, cmpy);<br>    <span class="hljs-comment">//线性扫描</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;k&amp;&amp;<span class="hljs-built_in">point</span>[mpt[j]].y-<span class="hljs-built_in">point</span>[mpt[i]].y&lt;d;j++)<br>          d=<span class="hljs-built_in">min</span>(d,dis(mpt[i],mpt[j]));<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)<br>  &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf&quot;</span>,&amp;<span class="hljs-built_in">point</span>[i].x,&amp;<span class="hljs-built_in">point</span>[i].y);<br>    sort(<span class="hljs-built_in">point</span>, <span class="hljs-built_in">point</span> + n, cmpxy);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, Closest_Pair(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>计算几何</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>计算几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天梯赛选拔-线段树辅助建图</title>
    <link href="/2021/03/30/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%80%89%E6%8B%94-%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BE%85%E5%8A%A9%E5%BB%BA%E5%9B%BE/"/>
    <url>/2021/03/30/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%80%89%E6%8B%94-%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BE%85%E5%8A%A9%E5%BB%BA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>背景： 天梯赛选拔赛被打爆了. . .<br>复盘发现是由于在两道题上浪费了太多时间并且最后没修出来。<br>一道暴力题我最开始就没想到裸暴力能过便死在了繁杂的优化上，还有一道就是这道题。<br>我考试中有想到过大体的方向，就是把区间缩点，和正解大致思路是相同的<br><del>(所以我感觉我的方向是对的就几乎把时间全花在这上面了)</del><br>但我当时不知道有线段树辅助建图的这个方法，于是自己用了一种十分繁杂的办法排列建图区间的左右端点然后再扫一遍端点确定缩点的范围来建图. . .<br>然后改细节改到心态崩溃<br>最后一直在这两道题之间反复横跳(因为感觉自己能打就差一点)。<br><del>下来后HS说这玩意他用线段树秒了。</del>便学习了这个算法。</p></blockquote><p>先看一下题目吧。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一个 n 个点的无向图。开始时图中没有边，之后yxh将进行 m 次加边操作，其中第 i 次操作具体描述如下：<br>每个操作的描述包含两个在 [1, n] 范围内的互不相同的整数 $l_i$, $r_i$，和一个正整数 $c_i$，对于所有满足$l_i$ ≤ s &lt; t ≤ $r_i$ 的点对 (s, t)，都在点 s 和点 t 之间加上一条长度为 $c_i$ 的无向边。<br>在所有加边操作完成后，yxh要求你计算出从节点 1 到节点 n 的最短路径。如果不存在任何从 1 到n 的路径，则输出 −1。</p></blockquote><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><p>第一行包含两个个正整数 n, m(2 ≤ n, m ≤ $10^5$)，含义如上所示。<br>接下来的 m 行，每行都包含三个整数 $l_i$, $r_i$(1 ≤ $l_i$ &lt; $r_i$ ≤ n), $c_i$(1 ≤ $c_i$ ≤ $10^9$)，含义如上所示。</p><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><p>输出包含一行，代表从节点 1 到节点 n 的最短路径。如果不存在任何从 1 到 n 路径，则输出 −1。</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>4 3<br>1 3 2<br>2 4 3<br>1 4 6</p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>5</p></blockquote><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>我自己考试时候的想法已经在背景里大致说了，<del>感觉应该可以搞但是麻烦到现在都不想打. . .</del>只讲一下线段树辅助建图吧。<br>我们可以根据题意将其简化为一个模型，<br>就是将每个区间连边操作都当作新建两个新节点(入节点和出节点)，然后保证这个区间里的所有点与入节点都能有一条权值为v的路，以及出节点与区间内所有点都能有一条权值为0的路，入节点和出节点连一条单向权值为0的边。<br>我们可以用线段树来简化这个操作，建两棵线段树，一棵由入节点组成且树上的边为指向父亲的权值为0的单向边；另一棵由出节点组成且树上的边为指向儿子的权值为0的单向边。<br>这样我们直接在树上进行连边操作即可。令一个线段树上的点代表其所属区间所有的集合，有新的区间建边操作时，在入节点线段树上找到属于该区间的所有小区间，并令这些小区间的代表点与新建的“操作点”连权值为v的边，出节点线段树的操作和入节点线段树上的操作几乎一样，只不过连的边相反并且边权均为0。<br>显然，每一次区间操作后连的边的期望为$log(区间长度)$,最终连的边数就是mlogn。<br>求最短路部分就用正常最短路算法即可，这里用的是堆优化的dj。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个方法本质上使用线段树的性质是用一点来表示整个区间，从而不需要区间里的每个节点都进行连边，最终达到了简化的目的。<br>我感觉这也正是线段树优化的本质：即用一个节点来记录囊括所有子节点的所需的相关信息，在询问相关问题时就可以用一个节点直接返回答案，减少对子节点的重复访问。<br>这道题为每个节点附上了代表一处区间的含义，然后用大节点来减少小结点的重复访问(建边)。这实际上是对以往区间操作的认知<del>(区间加减乘除)</del>的一个拓展，也是对以后再看到区间相关的题目的一种启发。<br>这个算法目前我打的还是直球版本，由于入节点和出节点的线段树所有操作相同，所以获得两棵线段树之间的联系后应该还可以继续优化。</p><hr><h3 id="update-2021-4-8"><a href="#update-2021-4-8" class="headerlink" title="update 2021/4/8"></a>update 2021/4/8</h3><p>之前一直没提交，然后今天发现OJ上的提交通道开放了，便提交了一下，然后Wa了 . . .<br>然后改改wawa，wawa改改，最后改回了原样，结果就过了<br><img src="/img/postpictures/asfsdvxczgrtrh.png" alt=""><br>然后发现自己在修改的第二个版本加了个打表一直没有删.  . .第一遍没过是因为没用long long。第四遍修改时把所有int改成了longlong，这个版本就应该过了，但是打表没删就一直卡着 . . .<br>菜且星际QAQ</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> x,y,next,v;<br>&#125;e[<span class="hljs-number">100010</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tree</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> ll,rr,num;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> u,d;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> node&amp; rhs) <span class="hljs-keyword">const</span>&#123;<span class="hljs-keyword">return</span> d&gt;rhs.d;&#125;<br>&#125;;<br><span class="hljs-built_in">priority_queue</span>&lt;node&gt;Q; <br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> Link[<span class="hljs-number">100010</span>],jkl=<span class="hljs-number">0</span>,pointnum,n,m,tree1fa,tree2fa;<br>tree point1[<span class="hljs-number">100010</span>],point2[<span class="hljs-number">100010</span>];<span class="hljs-comment">//point1是入点线段树，point2为出点线段树</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy,<span class="hljs-keyword">int</span> vv)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[++jkl].next=Link[xx];e[jkl].x=xx;e[jkl].y=yy;e[jkl].v=vv;Link[xx]=jkl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">build1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ll,<span class="hljs-keyword">int</span> rr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mid=(ll+rr)/<span class="hljs-number">2</span>,nowpoint=++pointnum;<br>    point1[nowpoint].num=pointnum;<br>    <span class="hljs-keyword">if</span>(ll==rr)<br>    &#123;<br>        point1[nowpoint].rr=point1[nowpoint].ll=ll;<br>        insert(ll,nowpoint,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> point1[nowpoint].num;<br>    &#125;<br>    point1[nowpoint].ll=build1(ll,mid);<br>    point1[nowpoint].rr=build1(mid+<span class="hljs-number">1</span>,rr);<br>    insert(point1[nowpoint].ll,nowpoint,<span class="hljs-number">0</span>);<span class="hljs-comment">//在入点线段树上建立0边</span><br>    insert(point1[nowpoint].rr,nowpoint,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> point1[nowpoint].num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">build2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ll,<span class="hljs-keyword">int</span> rr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mid=(ll+rr)/<span class="hljs-number">2</span>,nowpoint=++pointnum;<br>    point2[nowpoint].num=pointnum;<br>    <span class="hljs-keyword">if</span>(ll==rr)<br>    &#123;<br>        point2[nowpoint].rr=point2[nowpoint].ll=ll;<br>        insert(nowpoint,ll,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> point2[nowpoint].num;<br>    &#125;<br>    point2[nowpoint].ll=build2(ll,mid);<br>    point2[nowpoint].rr=build2(mid+<span class="hljs-number">1</span>,rr);<br>    insert(nowpoint,point2[nowpoint].ll,<span class="hljs-number">0</span>);<span class="hljs-comment">//在出点线段树上建立0边</span><br>    insert(nowpoint,point2[nowpoint].rr,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> point2[nowpoint].num;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">edge_in</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ll,<span class="hljs-keyword">int</span> rr,<span class="hljs-keyword">int</span> vv,<span class="hljs-keyword">int</span> nowll,<span class="hljs-keyword">int</span> nowrr,<span class="hljs-keyword">int</span> nowpoint)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mid=(nowll+nowrr)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(ll&lt;=nowll&amp;&amp;rr&gt;=nowrr)<br>    &#123;<br>        insert(nowpoint,pointnum,vv);<span class="hljs-comment">//入点线段树与区间节点建边</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ll&gt;nowrr||rr&lt;nowll)<span class="hljs-keyword">return</span> ;<br>    edge_in(ll,rr,vv,nowll,mid,point1[nowpoint].ll);edge_in(ll,rr,vv,mid+<span class="hljs-number">1</span>,nowrr,point1[nowpoint].rr);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">edge_out</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ll,<span class="hljs-keyword">int</span> rr,<span class="hljs-keyword">int</span> vv,<span class="hljs-keyword">int</span> nowll,<span class="hljs-keyword">int</span> nowrr,<span class="hljs-keyword">int</span> nowpoint)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(ll&gt;nowrr||rr&lt;nowll)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> mid=(nowll+nowrr)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(ll&lt;=nowll&amp;&amp;rr&gt;=nowrr)<br>    &#123;<br>        insert(pointnum,nowpoint,<span class="hljs-number">0</span>);<span class="hljs-comment">//区间节点与出点线段树建边</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <br>    edge_out(ll,rr,vv,nowll,mid,point2[nowpoint].ll);edge_out(ll,rr,vv,mid+<span class="hljs-number">1</span>,nowrr,point2[nowpoint].rr);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dis[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=pointnum;i++) dis[i]=<span class="hljs-number">100000000000ll</span>;<br>dis[st]=<span class="hljs-number">0</span>;<br>node minpoint;<br>minpoint.u=st;minpoint.d=<span class="hljs-number">0</span>;<br>    Q.push(minpoint);<br><span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())<br>&#123;<br>        minpoint=Q.top();Q.pop();<br>        <span class="hljs-keyword">int</span> u=minpoint.u,d=minpoint.d;<br><span class="hljs-keyword">if</span> (dis[u]!=d) <span class="hljs-keyword">continue</span> ;<br><span class="hljs-comment">//cout&lt;&lt;u&lt;&lt;&#x27; &#x27;&lt;&lt;d&lt;&lt;endl;</span><br>        <span class="hljs-comment">//if (d!=dis[u]) continue;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=Link[u];j;j=e[j].next)<span class="hljs-comment">//用最近的点来更新其他点的最近距离</span><br>&#123;<span class="hljs-comment">//保证了前一步找最近的点时找到的就是该点的最短路</span><br><span class="hljs-keyword">if</span>(dis[e[j].y]&gt;d+e[j].v)<br>&#123;<br>dis[e[j].y]=d+e[j].v;<br>                Q.push((node)&#123;e[j].y,dis[e[j].y]&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    freopen(<span class="hljs-string">&quot;a.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-built_in">stdin</span>);<br>    freopen(<span class="hljs-string">&quot;a.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,<span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    pointnum=n;<br>    tree1fa=build1(<span class="hljs-number">1</span>,n);tree2fa=build2(<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,ll,rr,vv;i&lt;=m;i++)  <br>    &#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;ll&gt;&gt;rr&gt;&gt;vv;<br>        pointnum++;<br>        edge_in(ll,rr,vv,<span class="hljs-number">1</span>,n,tree1fa);<br>        edge_out(ll,rr,vv,<span class="hljs-number">1</span>,n,tree2fa);<br>    &#125;<br>    <span class="hljs-comment">/*for(int i=1;i&lt;=pointnum;i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        cout&lt;&lt;i&lt;&lt;&#x27;:&#x27;;</span><br><span class="hljs-comment">        for(int j=Link[i];j;j=e[j].next)cout&lt;&lt;e[j].y&lt;&lt;&#x27; &#x27;;cout&lt;&lt;endl;</span><br><span class="hljs-comment">    &#125;*/</span><br>    dj(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="hljs-comment">//for (int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,dis[i]);</span><br>    <span class="hljs-keyword">if</span>(dis[n]!=dis[<span class="hljs-number">0</span>])<span class="hljs-built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>ACM</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电路分析基础学习笔记 一</title>
    <link href="/2021/03/23/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%801/"/>
    <url>/2021/03/23/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%801/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><pre><code>记录了电路分析的学习，以总结为主复习时使用其中大多数内容来源于丁老师的PPT，自学的时候帮助很大，这里主要是整合划分以及总结一些自己觉得重要的点还有自己的理解</code></pre><p>静态电路的分析就记在这里，动态电路的分析再开一页<a href="https://linzeyin.github.io/2021/05/05/%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%802/">在这里！！</a></p><hr><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><pre><code>一些基础的比较重要的但是没啥可说的都放到这里，想到啥写啥。</code></pre><hr><h3 id="基础术语"><a href="#基础术语" class="headerlink" title="基础术语"></a>基础术语</h3><h4 id="1-二端元件two-terminal"><a href="#1-二端元件two-terminal" class="headerlink" title="1.二端元件two-terminal:"></a><strong>1.二端元件two-terminal:</strong></h4><p>指有两个引出端子的元件，具有两个以上端子的元件称为多端元件，像晶体管就是一种三端元件，变压器是一种四端元件。在集总参数假设条件下，通常只关心元件端子上的特性（称为外部特性），而不注意其内部的情况。</p><h4 id="2-拓扑图topologic-graph"><a href="#2-拓扑图topologic-graph" class="headerlink" title="2.拓扑图topologic graph:"></a><strong>2.拓扑图topologic graph:</strong></h4><p>指用一条线段来代表元件后得到的几何结构图。又称线图，简称图graph。这个电路图就可简化为图(b)的拓扑图。<br><img src="/img/postpictures/drwxbhikkcaw.jpg" alt=""></p><h4 id="3-有向图directed-graph"><a href="#3-有向图directed-graph" class="headerlink" title="3.有向图directed graph:"></a><strong>3.有向图directed graph:</strong></h4><p>指标明参考方向的图。通常图中的参考方向与相应电路图中电流（或电压）的参考方向相同。</p><h4 id="4-支路branch"><a href="#4-支路branch" class="headerlink" title="4.支路branch:"></a><strong>4.支路branch:</strong></h4><p>电路图中的每一个元件，即图中的每一条线段，称为支路。有时为了方便，也可把某些元件的串联组合或并联组合当作一条支路来看待。在图论中也称支路为边。</p><h4 id="5-节点node"><a href="#5-节点node" class="headerlink" title="5.节点node:"></a><strong>5.节点node:</strong></h4><p>指支路的连接点。</p><h4 id="6-路径path"><a href="#6-路径path" class="headerlink" title="6.路径path:"></a><strong>6.路径path:</strong></h4><p>从某一节点出发，连续地经过一些支路和节点(只能各经过一次)，到达另一节点，就构成路径。</p><h4 id="7-回路loop"><a href="#7-回路loop" class="headerlink" title="7.回路loop:"></a><strong>7.回路loop:</strong></h4><p>如果路径的最后到达点就是出发点，这样的闭合路径称为回路。</p><h4 id="8-网孔mesh"><a href="#8-网孔mesh" class="headerlink" title="8.网孔mesh:"></a><strong>8.网孔mesh:</strong></h4><p>在平面图中，构成回路的各支路围成一个区域。并且在区域内部不包含其它支路和节点的回路就称为网孔</p><h4 id="9-电阻元件resistor"><a href="#9-电阻元件resistor" class="headerlink" title="9.电阻元件resistor:"></a><strong>9.电阻元件resistor:</strong></h4><p>分为 线性/非线性，时变/非时变等，本课程主要研究线性非时变电阻元件。</p><h4 id="10-电压源"><a href="#10-电压源" class="headerlink" title="10.电压源:"></a><strong>10.电压源:</strong></h4><p>理想电压源是指不管外部电路如何，其两端电压总能保持定值或一定的时间函数的电源。</p><h4 id="11-电流源"><a href="#11-电流源" class="headerlink" title="11.电流源:"></a><strong>11.电流源:</strong></h4><p>理想电流源是指不管外部电路如何，其输出电流(当方向与外电路电流相反时是吸收电功率)总能保持定值或一定的时间函数的电源。</p><h4 id="12-受控源"><a href="#12-受控源" class="headerlink" title="12.受控源:"></a><strong>12.受控源:</strong></h4><p>是指大小、方向受<strong>电路中其它地方</strong>的电压或电流控制的电源。即电压源的电压或电流源的电流不是给定的时间函数，而是受电路中某支路电压或电流控制。有源的二端口元件，分为受控电流源以及受控电压源。<br><strong>无论是受控源还是电流源和电压源，都只用其输出/输入的性质，其本身的其余性质(电阻等)均忽略。</strong>(但是与回路中电流电压方向相反时实际上和电阻等效)</p><h4 id="13-拓扑约束"><a href="#13-拓扑约束" class="headerlink" title="13.拓扑约束:"></a><strong>13.拓扑约束:</strong></h4><p>指组成电路的各个节点间电流及回路间电压的相互制约关系，这些关系仅由电路的结构(互连形式)决定，而与电路各支路中元件的电特性无关。该约束由基尔霍夫定律(KCL和KVL)体现。</p><h4 id="14-元件约束"><a href="#14-元件约束" class="headerlink" title="14.元件约束:"></a><strong>14.元件约束:</strong></h4><p>来自元件自身的性质，即指每种元件对两个量(电压和电流)形成的一个约束。用VAR体现。<br><strong>这两类约束是解决集总电路问题的基本依据。</strong></p><h4 id="15-网孔电流"><a href="#15-网孔电流" class="headerlink" title="15.网孔电流:"></a><strong>15.网孔电流:</strong></h4><p>指设想在电路的每个网孔里沿着构成该网孔的各支路循环流动的假想电流</p><h4 id="16-自电阻"><a href="#16-自电阻" class="headerlink" title="16.自电阻:"></a><strong>16.自电阻:</strong></h4><p>指各自网孔内所有电阻的总和。</p><h4 id="17-互电阻"><a href="#17-互电阻" class="headerlink" title="17.互电阻:"></a><strong>17.互电阻:</strong></h4><p>指网孔与网孔之间的工有电阻。</p><h4 id="18-互异性"><a href="#18-互异性" class="headerlink" title="18.互异性:"></a><strong>18.互异性:</strong></h4><p>互易性是一类特殊的线性网络的重要性质。一个具有互易性的网络在输入端（激励）与输出端（响应）互换位置后，同一激励所产生的响应并不改变。</p><h4 id="19-对偶性"><a href="#19-对偶性" class="headerlink" title="19.对偶性:"></a><strong>19.对偶性:</strong></h4><p>电路的对偶性体现在电路中的许多变量、元件、结构及定律都是成对出现，并且存在相类似的一一对应的特性。具有这样一一对应性质的一对元素（电路变量、 元件参数、 结构、 定律等），可称为对偶元素。<br>易知：<strong>如果电路中某一定理、公式或方程的表述是成立的，则将其中的元素用其相应对偶元素置换所得到的对偶表述也成立。</strong><br><img src="/img/postpictures/sadfsdvsdagv.PNG" alt="大概就是这样"></p><h4 id="20-线性电路"><a href="#20-线性电路" class="headerlink" title="20.线性电路:"></a><strong>20.线性电路:</strong></h4><p>－指由线性元件、线性受控源及独立源组成的电路。若某线性电阻电路有唯一解，则该电路中任一支路电流和电压均可表示为电路中所有独立源的线性组合。体现为两个主要特性－齐次性和叠加性。</p><h4 id="21-齐次性"><a href="#21-齐次性" class="headerlink" title="21.齐次性:"></a><strong>21.齐次性:</strong></h4><p>设网络的输入为f(t)，输出为y(t)，若 <script type="math/tex">f(t)→y(t)</script>，则： <script type="math/tex">af(t)→ ay(t)</script></p><h4 id="22-叠加性"><a href="#22-叠加性" class="headerlink" title="22.叠加性:"></a><strong>22.叠加性:</strong></h4><p>设网络的输入为f(t)，输出为y(t)，若 <script type="math/tex">f_1(t)→y_1(t),f_2(t)→y_2(t)</script>,则:<script type="math/tex">f_1(t)+f_2(t)→y_1(t)+y_2(t)</script><br><strong>所以我们可得出这么一个结论：若<script type="math/tex">f_1(t)→y_1(t),f_2(t)→y_2(t)</script>且<script type="math/tex">af_1(t) + bf_2(t)→ay_1(t)＋ by_2(t)</script>，呢么该系统就是线性系统。</strong></p><h4 id="23-网络函数"><a href="#23-网络函数" class="headerlink" title="23.网络函数:"></a><strong>23.网络函数:</strong></h4><p>线性、时不变电路在单一激励下，指定的响应(输出)与激励(输入)之比，称为网络函数，记为H，即</p><script type="math/tex; mode=display">H =\frac{输出向量}{输入向量}</script><p>输入(激励)是独立电压源或独立电流源，输出(响应)是感兴趣的某个电压或电流。</p><h4 id="24-数模转换器"><a href="#24-数模转换器" class="headerlink" title="24.数模转换器:"></a><strong>24.数模转换器:</strong></h4><p>将输入的每一位二进制代码按其权的大小转换成相应的模拟量，然后将代表各位的模拟量相加，所得的总模拟量就与数字量成正比，这样便实现了从数字量到模拟量的转换。<br><img src="/img/postpictures/sadgerdgbvfxz.PNG" alt="T型电阻网络DAC原理图"></p><blockquote><p>这种电路的特点：<br>①从任一结点向左或向右看，其等效电阻均为<script type="math/tex">2R</script>；<br>②任一开关接UREF时到地的等效电阻均为<script type="math/tex">3R</script>，即流经该开关的电流为<script type="math/tex">\frac{U_{REF}}{3R}</script>。<br>③电子开关<script type="math/tex">S_3～S_0</script>受输入二进制代码<script type="math/tex">d_3、d_2、d_1、d_0</script>的控制。</p></blockquote><h4 id="25-单口-one-port-网络"><a href="#25-单口-one-port-网络" class="headerlink" title="25.单口(one-port)网络:"></a><strong>25.单口(one-port)网络:</strong></h4><p>在电路分析中可以把互连的一组元件看作为一个整体，从而和其他部分区分开，若这个整体只有两个端钮与外部电路相连接，则不管它的内部结构如何，我们统称它为二端网络或单口网络。<strong>二端网络中从一个端钮流进的电流必定等于另一端钮流出的电流，一个单口网络对电路其余部分的影响，决定于其端口电流电压关系（VAR）</strong></p><h4 id="26-输入电阻"><a href="#26-输入电阻" class="headerlink" title="26.输入电阻:"></a><strong>26.输入电阻:</strong></h4><p>输入电阻等于将独立电源置零后，从端口看进去的等效电阻。“电源置零“的含义是：将电压源短路，使其输出电压为零；将电流源断路，使其输出电流为零。</p><hr><h3 id="电路等效"><a href="#电路等效" class="headerlink" title="电路等效"></a>电路等效</h3><p><strong>1. 等效定义:</strong> 两部分电路 B 与 C， 若对任意外电路 A,二者相互代换能使外电路 A 中有相同的电压、电流、功率，则称 B 电路与 C 电路是互为等效的.<br><strong>2. 等效条件:</strong> B 与 C 电路具有相同的VAR 。<br><strong>3. 等效对象:</strong> 任意外电路 A 中的电流、电压、功率。<br><strong>4. 等效目的:</strong> 为简化电路方便分析(求解)</p><hr><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><h3 id="欧姆定律（VAR）"><a href="#欧姆定律（VAR）" class="headerlink" title="欧姆定律（VAR）"></a>欧姆定律（VAR）</h3><p class="note note-info"><b><font size="2" >在一个回路中，通过某段导体的电流和这段导体两端电压成正比，跟它的电阻却是成反比</font></b></p>中学阶段就已经很熟悉了，在此不做过多叙述<p class="note note-success"><b><font size="3" >欧姆定律解决的是元件上电压、电流的约束关系，这种约束取决于支路元件的性质，与电路结构无关；KCL和KVL阐述的是电路结构上电压、电流的约束关系，取决于电路的连接形式，与支路元件的性质无关。</font></b></p><h3 id="基尔霍夫定律"><a href="#基尔霍夫定律" class="headerlink" title="基尔霍夫定律"></a>基尔霍夫定律</h3><h4 id="节点电流定律-KCL"><a href="#节点电流定律-KCL" class="headerlink" title="节点电流定律(KCL)"></a>节点电流定律(KCL)</h4><p class="note note-info"><b><font size="2" >任一瞬间，流向某一节点电流的代数和恒等于零。</font></b></p><p>直戳了当的结论，就是对于节点i，和它链接的电流为$I_i$，呢么可知 $\sum I_i =0$.及一个节点上流入的电流和流出的电流的代数和总为0.</p><blockquote><p>所谓电荷守恒定律，即是说电荷既不能创造，也不能消灭。基于这条定律，对集总参数电路中某一支路的横截面来说，它“收支”是完全平衡的。即是说，流入横截面多少电荷即刻又从该横截面流出多少电荷，$\frac{dq}{dt}$在一条支路上应处处相等，这就是电流的连续性。那么对于集总参数电路中的节点，在任意时刻t, 它“收支”也是完全平衡的,因此KCL成立。</p></blockquote><p>①KCL是电荷守恒和电流连续性原理在电路中任意节点处的反映；<br>②KCL是对节点处支路电流加的约束，与支路上接什么元件无关，与电路是线性还是非线性无关；<br>③ KCL方程是按电流参考方向列写的，与电流实际方向无关。首先要设出每一支路电流的参考方向，然后依据参考方向是流入或流出取号(流出者取正号，流入者取负号，或者反之)列写出KCL方程。<br>④ KCL具有普遍意义，它适用于任意时刻、任何激励源(直流、交流或其他任意变动激励源)情况下的一切集总参数电路。</p><h4 id="节点电压定律-KVL"><a href="#节点电压定律-KVL" class="headerlink" title="节点电压定律(KVL)"></a>节点电压定律(KVL)</h4><p class="note note-info"><b><font size="2" >对任何集总参数电路，在任意时刻，沿任意闭合路径巡行，各段电路电压的代数和恒等于零。其数学表示式为 $\sum^{m}_{k=1} U_k(t)=0$ (沿任一回路)$U_k(t)$表示各个元件上的电压，m为回路中包含元件的个数。(代数和是指与回路绕行方向一致的支路电压取正号，相反的取负号。)</font></b></p><blockquote><p>KVL的实质，反映了集总参数电路遵从能量守恒定律，或者说，它反映了保守场中做功与路径无关的物理本质。从电路中电压变量的定义容易理解KVL的正确性。如果自a点出发移动单位正电荷，沿着构成回路的各支路又“走”回到a点，相当求电压$u_{a-a}$, 显然应是$ V_a-V_a = 0$.</p></blockquote><p><strong>推论:</strong> 电路中任意两点间的电压等于两点间任一条路径经过的各元件电压的代数和。</p><p class="note note-success"><b><font size="3" >KCL定律的推广应用主要应把握广义结点的正确识别；KVL定律的推广应用则要在充分理解电位单值性原理的基础上，正确列写式中各段电压的正、负。</font></b></p><hr><h3 id="特勒根定理"><a href="#特勒根定理" class="headerlink" title="特勒根定理"></a>特勒根定理</h3><h4 id="特勒根功率定理"><a href="#特勒根功率定理" class="headerlink" title="特勒根功率定理"></a>特勒根功率定理</h4><p class="note note-info"><b><font size="2" >任何时刻，一个具有n个结点和b条支路的集总电路，在支路电流和电压取关联参考方向下吸收的功率之和恒等于零</font></b></p><h4 id="特勒根似功率定理"><a href="#特勒根似功率定理" class="headerlink" title="特勒根似功率定理"></a>特勒根似功率定理</h4><p class="note note-info"><b><font size="2" >任何时刻，对于两个具有n个结点和b条支路的集总电路，当它们具有相同的有向图，但由内容不同的支路构成，在支路电流和电压取关联参考方向下，满足A电压和B电流乘积等于B电压和A电流乘积。</font></b></p><p>公式:$\sum U_A I_B=\sum U_B I_A$，满足U和I都是在有向图相同的支路上。该定理表明，在有向图相同的任意两个电路中，在任何瞬时t，任一电路的支路电压与另一电路相应的支路电流的乘积的代数和恒等于零。</p><blockquote><p>①电路中的支路电压必须满足KVL;<br>②电路中的支路电流必须满足KCL;<br>③电路中的支路电压和支路电流必须满足关联参考方向（否则公式中加负号）；<br>④定理的正确性与元件的特征全然无关。</p></blockquote><hr><h4 id="互易定理"><a href="#互易定理" class="headerlink" title="互易定理"></a>互易定理</h4><p class="note note-info"><b><font size="2" >对一个仅含线性电阻的无源二端口电路$N_R$，其中一个端口加激励源，另一个端口作响应端口，在只有一个激励源的情况下，当激励与响应互换位置时，同一激励所产生的响应相同。</font></b></p><p>大概满足以下三种情况：<br><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/postpictures/uchdungoxj.jpg" alt=""></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/img/postpictures/vcdsvbtrwexsa.jpg" alt=""></div><div class="group-image-wrap"><img src="/img/postpictures/trvccxeodfg.jpg" alt=""></div></div></div><br>其实就是特勒根定律的特殊情况。<br>具有互易性的网络叫互易网络，互易定理是对电路的这种性质所进行的概括，它广泛的应用于网络的灵敏度分析和测量技术等方面。</p><blockquote><p>① 互易前后应保持网络的拓扑结构不变，仅理想电源搬移；<br>②互易前后端口处的激励和响应的极性保持一致（要么都关联，要么都非关联)；<br>③ 互易定理只适用于线性电阻网络在单一电源激励下，端口两个支路电压电流关系。<br>④含有受控源的网络，互易定理一般不成立。(update 2021/4/13需要受控源满足一定限制保证互易后相同)</p></blockquote><hr><h3 id="叠加定理"><a href="#叠加定理" class="headerlink" title="叠加定理"></a>叠加定理</h3><p class="note note-info"><b><font size="2" > </font></b></p><hr><h3 id="齐次定理"><a href="#齐次定理" class="headerlink" title="齐次定理"></a>齐次定理</h3><p class="note note-info"><b><font size="2" >当一个激励源(独立电压源或独立电流源)作用于线性电路，其任意支路的响应(电压或电流)与该激励源成正比。</font></b></p><p>齐次定理描述了线性电路的齐次性或比例性，若激励是电压源<script type="math/tex">u_S</script>，响应是某支路电流i，则<script type="math/tex">i = au_S</script></p><hr><h3 id="置换定理-substitution-theorem"><a href="#置换定理-substitution-theorem" class="headerlink" title="置换定理 substitution theorem"></a>置换定理 substitution theorem</h3><p class="note note-info"><b><font size="2" >具有唯一解的电路中，若知某支路k的电压为$u_k$，电流为$i_k$，且该支路与电路中其他支路无耦合,则无论该支路是由什么元件组成的，都可用<br>(1) 电压等于$u_k$的理想电压源；<br>(2) 电流等于$i_k$的理想电流源；<br>(3) 阻值为$\frac{u_k}{i_k}$的电阻<br>这三种原件去置换.</font></b></p><blockquote><p>① 替代定理既适用于线性电路，也适用于非线性电路。<br>② 替代后其余支路及参数不能改变。<br>③ 替代后电路必须有唯一解。</p></blockquote><p class="note note-danger"><b><font size="3" >注意： “置换”与“等效变换”是两个不同的概念。</font></b><br>“替代”是用独立电压源或电流源替代已知电压或电流的支路，在替代前后，被替代支路以外电路的拓扑结构和元件参数不能改变，因为一旦改变，替代支路的电压和电流也将发生变化；而“等效变换”是两个具有相同端口伏安特性的电路之间的相互转换，与变换以外电路的拓扑结构和元件参数无关。</p><hr><h3 id="戴维南定理"><a href="#戴维南定理" class="headerlink" title="戴维南定理"></a>戴维南定理</h3><p class="note note-info"><b><font size="2" >含独立电源的线性电阻单口网络N，就端口特性而言，可以等效为一个电压源和电阻串联的单口网络。</font></b></p><p>起到的作用是简化电路，需要求出端口的VAR方程然后根据需要进行等效。</p><hr><h3 id="诺顿定理"><a href="#诺顿定理" class="headerlink" title="诺顿定理"></a>诺顿定理</h3><p class="note note-info"><b><font size="2" >含独立电源的线性电阻单口网络N，就端口特性而言，可以等效成一个电流源与电阻并联的网络</font></b></p><p>戴维南等效电路可等效变换为诺顿等效电路。所以只要求得Uoc、Isc、 R0中任意两个，则可得等效电路。本质上是相同的俩个东西。因为可以通过电路等效变化进行代换。</p><hr><h2 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h2><h3 id="2b方程法"><a href="#2b方程法" class="headerlink" title="2b方程法"></a>2b方程法</h3><pre><code>指以支路电流和支路电压为变量列方程求解电路的方法。若电路有b条支路，则共有2b个变量。</code></pre><p><b>KCL独立方程(n-1)个 &amp;&amp; KVL独立方程(b-n+1个) &amp;&amp; 支路方程(b个) 一共2b个</b></p><p class="note note-danger">显而易见的是，2b法未知量较多，方程数目也很多，较为复杂，不建议使用。因此不在此详细说明。</p><h3 id="支路电流法和支路电压法"><a href="#支路电流法和支路电压法" class="headerlink" title="支路电流法和支路电压法"></a>支路电流法和支路电压法</h3><pre><code>支路电流/电压法实际上就是2b法消去部分方程的结果，因此相比于2b法更易计算。</code></pre><p>支路方程法将2b方程法的方程组合表示电流集/电压集之间的关系，减少了联立方程的数目。<br> <b>归纳、明确支路电流法分析电路的步骤。<br>第一步：设出各支路电流，标明参考方向。任取n-1个节点，依KCL列独立节点电流方程(n为电路节点数)。<br>第二步：选取独立回路(平面电路一般选网孔)，并选定巡行方向，依KVL列写出所选独立回路电压方程。<br>第三步：如若电路中含有受控源，并且受控源的控制量就是某一支路电流，那么方程组中方程个数可以不增加，由列写出的基本方程稍加整理即可求解。如果受控源的控制量是另外的变量，那么需对含受控源电路先按前面讲述的步骤一、二去列写基本方程(列写的过程中把受控源先作为独立源一样看待)，然后再加一个控制量用未知电流表示的辅助方程。<br>第四步：求解一、 二、 三步列写的联立方程组，就得到各支路电流。<br>第五步：如果需要，再根据元件约束关系等计算电路中任何处的电压、功率</b></p><h3 id="网孔分析法"><a href="#网孔分析法" class="headerlink" title="网孔分析法"></a>网孔分析法</h3><p>根据网孔电流以及回路关系构造网孔电流方程，第i个网孔的电流方程形式是$ (I_i \times \sum R_i) - \sum (I_j \times R_j)=U_i$,其中$I_i$是该网孔电流，$\sum R_i$是该网孔上所有电阻的和，$\sum (I_j \times R_j)$是与该网孔相交的其他网孔的网孔电流乘上相交部分的电阻的总和，$U_i$是该网孔上电压源输出的总和(带正负符号)。</p><h3 id="节点分析法"><a href="#节点分析法" class="headerlink" title="节点分析法"></a>节点分析法</h3><p>通过与节点相连的电导以及节点的流出电流获得，实质上是节点的流入电流等于节点的流出电流。<br>形式是<script type="math/tex">\sum_{j=1}^{总节点个数}U_{(j)}*G_{(i,j)}=I_i(i=1,2,3...)</script>，其中<script type="math/tex">U_{(j)}</script>是第j个节点的电位，<script type="math/tex">G_{(i,j)}</script>是第i个节点和第个节点直接连的导线的电导。<script type="math/tex">I_i</script>是第i个节点的流出电流。<br>很容易可以看出，这组成了一个线性方程组的形式，其中的系数矩阵由各个边上的电导组成。注意，当电导<script type="math/tex">G_{(i,j)}</script>i=j时该值为该点链接的总电导(正)，当i!=j时，电导值为负值。</p><h3 id="电路分解方法"><a href="#电路分解方法" class="headerlink" title="电路分解方法"></a>电路分解方法</h3><p>通过将电路划分为两个端口网络<script type="math/tex">N_1和N_2</script>，将电路简化求解其VAR，然后联立两者的VAR方程求的其端口电压电流.</p><h3 id="电路的等效变换"><a href="#电路的等效变换" class="headerlink" title="电路的等效变换"></a>电路的等效变换</h3><p>两个两端电路，端口具有相同的电压、电流关系,则称它们是等效的电路。<br>将具有相同VCR的电路替换原电路称为电路的等效变换，未变化的外电路A中的电压、电流和功率关系。（即对外等效，对内不等效）<br>单口网络等效电路</p><p>实际电压源、实际电流源两种模型可以进行等效变换，所谓的等效是指端口的电压、电流在转换过程中保持不变。<br><img src="/img/postpictures/asdggrawetfd.png" alt="转换规则是这样的"></p><p class="note note-danger">实际上是 电压源串联电阻 和 电流源并联电阻 这两个电路进行的转换，电阻值在变换中没有变化。新的电压源和电流源的输出值与原电流源和电压源的值和电阻构成欧姆定理<br>受控电流源的变换是受控电压源，反之亦然</p><p>实际上我们想要的是将复杂电路多个激励源转化为统一电压源用串联方式化简，或者同一电流源用并联方式化简，从而起到简化电路的作用。</p><h3 id="T-Υ-形网络和∏-Δ-形网络的等效变换"><a href="#T-Υ-形网络和∏-Δ-形网络的等效变换" class="headerlink" title="T(Υ)形网络和∏(Δ)形网络的等效变换"></a>T(Υ)形网络和∏(Δ)形网络的等效变换</h3><p><img src="/img/postpictures/dsavrtghrtwhgergfvds.png" alt="先看一下每种网络的形状"><br>转化的具体推导很麻烦. . .这里就仅仅写下结论</p><script type="math/tex; mode=display">R_Y=\frac{\Delta 相邻电阻乘积}{\sum R_{\Delta}} (\Delta \to Y)\\\\ G_{\Delta}=\frac{Y 相邻电导乘积}{\sum G_Y} (Y \to \Delta)</script><p>三变Y电阻，Y变三电导。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>大学课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>大学基础课程</tag>
      
      <tag>电路分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Johnson 算法-Dijkstra的负权图优化</title>
    <link href="/2021/03/21/DJ%20%E7%9A%84%E8%B4%9F%E6%9D%83%E5%9B%BE%E4%BC%98%E5%8C%96/"/>
    <url>/2021/03/21/DJ%20%E7%9A%84%E8%B4%9F%E6%9D%83%E5%9B%BE%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本来是在看费用流的题，结果发现EK+SPFA被卡了，然后发现了该方式的复杂度问题，便学习了Johnson使得DJ可以在负权图上运行。<br>DJ无法处理负权的边，一个显然的解决想法就是给所有的边都加上一个权值保证所有边非负，呢么算出最短路后就可以根据路径上边个数减去相应的增量。<br>这样想看起来很对，但是实际上是有漏洞的。比如这张图。<br><img src="/img/postpictures/safegnuikcxz.jpg" alt=""><br>假如要求从1到3的最短路，原图最短路是[1-4-5-6-3]，但是加权至无负权边之后，[1-2-3]路径总会比原最短路短。<br>这就说明，单纯的同时加上同一个数是不行的。因此我们需要改变加权方式.<br>Johnson 算法则通过另外一种方法来给每条边重新标注边权。它为每一个点设置了一个势能$h_i$。对于一条从u到v，权值为$w_i$的边。将其边权设置成$W_i +h_u -h_v$。<br>势能$h_i$的获得则需要新建立一个和所有点连接的虚节点，与该节点相连的所有边边权为0，之后在该点上跑单源最短路，该点到点i的最短路就是点i的势能$h_i$。<br>输出时用pre数组记录下路径，减去势能即可。<br>证明源自<a href="https://oi-wiki.org/graph/shortest-path/#johnson">OIerWiki</a>。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于网络流的一些整合</title>
    <link href="/2021/03/19/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <url>/2021/03/19/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>高中时期关于网络流仅仅只是学习了EK求最大流，现进行重新学习并于此补充。</p><h3 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>最大流原理就是不停的寻找增广路，最后无流可走就是最大流，其中很妙的一点是增添了反向边这个东西，使得之前未走最优的路径可以通过反向边“反悔”，其他细节的部分源码中有注释。</p><p><strong>Edmond_Karp</strong><br>EK算法是在源点和汇点当中反复使用bfs寻找增广路，每找到一条可行路径就用数组记录下来并增加流量，复杂度就是O(nm^2)<br><a href="https://linzeyin.github.io/2021/02/28/%E6%A8%A1%E6%9D%BF%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/#Edmond-Karp%E6%B1%82%E6%9C%80%E5%A4%A7%E6%B5%81">源码</a></p><p><strong>Dinic</strong><br>Dinic是在EK的基础上进行了优化，用bfs找到增广路之后用dfs寻找所有路径并增加流量，添加了深度数组保证一次dfs可以找到多条可行路径，时间复杂度O(n^2m)，这里是<a href="https://linzeyin.github.io/2021/02/28/%E6%A8%A1%E6%9D%BF%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/#Dinic%E6%B1%82%E6%9C%80%E5%A4%A7%E6%B5%81">源码</a>。<br><a href="https://linzeyin.github.io/2021/02/28/%E6%A8%A1%E6%9D%BF%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/#%E5%BD%93%E5%89%8D%E5%BC%A7%E4%BC%98%E5%8C%96%E7%9A%84Dinic">这个是当前弧优化版本的Dinic，优化效果显著</a><br>实际中遇到的多是最大流问题的变种，需要良好的建模能力才能准确应用</p><hr><h4 id="最小割问题-顶点容量流"><a href="#最小割问题-顶点容量流" class="headerlink" title="最小割问题||顶点容量流"></a>最小割问题||顶点容量流</h4><p>最大流最小割定理:网络的最大流等于最小割<br>这个等于是指在数值上的等于，具体证明不再赘述。最小割主要是分为割点和割边，割边就是明显的最大流问题，割点的话就需要对原图进行拆点转化<br>割点将一个点分为两个点，中间连上一条单向边，流量设为1.而原边的流量设置为极大数。显然，转变后两点之间流量为1的边才是有效边，而原边不会对流量产生干扰，如此将割点转换成割边的问题。<br><img src="/img/adsgerwqxc.jpg" alt="大概就像这样"><br>如图所示，在此时的图上跑最大流，红色边(原边)对答案起不到任何干扰，绿边(新创的边)才会制约答案。原理显然。<br>顶点容量流也和最小割点一样，使用拆点成边即可，不过此时新边为点的容量，原边容量不变</p><hr><h4 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h4><p>闭合图：对于一个有向图G，存在点集合V，任取点u属于V，u的出边的另一个点也属于V，则为闭合图。<br>就是在闭合图内任取一起点，途径的点和终点必定都属于该闭合图。<br>最大权闭合子图：当每个点有一个权值w（有正有负），点权和最大的闭合图为最大权闭合子图。<br><img src="/img/postpictures/aasdfsfervcxvz.png" alt="举个例子"><br>就像这张图片里的图，其中{1,2,3,4},{6,5,4},{7,4}为该图中的三个闭合图，而最大全闭合子图是{7,4}，权值为114514+1=114515.<br>这种题目也是通过最大流来解决，建立一个源点S和所有权值为正的点连边(源点→权值为正的点)，权值为该点的权值;再建立汇点E和所有权值为负的点连边(权值为负的点→汇点)，权值为该点的权值的绝对值。其他边的权值设为极大值。<br><img src="/img/postpictures/asddvreqgtgz.png" alt="就像这样"><br>然后在新图上跑最大流，最终最大权闭合子图的值就是<strong>所有点权为正的权值之和-新图上的最大流</strong><br>根据图片演示，应该很容易想到原理。<br>我们首先定义一个 <strong>“有效”的闭合子图</strong>为该图内所有点权之和大于0。由于闭合图的性质，我们可以得出所有有效的闭合子图就之和是我们所需的答案。<br>模拟一下网络流的过程，以一个节点开始必然会经过它之后的所有的节点，流向汇点E的部分就是<strong>所有有效的闭合子图的负权值之和</strong>。因为流向汇点的点均为负值节点。大于其边权的流量只能有该边权的流量通过;小于其边权的流量代表这个子图的总权值为负值，这个子图最终流向汇点的权值是其正值权值的总和，这部分权值不会计算在内，会在最后一步减去;而流向汇点的流量为0的边权则代表该点并不是有效的闭合子图的一部分。<br>因此得证 <strong>大权闭合子图的值 = 所有点权为正的权值之和 - 新图上的最大流</strong></p><hr><h3 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h3><p>给定一个网络，每条边除了有容量限制，还有一个单位流量的费用。<br>当一条边的的流量为$f_i$ 时，需要花费$f_i \times Cost_i$的费用。则该网络中总花费最小的最大流称为 最小费用最大流.</p><h4 id="SSP算法"><a href="#SSP算法" class="headerlink" title="SSP算法"></a>SSP算法</h4><p>SSP（Successive Shortest Path）是一个贪心的算法，每一次找到最短的可增广路进行增广，直到图上不存在增广路即可。<br>算法很简单，只要把EK或Dinic中的寻找增广路的部分换成SPFA即可，这里是<a href="https://linzeyin.github.io/2021/02/28/%E6%A8%A1%E6%9D%BF%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/#%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81-EK-SPFA">EK替换后的源码</a>。设网络最大流为f，呢么时间复杂度最坏情况为O(nmf)的</p><div class="note note-warning"><p>这并不是一个多项式时间复杂度，因为多项式时间复杂度要求算法花费的时间可以表示为一个关于输入数据规模$n$的多项式函数。而在SSP算法中，最大流$f$并不一定能表示为关于$n$的多项式函数。假如构造$m=n^2 , f=2^{n/2}$的网络，该情况下 SSP 算法的时间复杂度将达到指数时间复杂度。</p></div><h4 id="Primal-Dual-原始对偶算法"><a href="#Primal-Dual-原始对偶算法" class="headerlink" title="Primal-Dual 原始对偶算法"></a>Primal-Dual 原始对偶算法</h4><p>学习了<a href="https://linzeyin.github.io/2021/03/21/DJ%20%E7%9A%84%E8%B4%9F%E6%9D%83%E5%9B%BE%E4%BC%98%E5%8C%96/">Johnson算法</a>后我们可以尝试使用DJ来代替SPFA进行最短路的查找。此时要解决的是势能设定问题，因为每跑一次费用流流量均会发生改变，相应的单位权值乘上流量变化量形成的权值增量也会改变。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>网络流</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>图论</tag>
      
      <tag>算法</tag>
      
      <tag>网络流</tag>
      
      <tag>最大流</tag>
      
      <tag>最小割</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用matlab进行三维函数的绘制</title>
    <link href="/2021/03/15/%E7%94%A8matlab%E8%BF%9B%E8%A1%8C%E4%B8%89%E7%BB%B4%E5%87%BD%E6%95%B0%E7%BB%98%E5%88%B6/"/>
    <url>/2021/03/15/%E7%94%A8matlab%E8%BF%9B%E8%A1%8C%E4%B8%89%E7%BB%B4%E5%87%BD%E6%95%B0%E7%BB%98%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在浏览高数课件，然后对于其中的三维函数想进行直观的了解，原本函数只有二维时经常使用Geogerbra，但是其对三维函数无能为力，便学习了下matlab如何绘制三维函数</p><pre><code>简单的示例：</code></pre><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas">[<span class="hljs-meta">x</span>,y]=meshgrid(-3:0.1:3);<br>z<span class="hljs-meta">=sin(</span><span class="hljs-meta">x</span>.<span class="hljs-comment">*y);</span><br>subplot(1,2,2);<br>mesh(<span class="hljs-meta">x</span>,y,z);<br><span class="hljs-meta">title</span>(<span class="hljs-string">&#x27;mesh&#x27;</span>);<br>subplot(1,2,1);<br>surf(<span class="hljs-meta">x</span>,y,z);<br><span class="hljs-meta">title</span>(<span class="hljs-string">&#x27;surf&#x27;</span>);<br></code></pre></td></tr></table></figure><p><del>(语段的开头假如有代码框的话好像不加什么东西的话会出现渲染错误，请自动忽略这句话)</del>。<code>meshgrid</code> 用来生成二维方格矩阵，作为第三维变量z的因变量。在这里我们设置了x和y的范围相同，也可以分开设置成不同的范围，这时格式应设置成 <code>[x,y]=meshgrid[t,s]</code> ，t和s分别是行矩阵和列矩阵，要求的格式为(左区间:精度值:右区间)，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><span class="hljs-attribute">x</span>=<span class="hljs-number">2</span>:<span class="hljs-number">1</span>:<span class="hljs-number">6</span>;<br><span class="hljs-attribute">y</span>=(<span class="hljs-number">3</span>:<span class="hljs-number">1</span>:<span class="hljs-number">8</span>)&#x27;;<br>[X,Y]=meshgrid(x,y);<br></code></pre></td></tr></table></figure><p>mesh函数和surf函数都是用来生成三维曲线的，具体差别可以自己实验得知。subplot是规划显示的区域<br>具体效果如图：<br><img src="/img/postpictures/sfbyjfg.jpg" alt=""></p><hr><h3 id="update"><a href="#update" class="headerlink" title="update:"></a>update:</h3><p>注意 精度值设置成0.1即可，设置更低可能会造成加载缓慢或颜色加载不出来等问题。这是0.01的情况：<br><img src="/img/postpictures/sdgerbsdad.jpg" alt=""><br>（设置成0.0001时matlab直接停止运行了，不知道是我电脑设置的问题还是什么其他问题</p><hr><h3 id="update-1"><a href="#update-1" class="headerlink" title="update:"></a>update:</h3><p>更新一下三维曲面的写法<br>fsurf用来绘制三维的曲面，可以直接按$z=f(x,y)$形式输入，就像这样：<br> <code>fsurf(@(x,y) ((1-sqrt(x)+sqrt(y))^2))</code><br><img src="/img/postpictures/asdfwexcvzqefg.png" alt="效果"></p><p>也可以将x,y,z分别使用参数来表示，然后按照 <code>fsurf(x,y,z,范围)</code>的格式来绘制，比如这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">r <span class="hljs-operator">=</span> @(u,v) <span class="hljs-number">2</span> <span class="hljs-operator">+</span> <span class="hljs-built_in">sin</span>(<span class="hljs-number">7.</span><span class="hljs-operator">*</span>u <span class="hljs-operator">+</span> <span class="hljs-number">5.</span><span class="hljs-operator">*</span>v);<br>funx <span class="hljs-operator">=</span> @(u,v) r(u,v).<span class="hljs-operator">*</span><span class="hljs-built_in">cos</span>(u).<span class="hljs-operator">*</span><span class="hljs-built_in">sin</span>(v);<br>funy <span class="hljs-operator">=</span> @(u,v) r(u,v).<span class="hljs-operator">*</span><span class="hljs-built_in">sin</span>(u).<span class="hljs-operator">*</span><span class="hljs-built_in">sin</span>(v);<br>funz <span class="hljs-operator">=</span> @(u,v) r(u,v).<span class="hljs-operator">*</span><span class="hljs-built_in">cos</span>(v);<br>fsurf(funx,funy,funz,[<span class="hljs-number">0</span> <span class="hljs-number">2</span><span class="hljs-operator">*</span>pi <span class="hljs-number">0</span> pi]) <br>camlight<br><span class="hljs-operator">%</span> camlight是打光，更加立体化<br></code></pre></td></tr></table></figure><p><img src="/img/postpictures/tbczx6SZ5VEEH8.png" alt=""></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>数学建模</tag>
      
      <tag>matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论题目 数学</title>
    <link href="/2021/03/14/%E6%95%B0%E8%AE%BA_%E6%95%B0%E5%AD%A6/"/>
    <url>/2021/03/14/%E6%95%B0%E8%AE%BA_%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="https://imglf1.lf127.net/img/ckt6UUlOLzQ0cXVwY1NKYjJNcXhNcTZ6TFJKVnY0Mm1NY01hOU4wczNtSHhUQlZzRDZXeG93PT0.jpg?=imageView&amp;thumbnail=500x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2" alt=""></p><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><p>两个整数$ N , M 。N,M&lt;=10^{15}$</p><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><p>输出一个整数，表示满足条件的数.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>5 6</p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>240 </p></blockquote><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>看起来根本不能做的题系列. . .<br>不过我们可以找规律嘛，打表输出20以内的所有(n,m)组合，就会发现所有满足要求的φ(k)的和其实等于n*m.<br>惊不惊喜，开不开心？<br>之后输出 $ n \times m \times \phi(n) \times \phi(m) $ 即可.</p><p>嗯没错，这道题已经完了.</p><p><del>（再一次启示我们打表很重要,恩,没错</del></p><p>正规证法：</p><p>（我当时苦于证明的blog中的一歩，含神看了看说：这么简单,你乘法分配律怎么学的啊 ？然后我再看了一遍，<em>*</em>，把除号当成取余了QAQ</p><p>我们首先设$ n \% k = r_1,m \% k = r_2; $<br>$ n + m = ( n / k+m/k)*k+r_1+r_2; $ </p><p>呢么$(n+m)/k=n/k+m/k+(r_1+r_2)/k=n/k+m/k+1;$</p><p>所以$(n+m)/k-n/k-m/k=1;$</p><p>接下来就可以证：<br><img src="/img/img_ckt6UUlOLzQ0cXVwY1NKYjJNcXhNZ0o5MTZFUWZYY3IyeVVjY3oycmNYVk5aS2NNN2c5eE9RPT0.png" alt=""></p><p><img src="/img/img_ckt6UUlOLzQ0cXVwY1NKYjJNcXhNa1FXekNIOTNzcmVHYmliak5WSit4UC9mTkdUdXVXOFdnPT0.png" alt=""></p><p><del>(这公式真的打不出来QwQ)</del><br>所以$ sum = n <em> m </em> \phi(n)* \phi(m)$了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m=<span class="hljs-built_in">sqrt</span>((<span class="hljs-keyword">double</span>)x);<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k=x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">2</span>;i&lt;=m;i++)<br>&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<br>&#123;<br>            k=k/i*(i<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)<br>x/=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>)<br>k=k/x*(x<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-built_in">cout</span>&lt;&lt;(((n%<span class="hljs-number">998244353</span>)*(m%<span class="hljs-number">998244353</span>)%<span class="hljs-number">998244353</span>)*((phi(n)%<span class="hljs-number">998244353</span>)*(phi(m)%<span class="hljs-number">998244353</span>)%<span class="hljs-number">998244353</span>))%<span class="hljs-number">998244353</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//注意必须每次乘都膜，wa了好几次QAQ</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>高中</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论题目 Longge的问题</title>
    <link href="/2021/03/12/%E6%95%B0%E8%AE%BA_Longge%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/12/%E6%95%B0%E8%AE%BA_Longge%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定整数N，求$ \sum_{ i = 1 } ^ n gcd(i,n)$。</p></blockquote><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><p>一个整数$N。N&lt;=2 ^ {32} $</p><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><p>输出一个整数，表示满足条件的数对数量.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>6</p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>15</p></blockquote><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>由题意可知，输入一个n，输出1~n所有数与n的最大公约数的个数和。<br>乍一看很难，实际上并不是，设k=gcd(i,n)，则 $ \frac {i}{k} $ 与 $ \frac {n}{k} $互质，<br>我们可以通过枚举k来得到所有与n的最大公约数为k的数<br>——也就是除以k之后与 $ \frac {n}{k} $ 互质，也就是说$ \frac {n}{k}$的欧拉函数值即为与n最大公约数为k的数的数目。</p><p>之后用sum来累加$ k * \phi ( \frac {n}{k} ) $就是答案。</p><p>PS：如果首先预处理的话，则会爆空间，所以说只能找到一个k再找$ \frac{n}{k} $的欧拉函数值（蜜汁不超时）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> m=<span class="hljs-built_in">sqrt</span>((<span class="hljs-keyword">double</span>)x);<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> k=x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> i=<span class="hljs-number">2</span>;i&lt;=m;i++)<br>&#123;<br>        <span class="hljs-keyword">if</span>(x%i==<span class="hljs-number">0</span>)<br>&#123;<br>            k=k/i*(i<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">while</span>(x%i==<span class="hljs-number">0</span>)x/=i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>)k=k/x*(x<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i*i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<br>&#123;<br>sum+=i*phi(n/i);<br><span class="hljs-keyword">if</span>(i*i&lt;n)<br>sum+=(n/i)*phi(i);<br><span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;n/i&lt;&lt;&#x27;:&#x27;&lt;&lt;phi[i]&lt;&lt;&#x27; &#x27;&lt;&lt;phi[n/i]&lt;&lt;&quot;    &quot;&lt;&lt;sum&lt;&lt;endl;</span><br>&#125;<br>&#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>高中</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论题目 GCD</title>
    <link href="/2021/03/12/%E6%95%B0%E8%AE%BA_GCD/"/>
    <url>/2021/03/12/%E6%95%B0%E8%AE%BA_GCD/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定整数N，求1&lt;=x,y&lt;=N且Gcd(x,y)为素数的数对(x,y)有多少对.</p></blockquote><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><p>一个整数$N。N&lt;=10^7$</p><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><p>输出一个整数，表示满足条件的数对数量.</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>4</p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>4</p></blockquote><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>其实，根本用不到gcd，<br>由于gcd(x,y)为素数,设这个素数为p,所以 $ gcd( \frac{x}{p},\frac{y}{p})=1 $;也就是说每一个小于n的质数p，对于每两个互质的数，都会有一组解（x&lt;=n&amp;&amp;y&lt;=n）<br>先求出1~n的欧拉函数，之后再求出其前缀和 $ \phi [i] $ 为前n个数的欧拉函数和，表示在1~n中有多少互质数.<br>再把每一次的乘二再相加，就是要求的sum了</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> cnt=<span class="hljs-number">0</span>,prime[<span class="hljs-number">10000010</span>];  <br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> phi[<span class="hljs-number">10000010</span>];<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123; <br>phi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)  <br>    &#123; <br>        <span class="hljs-keyword">if</span>(!phi[i])<br>&#123;<br>prime[++cnt]=i;  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;=n;j+=i)  <br>&#123;<br><span class="hljs-keyword">if</span>(phi[j]==<span class="hljs-number">0</span>)<br>phi[j]=j;<br>phi[j]=phi[j]/i*(i<span class="hljs-number">-1</span>);<br>&#125;<br>        &#125;  <br>    &#125;  <br>&#125;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-comment">//int k=clock();</span><br><span class="hljs-comment">//for(int i=1;i&lt;=n;i++)</span><br><span class="hljs-comment">//phi[i]=i;</span><br><span class="hljs-built_in">get</span>();<br><span class="hljs-comment">//get2();</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) phi[i]+=phi[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)<br>sum+=phi[n/prime[i]]*<span class="hljs-number">2</span><span class="hljs-number">-1</span>;<br><span class="hljs-comment">//cout&lt;&lt;clock()-k&lt;&lt;endl;</span><br><span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>高中</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论总结</title>
    <link href="/2021/03/06/%E6%95%B0%E8%AE%BA/"/>
    <url>/2021/03/06/%E6%95%B0%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想着把所有内容都放在模板补全计划里势必会造成文章繁多难受，便新开一档<br>高中阶段曾经学习过一些，不过大多早已忘却，于今日开始补完<br>从基础的开始</p><h3 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h3><p>在遇到乘法两个数都很大的情况下，需要通过快速乘来保证在计算过程中间不会溢出<br>网上有多种快速乘方式，我在此仅提供一种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> z=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>)x/p*y;<br><span class="hljs-keyword">return</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)x*y-(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)z*mod+mod)%mod;<br>&#125;<br></code></pre></td></tr></table></figure><p>z就是 <script type="math/tex">\lfloor x \times y / mod \rfloor</script>,而我们要求的<script type="math/tex">x \times y \% mod</script> 实际上与<script type="math/tex">x \times y - \lfloor x \times y / mod \rfloor \times mod</script> 是等价的<br>而<code>unsigned long long</code> 保证了就算溢出，<script type="math/tex">x \times y</script> 和 <script type="math/tex">\lfloor x \times y / mod \rfloor \times mod</script>的差值还是不变，因此即使溢出最后的结果仍然不变。时间复杂度 O(1)</p><p><del>(latex好麻烦，大幅度降低写文效率. . .)</del></p><hr><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>很简单的原理，在此不做过多叙述<br>chty的一行快速幂：<br><code>long long fast(long long a,long long b)&#123;long long ans=1;for(;b;b&gt;&gt;=1,a=mul(a,a))if(b&amp;1)ans=mul(ans,a);return ans;&#125;</code><br>（syq学长好强啊</p><hr><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>这个也算是入门级别的<br><code>inline long long gcd(a,b)&#123;return !b?a:gcd(b,a%b);&#125;</code></p><hr><h3 id="拓展GCD"><a href="#拓展GCD" class="headerlink" title="拓展GCD"></a>拓展GCD</h3><blockquote><p>裴蜀定理：丢番图方程（二元一次，下同）$ a \times x + b \times y = m $有解当且仅当$ m | ( a , b )$</p></blockquote><p>扩展gcd就是在求丢番图方程$ a \times x + b \times y  =gcd(a,b) $的整数解<br>证明：<br>$    a \times x_1 + b \times y_1 = gcd(a,b) $<br>$    b \times x_2 + (a \% b) \times y_2 = gcd(b,a \% b)$<br>$    因为 gcd(a,b) = gcd(b,a \% b) $<br>$    得 a \times x_1 + b \times y_1 = b \times x_2 + ( a \% b ) \times y_2 = b \times x_2 + ( a - a / b \times b ) \times y_2 = a \times y_2 + b \times (x_2 - a / b \times y_2 ) $<br>$    所以x_1=y_2,y_1=x_2-a/b \times y_2$<br>$    末状态：b=0,a = gcd(a,b)时，gcd(a,b) \times x=gcd(a,b),得x = 1$<br>代码如下：<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sas">void exgcd(int a,int b,int <span class="hljs-variable">&amp;x</span>,int <span class="hljs-variable">&amp;y</span>)<br>&#123;<br>    <span class="hljs-meta">if</span>(b==0)  &#123;<span class="hljs-meta">x</span>=1; y=0; <span class="hljs-meta">return</span>;&#125;<br>    exgcd(b,a<span class="hljs-name">%b</span>,<span class="hljs-meta">x</span>,y);<br>    int t=<span class="hljs-meta">x</span>;<span class="hljs-meta">x</span>=y;y=t-a/b<span class="hljs-comment">*y;</span><br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><blockquote><p>对于一个正整数n，小于n且和n互质的正整数（包括1）的个数叫做欧拉函数，记作 $\phi(n)$ 。</p></blockquote><p>一个很简明的想法是在1~n中找到n的约数，然后减去约数在n之内的倍数即可。<br>例：若n=12，呢么分解质因数则为$ 12 = 2 \times 2 \times 3 $<br>但是不能直接减12/2和12/3，因为会有6这个2，3的公倍数被减了两次<br>运用容斥的原理，我们可得一种简单的方法，令$ phi(n) = n \times \prod_{i=1}^k (1 - a_i)$(a是n因子的集合，k为a因子的个数)<br>直接分解质因数的复杂度会达到$ O(\sqrt n)$,求单个数时可用，但求n个数的欧拉函数时说不可用的<br>在求n个数的欧拉函数时，我们可以利用类似筛法的方式求得<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">long long <span class="hljs-built_in">phi</span>[Maxn+<span class="hljs-number">10</span>];<br>void Euler()<br>&#123;<br>    <span class="hljs-built_in">phi</span>[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-built_in">n</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">if</span>(!<span class="hljs-built_in">phi</span>[i])<br>        &#123;<br>            for(<span class="hljs-built_in">int</span> j=i;j&lt;<span class="hljs-built_in">n</span>;j+=i)<br>            &#123;<br>                <span class="hljs-built_in">if</span>(!<span class="hljs-built_in">phi</span>[j]) <span class="hljs-built_in">phi</span>[j]=j;<br>                <span class="hljs-built_in">phi</span>[j]=<span class="hljs-built_in">phi</span>[j]/i*(i-<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>一些性质：</p><blockquote><p>欧拉函数是积性函数——若m,n互质，$ \phi(mn) = \phi(m) \times \phi(n) $<br>p为质数 $ \phi(p) = p-1 $   因为质数p除了1以外的因数只有p<br>如果 $ i \% p = 0 $, 那么 $ \phi(i \times p) = \phi(i) \times p $<br>若 $ i \% p ≠ 0 $,  那么$ \phi( i \times p ) = \phi(i) \times ( p - 1 ) $<br>如果n是素数，k是正整数，那么 $ \phi( n ^ k ) = (n-1) \times n^{k-1} $</p></blockquote><p>由这些性质，我们可以将复杂度进一步优化到$ O(n) $递推</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs inform7">long long phi<span class="hljs-comment">[MaxN+10]</span>, prime<span class="hljs-comment">[MaxN+10]</span>;<br>void Euler()<br>&#123;<br>    phi<span class="hljs-comment">[1]</span>=1;<br>    for(int i=2;i&lt;N;++)<br>    &#123;<br>        if(!phi<span class="hljs-comment">[i]</span>)//第二条性质<br>        &#123;<br>            phi<span class="hljs-comment">[i]</span>=i-1;<br>            prime<span class="hljs-comment">[prime<span class="hljs-comment">[0]</span>++]</span>=i;<br>        &#125;<br>        for(int j=0;j&lt;prime<span class="hljs-comment">[0]</span>&amp;&amp;1ll*i*prime<span class="hljs-comment">[j]</span>&lt;N;j++)<br>        &#123;<br>            if(i%prime<span class="hljs-comment">[j]</span>)phi<span class="hljs-comment">[i*prime<span class="hljs-comment">[j]</span>]</span>=phi<span class="hljs-comment">[i]</span>*(prime<span class="hljs-comment">[j]</span>-1);//第三条性质<br>            else<br>            &#123;<br>                phi<span class="hljs-comment">[i*prime<span class="hljs-comment">[j]</span>]</span>=phi<span class="hljs-comment">[i]</span>*prime<span class="hljs-comment">[j]</span>;<br>                break;//优化成线性复杂度<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><blockquote><p>对于正整数a和m，如果$ a \times x \% m=1 $, 则x的最小正整数解称为a模m的逆元，表示为$ a ^{-1} (mod m)$</p></blockquote><p>（1）根据费马小定理：有$ a^{m-1} \% m = 1 $,  即$ a \times a^{m-2} \% m = 1 $, 所以$ a ^{m-2} $就是a模m的逆元。 （适用条件：m为素数）<br>（2）扩展欧几里得求解：$ a \times x \% m = 1 $,即$ a \times x - m \times y = 1 $,解这个丢番图方程即可。(适用条件：gcd(a,m)=1)<br>（3）欧拉定理：若 $ gcd(a,m) = 1 $，则 $ a^{ \phi(m)} ≡ 1 (mod m) $<br>$ a^{-1}=a^{\phi(m)-1}$，使用欧拉函数+快速幂计算，复杂度同费马，但较费马而言，模数m可以不为质数，因此应用范围广一点<br>（4）线性递推：<br>规定m为质数，且$ 1^{-1} ≡ 1(mod m) $    设 $ m = k \times a + b (b &lt; a , 1 &lt; a &lt; m ) $,即$ k \times a + b ≡ 0(mod m) $<br>两边同时乘以$ a^{−1} \times b^{−1} $，得到 $ k \times b^{−1} + a^{−1} ≡ 0 (mod m) $<br>$ a^{-1} ≡ − k \times b^{−1}     (mod m) $<br>$ a^{−1} ≡ − m / a \times ( m \% a )^{-1}      (mod m) $<br>从头开始扫一遍即可，时间复杂度O(n)         （适用条件：m为素数）<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q"><span class="hljs-built_in">inv</span>[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>for(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++) <span class="hljs-built_in">inv</span>[i]=(<span class="hljs-built_in">mod</span>-(<span class="hljs-built_in">mod</span>/i))*<span class="hljs-built_in">inv</span>[<span class="hljs-built_in">mod</span>%i]%<span class="hljs-built_in">mod</span>;<br></code></pre></td></tr></table></figure></p><hr><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p> 假设整数 $ m_1,m_2,m_3…$ 两两互素，则对于任意的整数 $ a_1,a_2,a_3…$ ，方程组</p><script type="math/tex; mode=display">\begin{cases}    & x \equiv a_1 (mod m_1)  \\\\    & x \equiv a_2 (mod m_2)  \\\\    & x \equiv a_3 (mod m_3)  \\\\    & . . .  \\\\    \end{cases}</script><p>都存在整数解.<br>若多个数 <script type="math/tex">x_1,x_2...</script>满足该方程，则必有 <script type="math/tex">x_i \equiv x_j (mod M)</script>，其中 <script type="math/tex">M = \prod_{i=1}^n m_i</script><br>因此x在MOD M下有唯一解。<br>解为：<script type="math/tex">x\equiv (a_1 M_1 M_1^{-1} + a_2 M_2 M_2^{-1} +...+a_n M_n M_n^{-1}) (mod M)</script><br>其中 <script type="math/tex">M_i = M / m_i , M_i^{-1}</script>为 <script type="math/tex">M_i</script> 膜 <script type="math/tex">m_i</script>的逆元。</p><hr><h3 id="lucas定理-快速求组合数"><a href="#lucas定理-快速求组合数" class="headerlink" title="lucas定理 快速求组合数"></a>lucas定理 快速求组合数</h3><p>适用于求解组合数取模问题，n较为大不能用阶乘计算且要求mod较小</p><script type="math/tex; mode=display">C_n^m \% mod = (C_{\frac{n}{mod}}^{\frac{m}{mod}}*C_{n\%mod}^{m\%mod})\%mod</script><p>lucas复杂度<script type="math/tex">O(log_{p}(n)*p)</script><br>具体证明<a href="https://www.luogu.com.cn/problem/solution/P3807">见此</a>，不过直接用就好了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> N = <span class="hljs-number">1e6</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,m,p,A[N+<span class="hljs-number">5</span>],B[N+<span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> (m&gt;n)?<span class="hljs-number">0</span>:((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)A[n]*B[n-m]%p*B[m]%p);&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Lucas</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m,<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> p)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-keyword">return</span> (!m)?<span class="hljs-number">1</span>:((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p);&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);<br>    A[<span class="hljs-number">0</span>]=B[<span class="hljs-number">0</span>]=A[<span class="hljs-number">1</span>]=B[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=p;i++)B[i]=-(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)(p/i)*B[p%i]%p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=p;i++)A[i]=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)A[i<span class="hljs-number">-1</span>]*i%p,B[i]=(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)B[i<span class="hljs-number">-1</span>]*B[i]%p;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (Lucas(n, m, p)+p)%p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h3 id="Meisell-Lehmer算法-计算大范围素数个数"><a href="#Meisell-Lehmer算法-计算大范围素数个数" class="headerlink" title="Meisell-Lehmer算法 计算大范围素数个数"></a>Meisell-Lehmer算法 计算大范围素数个数</h3><p>Meisell-Lehmer算法是计算超大范围内素数个数的一种算法，原理中文网上资料甚少. . .导致只有代码.附有<a href="https://en.wikipedia.org/wiki/Meissel%E2%80%93Lehmer_algorithm">wiki链接</a>，能看懂的老兄可以去试着看看，需要用不存在的工具查看。<br>测试计算极限为<script type="math/tex">10^{11}</script></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 100    <span class="hljs-comment">// pre-calc max n for phi(m, n)</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXM 10010 <span class="hljs-comment">// pre-calc max m for phi(m, n)</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXP 40000 <span class="hljs-comment">// max primes counter</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 400010    <span class="hljs-comment">// max prime</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> setbit(ar,i) (((ar[(i) &gt;&gt; 6]) |= (1 <span class="hljs-meta-string">&lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> chkbit(ar,i) (((ar[(i) &gt;&gt; 6]) &amp; (1 <span class="hljs-meta-string">&lt;&lt; (((i) &gt;&gt; 1) &amp; 31))))</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isprime(x) (((x)&amp;&amp;((x)&amp;1)&amp;&amp;(!chkbit(ar,(x))))||((x) == 2))</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dp[MAXN][MAXM];<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ar[(MAX&gt;&gt;<span class="hljs-number">6</span>)+<span class="hljs-number">5</span>]=&#123;&#125;;<br><span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>,primes[MAXP],counter[MAX];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Sieve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    setbit(ar,<span class="hljs-number">0</span>),setbit(ar,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;(i*i)&lt;MAX;i++,i++)<br>        <span class="hljs-keyword">if</span> (!chkbit(ar,i))<br>        &#123;<br>            <span class="hljs-keyword">int</span> k=i&lt;&lt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=(i*i);j&lt;MAX;j+= k) setbit(ar, j);<br>        &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;MAX;i++)<br>    &#123;<br>        counter[i]=counter[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(isprime(i))primes[len++]=i,counter[i]++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Sieve();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;MAXM;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (!i) dp[i][j]=j;<br>            <span class="hljs-keyword">else</span> dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]-dp[i<span class="hljs-number">-1</span>][j/primes[i<span class="hljs-number">-1</span>]];<br>        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;<br>    <span class="hljs-keyword">if</span>(primes[n<span class="hljs-number">-1</span>]&gt;=m)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(m&lt;MAXM&amp;&amp;n&lt;MAXN)<span class="hljs-keyword">return</span> dp[n][m];<br>    <span class="hljs-keyword">return</span> phi(m,n<span class="hljs-number">-1</span>)-phi(m/primes[n<span class="hljs-number">-1</span>],n<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Lehmer</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(m&lt;MAX)<span class="hljs-keyword">return</span> counter[m];<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> w,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> a,s,c,x,y;<br>    s=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">0.9</span> + m),y=c=cbrt(<span class="hljs-number">0.9</span>+m);<br>    a=counter[y],sum =phi(m,a)+a<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=a;primes[i]&lt;=s;i++) sum=sum-Lehmer(m/primes[i])+Lehmer(primes[i])<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    init();<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n)!=EOF)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,Lehmer(n));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客创建历程(记录向)</title>
    <link href="/2021/03/05/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%8E%86%E7%A8%8B(%E8%AE%B0%E5%BD%95%E5%90%91)/"/>
    <url>/2021/03/05/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%8E%86%E7%A8%8B(%E8%AE%B0%E5%BD%95%E5%90%91)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="萌新时期"><a href="#萌新时期" class="headerlink" title="萌新时期"></a>萌新时期</h2><p>实际上百度一下就有很多的资源，以前也看过xorex搭过，用的Hexo，关键词也很好得到，直接百度/知乎 hexo &amp;&amp; blog就行。<br>具体环境以及配置内容主要参考了<a href="https://godweiyang.com/2018/04/13/hexo-blog/">韦阳的博客</a>,不过由于原博年代过久导致出现了版本不适配的过程，<br>比如博文中提供的Node.js需要最新版的，建议<strong>资源类配置自行寻至最新版本保证相互兼容</strong>。<br>以及<strong>配置git时需将github号码一并配置</strong>，否则以后上传时每一次都需要输入账号密码(不过有机会补救，具体见后文)<br>配置基础完成后，选择了原博推荐的主题，但是内容繁多，主题下载到本地后需要修改的东西以及配置时出现的未定义的错误较多，费了一番功夫后放弃了。<br>之后又找到了<a href="https://www.cnblogs.com/xrblog/p/11585885.html">月如霜的博客</a>，完善了一些配置并解决了需要一直输入账号密码的问题，详见他的<a href="https://www.cnblogs.com/xrblog/p/11585902.html">第二篇博文</a>。<br>不过这篇博客之后推荐的vim编辑方式不是很推荐，可能是我个人对命令行编写的不熟悉，导致写的很辛苦。<br>个人是直接选择了编辑器里直接修改posts文件夹里的博文，因为vscode也有Markdown的语法插件，并且编辑器写起来也很舒服。<br>vscode的直接下载支持Markdown语法的插件就行，我使用的是 <img src="/img/3Q25.png" alt=""> 编辑好后直接<strong>Ctrl+Shift+v</strong>就可以预览。<br>然后选择了推荐的主题<a href="https://github.com/Ben02/hexo-theme-Anatole">Anatole主题</a>（在月如霜的第四篇博客。<br>这个主题十分精简，对于萌新来说十分友好，建议开始可以先使用简单的主题。</p><hr><h2 id="这里是我觉得开始进阶的时候"><a href="#这里是我觉得开始进阶的时候" class="headerlink" title="这里是我觉得开始进阶的时候"></a>这里是我觉得开始进阶的时候</h2><p>但是我在上传时出现了问题，友链页面本地运行可以打开，但是上传至Github上就是404<br>便学习了一些hexo _config.yml的相关配置，其中<a href="https://blog.csdn.net/zemprogram/article/details/104288872">这篇博文</a>以及下方推荐的hexo文件结构帮助了不少。学习后变依靠原有的主题结构修改了一些东西。<br><em>(不过还是没有把友链整出来，以及主题框架原本就很简单，自己的改动增添也改不了多少，便又更换了主题</em></p><p>目前使用的主题是<a href="https://hexo.fluid-dev.com/">fluid</a>，对于前端知识缺乏的人十分友好，因为格式很工整以及注释很详细(当然也有可能是在搭建blog过程中我个人对hexo的结构更加熟悉了而已)<br>具体的安装过程以及<strong>配置用法</strong>网站上很详细，在此不做叙述。<br>之后大概就是一些小功能的更新记录</p><hr><h3 id="点击特效"><a href="#点击特效" class="headerlink" title="点击特效"></a>点击特效</h3><p>百度到了简书上的<a href="https://www.jianshu.com/p/6fe2b80c56de">做法</a>，其中第一个小心心的特效可以正常运行，但是文字输出部分(原文是社会主义核心价值观)出现问题无法输出。<br>然后去解码别人搭好的blog，试出了合适本主题的文字输出，由于搜索博文过多无法找到原博贴出，便直接贴出代码<br><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/* 鼠标特效 */</span><br><span class="hljs-keyword">var</span> a_idx = <span class="hljs-number">0</span>; <br>jQuery(document).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123; <br>    $(<span class="hljs-string">&quot;body&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123; <br>        <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Array(<span class="hljs-string">&quot;你要输入的文字&quot;</span>, <span class="hljs-string">&quot;你要输入的文字&quot;</span>,<span class="hljs-string">&quot;你要输入的文字&quot;</span>,<span class="hljs-string">&quot;你要输入的文字&quot;</span>,<span class="hljs-string">&quot;你要输入的文字&quot;</span>); <br>        <span class="hljs-keyword">var</span> <span class="hljs-symbol">$i</span> = $(<span class="hljs-string">&quot;&lt;span/&gt;&quot;</span>).text(a[a_idx]); <br>        a_idx = (a_idx + <span class="hljs-number">1</span>) % a.length; <br>        <span class="hljs-keyword">var</span> x = e.pageX, <br>        y = e.pageY; <br>        <span class="hljs-symbol">$i</span>.css(&#123; <br>            <span class="hljs-string">&quot;z-index&quot;</span>: <span class="hljs-number">999999999999999999999999999999999999999999999999999999999999999999999</span>, <br>            <span class="hljs-string">&quot;top&quot;</span>: y - <span class="hljs-number">20</span>, <br>            <span class="hljs-string">&quot;left&quot;</span>: x, <br>            <span class="hljs-string">&quot;position&quot;</span>: <span class="hljs-string">&quot;absolute&quot;</span>, <br>            <span class="hljs-string">&quot;font-weight&quot;</span>: <span class="hljs-string">&quot;bold&quot;</span>, <br>            <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#ff6651&quot;</span> <br>        &#125;); <br>        $(<span class="hljs-string">&quot;body&quot;</span>).append(<span class="hljs-symbol">$i</span>); <br>        <span class="hljs-symbol">$i</span>.animate(&#123; <br>            <span class="hljs-string">&quot;top&quot;</span>: y - <span class="hljs-number">180</span>, <br>            <span class="hljs-string">&quot;opacity&quot;</span>: <span class="hljs-number">0</span> <br>        &#125;, <br>        <span class="hljs-number">1500</span>, <br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <br>            <span class="hljs-symbol">$i</span>.remove(); <br>        &#125;); <br>    &#125;); <br>&#125;); <br></code></pre></td></tr></table></figure><br>使用方法的话还是依照上面简书的教程，只不过将这个源码替换成简书提供的点击文字特效的源码即可。</p><hr><h3 id="添加音乐"><a href="#添加音乐" class="headerlink" title="添加音乐"></a>添加音乐</h3><p>hexo添加音乐搜索可得两种方案：</p><ul><li>在官方网站获取外链</li><li>自己生成外链，插入文章</li></ul><p>第一种办法可能会受到版权的限制有些无法生成外链，会比较不自由<br>用第二种方法的话，需要将播放器加入hexo，我用的是<a href="https://github.com/DIYgod/APlayer">APlayer</a><br>安装时直接在hexo根目录输入<code>npm install --save hexo-tag-aplayer</code>即可<br>安装好后可直接使用，具体使用方式为在需要添加音乐位置直接加入<code>&#123;% aplayer "歌曲名称" "作者" "音乐_url" "封面图片_url" "autoplay" %&#125;</code>即可<br>最终效果：<br><img src="/img/Mucis.png" alt=""></p><blockquote><p>我的<a href="https://linzeyin.github.io/2021/01/29/test/">test页面</a></p></blockquote><hr><h3 id="文章加密"><a href="#文章加密" class="headerlink" title="文章加密"></a>文章加密</h3><p>安装<strong>hexo-blog-encrypt</strong> 拓展<br><code>npm install --save hexo-blog-encrypt</code><br>使用方式直接在博文文件头处添加即可<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2021-01-29 16:17:00</span><br><span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><span class="hljs-attr">message:</span> <span class="hljs-string">测试加密，密码为123456，点击此处解密。</span><br><span class="hljs-comment">#输入处加密提示</span><br><span class="hljs-attr">abstract:</span> <span class="hljs-string">这是一个加密文档</span><br><span class="hljs-comment">#简介处加密提示，注意，加密后文章原本摘要会被覆盖</span><br><span class="hljs-attr">wrong_pass_message:</span> <span class="hljs-string">密码错误</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></p><hr><h3 id="添加B站视频"><a href="#添加B站视频" class="headerlink" title="添加B站视频`"></a>添加B站视频`</h3><p>先是下载了dplor拓展，然后发现无法获得直接的mp4地址(<em>据说大多数网站是将视频分成多端传输的，以前听Xorex说过抓包获得地址什么的但是自己一窍不通</em>)。便放弃了。<del>(不过意外发现了一个大佬博客，自卑++)</del><br>然后选择简单方式，直接从B站获得分享直链然后加入即可，但是这种方式在我这里出现了播放窗口大小异常的问题，百度之后解决。<br>需要在自己主题的head文件里加入<br><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://api.beixibaobao.com/css/bilibili-player/bofangqi.css&quot;&gt;</code><br>然后再将从B站获得的分享码的<code>iframe</code> 后面加上：<code>class=&quot;iframe_video&quot;</code>即可</p><p>效果：</p><blockquote><p>我的<a href="https://linzeyin.github.io/2021/01/29/test/">test页面</a><br>原博：<a href="https://blog.beixibaobao.com/wailian-bilibili-videoplay/">北熙赤ちゃん</a></p></blockquote><hr><h3 id="更改鼠标样式"><a href="#更改鼠标样式" class="headerlink" title="更改鼠标样式"></a>更改鼠标样式</h3><p>首先是得下载你所需的cur文件(鼠标文件格式)，百度即可。然后将鼠标文件放入你主题的source中新创建的cur文件夹中。<br>在css文件夹中找到main.styl,加入以下代码<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*鼠标样式*/</span><br><span class="hljs-selector-tag">body</span><br>&#123;<br>  <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/cur/mouse.cur</span>),<br>    auto <span class="hljs-meta">!important</span>;<br>&#125;<br> <br><span class="hljs-comment">/* a, */</span><br><span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/cur/butt.cur</span>),<br>    auto <span class="hljs-meta">!important</span>;<br>&#125;<br> <br><span class="hljs-comment">/*a标签*/</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/cur/link.cur</span>),<br>    auto;<br>&#125;<br> <br><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:hover</span>&#123;<br>  <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/cur/input.cur</span>),<br>    auto;<br>&#125;<br><span class="hljs-comment">/*按钮*/</span><br><span class="hljs-selector-tag">button</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/cur/butt.cur</span>),<br>    auto;<br>&#125;<br> <br><span class="hljs-comment">/*i标签*/</span><br><span class="hljs-selector-tag">i</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">cursor</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/cur/link.cur</span>),<br>    auto;<br>&#125;<br><br><span class="hljs-comment">/*鼠标样式END*/</span><br></code></pre></td></tr></table></figure><br>根据个人的cur文件名自由更改即可。</p><hr><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><blockquote><p>部分浏览器以及服务器并不支持ani鼠标样式，推荐使用cur</p></blockquote><p>更新版本后ani动态鼠标样式无法实现，便将ani转成了cur<br>具体做法是下载 <a href="http://www.pc0359.cn/downinfo/64516.html">cursorworkshop</a> (选择普通下载就莫得莫得捆绑)</p><p>进入软件文件夹后，点开<strong>CursorWorkshop_Cracked.exe</strong>，我试的这个不需要注册码，把公司随便一填就可以使用。<br>（或者你也可以根据它的使用说明，不过不敢保证是否会顺便安装些什么其他东西</p><p>点开ani文件会有逐帧的图片显示，复制一个想要转为cur的帧，然后新建，在新建的里面粘贴即可。<br>实际上可做的操作还有很多，你也可以通过这个软件改变原样式的大小(我目前使用的就是将32<em>32的样式转成了48</em>48样式)，也可以自己绘制鼠标样式。</p><hr><h3 id="背景加入彩带"><a href="#背景加入彩带" class="headerlink" title="背景加入彩带"></a>背景加入彩带</h3><p>先在js文件夹里新建文件<code>ribbon.js</code>，之后写入<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Copyright (c) 2016 hustcc</span><br><span class="hljs-comment"> * License: MIT</span><br><span class="hljs-comment"> * Version: v1.0.1</span><br><span class="hljs-comment"> * GitHub: https://github.com/hustcc/ribbon.js</span><br><span class="hljs-comment">**/</span><br><span class="hljs-comment">/*jshint -W030 */</span><br>! function() &#123;<br>  function attr(node, attr, default_value) &#123;<br>    <span class="hljs-keyword">return</span> Number(node.getAttribute(attr)) || default_value;<br>  &#125;<br><br>  <span class="hljs-comment">// get user config</span><br>  var scripts = document.getElementsByTagName(<span class="hljs-string">&#x27;script&#x27;</span>),<br>    script = scripts[scripts.length - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 当前加载的script</span><br>  config = &#123;<br>    z: attr(script, <span class="hljs-string">&quot;zIndex&quot;</span>, <span class="hljs-number">-1</span>), <span class="hljs-comment">// z-index</span><br>    a: attr(script, <span class="hljs-string">&quot;alpha&quot;</span>, <span class="hljs-number">0.6</span>), <span class="hljs-comment">// alpha</span><br>    s: attr(script, <span class="hljs-string">&quot;size&quot;</span>, <span class="hljs-number">90</span>), <span class="hljs-comment">// size</span><br>  &#125;;<br><br>  var canvas = document.createElement(<span class="hljs-string">&#x27;canvas&#x27;</span>),<br>    g2d = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>),<br>    pr = window.devicePixelRatio || <span class="hljs-number">1</span>,<br>    <span class="hljs-built_in">width</span> = window.innerWidth,<br>    <span class="hljs-built_in">height</span> = window.innerHeight,<br>    f = config.s,<br>    q, t,<br>    m = Math,<br>    r = <span class="hljs-number">0</span>,<br>    pi = m.<span class="hljs-literal">PI</span>*<span class="hljs-number">2</span>,<br>    <span class="hljs-built_in">cos</span> = m.<span class="hljs-built_in">cos</span>,<br>    <span class="hljs-built_in">random</span> = m.<span class="hljs-built_in">random</span>;<br>  canvas.<span class="hljs-built_in">width</span> = <span class="hljs-built_in">width</span> * pr;<br>  canvas.<span class="hljs-built_in">height</span> = <span class="hljs-built_in">height</span> * pr;<br>  g2d.<span class="hljs-built_in">scale</span>(pr, pr);<br>  g2d.globalAlpha = config.a;<br>  canvas.style.cssText = <span class="hljs-string">&#x27;opacity: &#x27;</span> + config.a + <span class="hljs-string">&#x27;;position:fixed;top:0;left:0;z-index: &#x27;</span> + config.z + <span class="hljs-string">&#x27;;width:100%;height:100%;pointer-events:none;&#x27;</span>;<br>  <span class="hljs-comment">// create canvas</span><br>  document.getElementsByTagName(<span class="hljs-string">&#x27;body&#x27;</span>)[<span class="hljs-number">0</span>].appendChild(canvas);<br><br>  function <span class="hljs-built_in">redraw</span>() &#123;<br>    g2d.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">width</span>, <span class="hljs-built_in">height</span>);<br>    q = [&#123;x: <span class="hljs-number">0</span>, y: <span class="hljs-built_in">height</span> * <span class="hljs-number">0.7</span> + f&#125;, &#123;x: <span class="hljs-number">0</span>, y: <span class="hljs-built_in">height</span> * <span class="hljs-number">0.7</span> - f&#125;];<br>    <span class="hljs-keyword">while</span>(q[<span class="hljs-number">1</span>].x &lt; <span class="hljs-built_in">width</span> + f) <span class="hljs-title">draw</span>(q[<span class="hljs-number">0</span>], q[<span class="hljs-number">1</span>]);<br>  &#125;<br>  function <span class="hljs-title">draw</span>(i, j) &#123;<br>    g2d.beginPath();<br>    g2d.moveTo(i.x, i.y);<br>    g2d.lineTo(j.x, j.y);<br>    var k = j.x + (<span class="hljs-built_in">random</span>()*<span class="hljs-number">2</span><span class="hljs-number">-0.25</span>)*f, n = <span class="hljs-built_in">line</span>(j.y);<br>    g2d.lineTo(k, n);<br>    g2d.closePath();<br>    r -= pi / <span class="hljs-number">-50</span>;<br>    g2d.fillStyle = <span class="hljs-string">&#x27;#&#x27;</span>+(<span class="hljs-built_in">cos</span>(r)*<span class="hljs-number">127</span>+<span class="hljs-number">128</span>&lt;&lt;<span class="hljs-number">16</span> | <span class="hljs-built_in">cos</span>(r+pi/<span class="hljs-number">3</span>)*<span class="hljs-number">127</span>+<span class="hljs-number">128</span>&lt;&lt;<span class="hljs-number">8</span> | <span class="hljs-built_in">cos</span>(r+pi/<span class="hljs-number">3</span>*<span class="hljs-number">2</span>)*<span class="hljs-number">127</span>+<span class="hljs-number">128</span>).toString(<span class="hljs-number">16</span>);<br>    g2d.<span class="hljs-built_in">fill</span>();<br>    q[<span class="hljs-number">0</span>] = q[<span class="hljs-number">1</span>];<br>    q[<span class="hljs-number">1</span>] = &#123;x: k, y: n&#125;;<br>  &#125;<br>  function <span class="hljs-built_in">line</span>(p)&#123;<br>    t = p + (<span class="hljs-built_in">random</span>() * <span class="hljs-number">2</span> - <span class="hljs-number">1.1</span>) * f;<br>    <span class="hljs-keyword">return</span> (t &gt; <span class="hljs-built_in">height</span> || t &lt; <span class="hljs-number">0</span>) ? <span class="hljs-built_in">line</span>(p) : t;<br>  &#125;<br><br>  document.onclick = <span class="hljs-built_in">redraw</span>;<br>  document.ontouchstart = <span class="hljs-built_in">redraw</span>;<br>  <span class="hljs-built_in">redraw</span>();<br>&#125;();<br></code></pre></td></tr></table></figure><br><strong>然后在<code>layout.ejs</code>的<code>&lt;body&gt;</code>里加入</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;% if (theme.ribbon)&#123; %&gt;<br>    <span class="hljs-comment">&lt;!-- &lt;script src=&quot;https://g.joyinshare.com/hc/ribbon.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/js/ribbon.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>&lt;% &#125; %&gt;<br><br></code></pre></td></tr></table></figure></p><blockquote><p>看到的第一个bolg说是要在body外. . .搞的我还以为哪儿配错了</p></blockquote><p>最后在config中加上<code>ribbon: true</code>即可</p><hr><h3 id="Update-2021-03-06-补全ssh链接"><a href="#Update-2021-03-06-补全ssh链接" class="headerlink" title="Update 2021/03/06 补全ssh链接"></a>Update 2021/03/06 补全ssh链接</h3><p>出现了奇怪的bug，hexo-d又开始需要输入账号密码了<br>然后去找解决方案，东西扒凑终于知道为什么了。<br>我第一次设置的是用ssh密钥链接传github的，但是由于当时的网络状况问题并未成功链接，我当时以为是博客问题，便有换了篇博客重新搭，这篇博客用的是自引用账号密码的，是用https路径上传，可是我当时不知道（博主也不知道，他也是找的其他人的方法。成功了之后就一直以为自己是在用ssh连接上传。<br>今日按着步骤重新搭了一次ssh的配置，写一次update来检测是否配置成功。</p><hr><h3 id="Update-2021-03-10-数学公式渲染问题"><a href="#Update-2021-03-10-数学公式渲染问题" class="headerlink" title="Update 2021/03/10 数学公式渲染问题"></a>Update 2021/03/10 数学公式渲染问题</h3><p>在完善数论专题，学习了Latex并加入至了blog中<br>但是出现了无法换行的问题，确认公式无误后发现是blog问题。<br><img src="/img/efw.png" alt="问题如图"><br>原本用的是mathjar渲染公式。但是百度后发现是使用的mathjar版本低无法渲染换行符<code>\\</code>，应该换用Katex渲染。<br>由于目前用数位板和触控屏很难控制<br>目前先咕一段时间。等新鼠标来了再改 <del>(懒癌)</del><br>记一下<a href="https://blog.csdn.net/qq_34769162/article/details/107687801">链接</a></p><h4 id="Update-2021-03-29"><a href="#Update-2021-03-29" class="headerlink" title="Update 2021/03/29"></a>Update 2021/03/29</h4><p>更了更了<br>把mathjar改成了katex，<br>不用之前博文的呢么麻烦，输入指令直接下载就行<br><code>npm install @upupming/hexo-renderer-markdown-it-plus --save</code><br>然后<code>hexo clean</code>就行<br>测试了下还是有部分公式渲染不出来. . .<br>怪</p><h3 id="2022-02-12-博客新创页面"><a href="#2022-02-12-博客新创页面" class="headerlink" title="2022/02/12 博客新创页面"></a>2022/02/12 博客新创页面</h3><p>发现了一个很棒的<a href="https://sharkle.com/">前端网站</a>搬了一个变换的照片区域到blog上，由于html经过主题渲染会出问题，于是需要在hexo设置里关掉对呢个文件夹的渲染。<br>也就是<a href="https://blog.csdn.net/weixin_34367257/article/details/89009088">这篇blog</a>里介绍的方式，很简单。</p><h3 id="2023-3-24-博客报错问题"><a href="#2023-3-24-博客报错问题" class="headerlink" title="2023/3/24 博客报错问题"></a>2023/3/24 博客报错问题</h3><p>忽然上传不上了，他给我显示的错误代码为：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights<br>and the repository exists.<br>FATAL &#123;<br>  <span class="hljs-attribute">err</span>: Error: Spawn failed<br>      at ChildProcess.&lt;anonymous&gt; (E:\web blog\node_modules\hexo-util\lib\spawn<span class="hljs-variable">.js</span>:51:21)<br>      at ChildProcess<span class="hljs-variable">.emit</span> (events<span class="hljs-variable">.js</span>:315:20)<br>      at ChildProcess<span class="hljs-variable">.cp</span><span class="hljs-variable">.emit</span> (E:\web blog\node_modules\cross-spawn\lib\enoent<span class="hljs-variable">.js</span>:34:29)<br>      at Process<span class="hljs-variable">.ChildProcess</span><span class="hljs-variable">._handle</span><span class="hljs-variable">.onexit</span> (internal/child_process<span class="hljs-variable">.js</span>:275:12) &#123;<br>    code: 128<br>  &#125;<br>&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo<span class="hljs-variable">.io</span>/docs/troubleshooting<span class="hljs-variable">.html</span><br></code></pre></td></tr></table></figure><br>先搜的Spawn failed报错，按照<a href="https://blog.csdn.net/HTL2018/article/details/106876940">这个</a>博客的说法整了一波，但是还是布行，上传不上去。<br>然后搜的<code>fatal: Could not read from remote repository.Please make sure you have the correct access rights</code>发现可能是ssh需要重新配置。<br>过程报错参考：<br>报错1：<a href="https://blog.csdn.net/qq_43391414/article/details/121179955">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY。Someone could be eavesdropping on you</a></p><p>报错2：<a href="https://blog.csdn.net/argleary/article/details/100638560">Could not open a connection to your authentication agent</a><br>最终报错解决，上传成功。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>互联网</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些细碎的知识点补充</title>
    <link href="/2021/03/01/%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/"/>
    <url>/2021/03/01/%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><blockquote><p>直观用途：o(n)找出数组中每个数右边第一个比它大的元素</p></blockquote><pre><code>题目：给定一个整型数组，数组元素随机无序的，要求打印出所有元素右边第一个大于该元素的值。如数组A=[1,5,3,6,4,8,9,10] 输出[5, 6, 6, 8, 8, 9, 10, -1]如数组A=[8, 2, 5, 4, 3, 9, 7, 2, 5] 输出[9, 5, 9, 9, 9, -1, -1, 5, -1]</code></pre><p>对于类似的这种问题,即可用单调栈来优化.<br> <strong>其实只用到了栈结构，即先进后出。</strong><br>遍历原数组，当遍历过i后将i加入栈。若i+1的值大于栈顶呢么一直出栈即可，直到遇到栈顶大于i+1的值，此时栈顶就是该点一侧的第一个大于该元素的值。<br>每个元素都会进栈一次最多出栈一次，故复杂度为O(2n)即O(n)算法。<br>证明显然，出栈的元素比小于当前点，呢么对之后点就无法起到贡献(因为当前点比出栈的元素大且靠近之后的点)，因此出栈点对后续操作没有影响<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">void Work()<br>&#123;<br>    <span class="hljs-built_in">int</span> Stack[Maxn]=&#123;&#125;,<span class="hljs-built_in">now</span>=<span class="hljs-number">0</span>;//数组实现栈，<span class="hljs-built_in">now</span>是栈顶，入栈前自增，出栈--。<br>    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">n</span>;i++)<br>    &#123;<br>        while(Stack[<span class="hljs-built_in">now</span>]&lt;a[i])<span class="hljs-built_in">now</span>--;<br>        ans[i]=Stack[<span class="hljs-built_in">now</span>];<br>        Stack[++<span class="hljs-built_in">now</span>]=a[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><blockquote><p>单调队列主要用于解决在长度为n的序列中，求每个长度为m的区间的区间最值。</p></blockquote><p>基本思想是，维护一个所有元素都在目前区间的单调递减双向队列，遍历序列时仅当一个元素可能成为某个区间最值时才保留它，队列里面储存的数是原数组的下标<br>以求区间最大为例<br>当遍历到第n个数时，将其与队首元素比较大小，若大于队首元素，则将队首元素出队，直到小于队首元素，然后进队，之后队尾元素在m区间以外的元素出队，此时区间最大为目前的队尾。<br>每个元素都最多进一次队出一次队，故复杂度为O(n);<br>代码大概是这样</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int n,a<span class="hljs-comment">[50]</span>,ans<span class="hljs-comment">[maxn]</span>;<br>int work()<br>&#123;<br>    int Queue<span class="hljs-comment">[maxn]</span>,ll=0,rr=1;<br>    Queue<span class="hljs-comment">[++ll]</span>=1;<br>    for(int i=2;i&lt;=n;i++)<br>    &#123;<br>        while(a<span class="hljs-comment">[Queue<span class="hljs-comment">[rr]</span>]</span>&lt;a<span class="hljs-comment">[i]</span>)rr--;<br>        Queue<span class="hljs-comment">[++rr]</span>=i;<br>        while(Queue<span class="hljs-comment">[ll]</span>+m&lt;i)ll++;<br>        ans<span class="hljs-comment">[i]</span>=Queue<span class="hljs-comment">[ll]</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h3><blockquote><p>有n个人围成一个圈，每 q个人踢掉一个人，问最后留下来的人是几号？</p></blockquote><p>模拟的复杂度肯定是不合要求的，在此不做多说。<br>以下是 <strong>logn复杂度</strong>求法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Ceil</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> x / y + (x % y != <span class="hljs-number">0</span>);&#125;<br><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">J</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> q)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> D=<span class="hljs-number">1</span>,<span class="hljs-built_in">end</span>=(q<span class="hljs-number">-1</span>)*n;<br>    <span class="hljs-keyword">while</span>(D&lt;=<span class="hljs-built_in">end</span>)<br>        D=Ceil(q*D,q<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> q*n+<span class="hljs-number">1</span>-D;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n,q;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;q))<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, J(n,q));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>具体证明见<a href="https://www.zhihu.com/question/358255792/answer/974983270">godweiyang的回答</a></p><h3 id="序列自动机"><a href="#序列自动机" class="headerlink" title="序列自动机"></a>序列自动机</h3><blockquote><p>求s1是否是s2的子串，复杂度是 siz(s2)<em>26+siz(s1);空间只需要siz(s2)</em>26即可</p></blockquote><p>当时在太原五中看到的，整理旧blog时顺带补上<br>原理就是预处理出s2的每位后最靠前的26个字母，存起来之后把s1放到上面扫就行。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">string</span> s1,s2;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">27</span>][<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(a,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(a));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">26</span>;j++)<br>a[j][i]=a[j][i+<span class="hljs-number">1</span>];<br>a[s1[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>][i]=i;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;s2)<br>&#123;<br><span class="hljs-keyword">int</span> kl=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;s2.<span class="hljs-built_in">size</span>();i++)<br>&#123;<br><span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;a[s2[i]-&#x27;a&#x27;+1][j]&lt;&lt;endl;</span><br><span class="hljs-keyword">if</span>(a[s2[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>][j]!=a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>j=a[s2[i]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>][j];<br><span class="hljs-keyword">else</span><br>&#123;kl=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(kl==<span class="hljs-number">1</span>)<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="伪三分"><a href="#伪三分" class="headerlink" title="伪三分"></a>伪三分</h3><blockquote><p>求二次函数极值</p></blockquote><p>正常的二分只能在单调函数上寻找值，呢么假如我们要寻找二次函数的极值这种问题，肯定是无法直接使用二分来进行。<br>呢么我们可以用三分来解决这个问题，当然这个小专题名字叫做伪三分，呢就肯定不是正常的三分算法。准确的说我们使用的还是二分算法，只不过相当于是在原函数的“导数”上二分。<br>每一次取mid时，通过判断mid左右极小值的函数值大小来判断此点的斜率，假如f[mid+eps]&gt;f[mid-eps]，呢么函数在mid这一点的极小邻域内必定是上升。反之，则是下降。根据函数特性来用mid替换左边界或右边界。<br><a href="https://www.luogu.com.cn/problem/P3382">题目</a>和代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">double</span> eps=<span class="hljs-number">0.00001</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br><span class="hljs-keyword">double</span> ll,rr,Fans,a[<span class="hljs-number">30</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">double</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> ans=a[n+<span class="hljs-number">1</span>],xx=x;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        ans+=a[i]*xx;<br>        xx*=x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span><br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;ll&gt;&gt;rr;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)<span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>    <span class="hljs-keyword">while</span>((rr-ll)&gt;eps)<br>    &#123;<br>        <span class="hljs-keyword">double</span> mid=(ll+rr)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(F(mid+eps)-F(mid-eps)&lt;<span class="hljs-number">0</span>)rr=mid;<br>        <span class="hljs-keyword">else</span> ll=mid;<br>        <span class="hljs-comment">//cout&lt;&lt;ll&lt;&lt;&#x27; &#x27;&lt;&lt;rr&lt;&lt;&#x27; &#x27;&lt;&lt;mid&lt;&lt;&#x27; &#x27;&lt;&lt;F(mid)&lt;&lt;endl;</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;rr&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="二叉树的三种遍历方式"><a href="#二叉树的三种遍历方式" class="headerlink" title="二叉树的三种遍历方式"></a>二叉树的三种遍历方式</h3><p>首先我们需要知道这三种方式都是如何遍历的<br>前序遍历：根节点-&gt;左子树-&gt;右子树<br>中序遍历：左子树-&gt;根节点-&gt;右子树<br>后序遍历：左子树-&gt;右子树-&gt;根节点<br>我们知道中序遍历以及另一种遍历结果，是可以求出来剩下的一种遍历结果的，而已知前序遍历、后序遍历无法求出中序遍历（因为由前序后序重构出来的二叉树不止一种）</p><h3 id="分段打表"><a href="#分段打表" class="headerlink" title="分段打表"></a>分段打表</h3><p>2022的天梯赛选拔，寄。<br>主要原因卡了两道题，一题是自己的思路绕弯了，把自己卡了很久。另一道就是这个需要分段打表的题。<br>考场上确实是推出来是逆元的性质，但是不会做快速求1e9的阶乘。<br>分段打表是可以将打表的递推数据不全部打出，假入全部输出线性递推的所有数据（比如这道题用的阶乘），输出所耗时间很多并且文件也很难存下。<br>于是可以将区间平均的分为100段，只存这100段的头的数据，具体需要求哪个数的时候从距离他最近的打表数据开始递推，复杂度就降到了n/100（可以打更多的段，复杂度就更低）。<br>大概是这样，希望下次不寄。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板补全计划</title>
    <link href="/2021/02/28/%E6%A8%A1%E6%9D%BF%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/"/>
    <url>/2021/02/28/%E6%A8%A1%E6%9D%BF%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="区间加乘"><a href="#区间加乘" class="headerlink" title="区间加乘"></a>区间加乘</h4><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 100010</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LL long long  </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> left l,mid,k&lt;&lt;1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> right mid+1,r,k&lt;&lt;1|1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lef k&lt;&lt;1 </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rig k&lt;&lt;1|1</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,m,p,s,x,y;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum[maxn*<span class="hljs-number">4</span>],kk,lazy_ad[maxn*<span class="hljs-number">4</span>],lazy_mu[maxn*<span class="hljs-number">4</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>,w=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> ch=getchar();<br><span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)w=<span class="hljs-number">-1</span>; ch=getchar();&#125;<br><span class="hljs-keyword">while</span>(ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>&amp;&amp;ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>) s=s*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>,ch=getchar();<br><span class="hljs-keyword">return</span> s*w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>lazy_mu[k]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(l==r) sum[k]=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>build(left); build(right);<br>sum[k]=(sum[lef]+sum[rig])%p;<span class="hljs-comment">//</span><br>&#125;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k,LL a,LL b)</span></span><br><span class="hljs-function"></span>&#123;<br>lazy_ad[k]=(lazy_ad[k]*b+a)%p;<br>lazy_mu[k]=(lazy_mu[k]*b)%p;<br>sum[k]=(sum[k]*b+(r-l+<span class="hljs-number">1</span>)*a)%p;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k)</span><span class="hljs-comment">//</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>push(left,lazy_ad[k],lazy_mu[k]);<br>push(right,lazy_ad[k],lazy_mu[k]);<br>lazy_ad[k]=<span class="hljs-number">0</span>;lazy_mu[k]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midefy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k,LL a,LL b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) push(l,r,k,a,b);<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(lazy_ad[k]!=<span class="hljs-number">0</span>||lazy_mu[k]!=<span class="hljs-number">1</span>) down(l,r,k);<br><span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid) midefy(left,a,b);<br><span class="hljs-keyword">if</span>(y&gt;mid) midefy(right,a,b);<br>sum[k]=(sum[lef]+sum[rig])%p;<br>&#125;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> LL <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> k)</span><span class="hljs-comment">//询问</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="hljs-keyword">return</span> sum[k];<br><span class="hljs-keyword">if</span>(lazy_ad[k]!=<span class="hljs-number">0</span>||lazy_mu[k]!=<span class="hljs-number">1</span>) down(l,r,k);<br><span class="hljs-keyword">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>LL ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid) ans=(ans+ask(left))%p;<br><span class="hljs-keyword">if</span>(y&gt;mid) ans=(ans+ask(right))%p;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>n=<span class="hljs-built_in">read</span>(); m=<span class="hljs-built_in">read</span>(); p=<span class="hljs-built_in">read</span>(); <br>build(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>s=<span class="hljs-built_in">read</span>();x=<span class="hljs-built_in">read</span>(); y=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">if</span>(s==<span class="hljs-number">1</span>)<span class="hljs-comment">//add</span><br>&#123;<br>kk=<span class="hljs-built_in">read</span>(); <br>midefy(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,kk);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-number">2</span>)<span class="hljs-comment">//mul</span><br>&#123;<br>kk=<span class="hljs-built_in">read</span>(); <br>midefy(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,kk,<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ask(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>));<span class="hljs-comment">//ask</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><details><summary>代码</summary><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;iostream&gt;</span><br><span class="hljs-comment">#include&lt;cstdio&gt;  </span><br><span class="hljs-comment">#include&lt;cmath&gt;  </span><br><span class="hljs-comment">#include&lt;cstring&gt;  </span><br><span class="hljs-comment">#include&lt;algorithm&gt; </span><br>using namespace std; <br>inline <span class="hljs-keyword">int</span> lowbit(<span class="hljs-keyword">int</span> k)&#123;<span class="hljs-keyword">return</span> k&amp;(-k);&#125;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">5000</span>],c[<span class="hljs-number">5000</span>],s[<span class="hljs-number">5000</span>],n,m,m1,m2;<br><span class="hljs-keyword">int</span> add(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> yu)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kl=yu;kl&lt;=n;kl+=lowbit(kl))<br>c[kl]+=k;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">int</span> Find(<span class="hljs-keyword">int</span> k)<br>&#123;<br><span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kl=k;kl&gt;<span class="hljs-number">0</span>;kl-=lowbit(kl))<br>sum+=c[kl];<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-keyword">int</span> quadd(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> kl)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=k;i&gt;<span class="hljs-number">0</span>;i-=lowbit(i))<br>s[i]+=kl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">int</span> quFind(<span class="hljs-keyword">int</span> k)<br>&#123;<br><span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> kl=k;kl&lt;n;kl+=lowbit(kl))<br>sum+=s[kl];<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-keyword">int</span> main()<br>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;m1&gt;&gt;m2;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>cin&gt;&gt;a[i];<br>add(a[i],i);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m1;i++)//单点修改<br>&#123;<br><span class="hljs-keyword">int</span> kl,kl1;<br>cin&gt;&gt;kl&gt;&gt;kl1;<br>add(kl1-a[kl],kl);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)//区间求和<br>&#123;<br><span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>,<span class="hljs-keyword">y</span>;<br>cin&gt;&gt;<span class="hljs-keyword">x</span>&gt;&gt;<span class="hljs-keyword">y</span>;<br>cout&lt;&lt;Find(<span class="hljs-keyword">y</span>)-Find(<span class="hljs-keyword">x</span>-<span class="hljs-number">1</span>)&lt;&lt;endl;<br>&#125;<br>//<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m1;i++)//区间修改<br>&#123;<br><span class="hljs-keyword">int</span> kl,kl1,kl2;<br>cin&gt;&gt;kl1&gt;&gt;kl2&gt;&gt;kl;<br>quadd(kl2,kl);<br>quadd(kl1-<span class="hljs-number">1</span>,-kl);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)//输出区间修改后结果<br>cout&lt;&lt;a[i]+quFind(i)&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>cout&lt;&lt;endl;<br>//<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="prim"><a href="#prim" class="headerlink" title="prim"></a>prim</h4><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,a[<span class="hljs-number">5000</span>][<span class="hljs-number">5000</span>],m,sum=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> dis[<span class="hljs-number">10000</span>],vis[<span class="hljs-number">10000</span>];<br><span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">10</span>,<span class="hljs-keyword">sizeof</span>(dis));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>dis[i]=a[st][i];<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<br>vis[st]=<span class="hljs-number">1</span>;<br>sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">int</span> minn=dis[<span class="hljs-number">0</span>],kl=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(vis[j]==<span class="hljs-number">0</span>&amp;&amp;dis[j]&lt;minn)<br>&#123;<br>minn=dis[j];<br>kl=j;<br>&#125;<br>&#125;<br>vis[kl]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>&#123;<br><span class="hljs-keyword">if</span>(a[kl][j]&lt;dis[j]&amp;&amp;vis[j]==<span class="hljs-number">0</span>)<br>&#123;<br>dis[j]=a[kl][j];<br>&#125;<br>&#125;<br>sum+=minn;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//freopen(&quot;a1.in&quot;,&quot;r&quot;,stdin);</span><br><span class="hljs-comment">//freopen(&quot;a1.out&quot;,&quot;w&quot;,stdout);</span><br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-keyword">int</span> x,y,z;<br><span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>a[x][y]=z;<br>a[y][x]=z;<br>&#125;<br>prim(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nn</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x,y,v;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> next,id,y,v;<br>&#125;bian[<span class="hljs-number">50010</span>];<br>nn bianpai[<span class="hljs-number">50010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mycmp</span><span class="hljs-params">(nn a1,nn a2)</span></span>&#123;<span class="hljs-keyword">return</span> a1.v&lt;a2.v;&#125;<br><span class="hljs-keyword">int</span> lin[<span class="hljs-number">50010</span>],k=<span class="hljs-number">0</span>,n,m,numn=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> bianrank[<span class="hljs-number">50010</span>],fa[<span class="hljs-number">50010</span>],dd[<span class="hljs-number">50010</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy,<span class="hljs-keyword">int</span> vv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//cout&lt;&lt;vv&lt;&lt;endl;</span><br>bian[++k].y=yy,bian[k].id=xx,bian[k].v=vv;<br>bian[k].next=lin[xx];<br>lin[xx]=k;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findfather</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(fa[xx]==xx)<span class="hljs-keyword">return</span> xx;<br><span class="hljs-keyword">return</span> fa[xx]=findfather(fa[xx]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfather</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> xfa=findfather(xx),yfa=findfather(yy);<br>fa[xfa]=yfa;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dd,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(dd));<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)fa[i]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,xx,yy,vv;i&lt;=m;i++)<span class="hljs-comment">//先用一个结构体存储每一条边用于排序</span><br>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;xx&gt;&gt;yy&gt;&gt;vv;<br>bianpai[i].x=xx;<br>bianpai[i].y=yy;<br>bianpai[i].v=vv;<br>&#125;<br>sort(bianpai+<span class="hljs-number">1</span>,bianpai+m+<span class="hljs-number">1</span>,mycmp);<span class="hljs-comment">//将边从小到大排序</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<span class="hljs-comment">//将排好序的边用连接表按次序储存</span><br>&#123;<br><span class="hljs-comment">//cout&lt;&lt;bianpai[i].v&lt;&lt;endl;</span><br>insert(bianpai[i].x,bianpai[i].y,bianpai[i].v);<br>insert(bianpai[i].y,bianpai[i].x,bianpai[i].v);<br>bianrank[i]=k;<span class="hljs-comment">//通过名次得到连接表中边的下标（由于连接表的构造性质可知实际上就是边的rank*2</span><br>&#125;<br><span class="hljs-comment">//cout&lt;&lt;endl;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,xfa,yfa;i&lt;=m;i++)<br>&#123;<br>xfa=findfather(bian[bianrank[i]].id);<br>yfa=findfather(bian[bianrank[i]].y);<br><span class="hljs-keyword">if</span>(xfa==yfa)<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判断这条边的两点是否在并查集中，若都存在则continue</span><br><span class="hljs-keyword">else</span><br>&#123;<br>addfather(bian[bianrank[i]].id,bian[bianrank[i]].y);<span class="hljs-comment">//将两点加入并查集中</span><br><span class="hljs-comment">//cout&lt;&lt;bian[bianrank[i]].id&lt;&lt;&#x27; &#x27;&lt;&lt;bian[bianrank[i]].y&lt;&lt;&#x27; &#x27;&lt;&lt;bian[bianrank[i]].v&lt;&lt;endl;</span><br>sum+=bian[bianrank[i]].v;<br><span class="hljs-keyword">if</span>(dd[bian[bianrank[i]].id]==<span class="hljs-number">0</span>)dd[bian[bianrank[i]].id]=<span class="hljs-number">1</span>,numn++;<span class="hljs-comment">//新点则计数器++</span><br><span class="hljs-keyword">if</span>(dd[bian[bianrank[i]].y]==<span class="hljs-number">0</span>)dd[bian[bianrank[i]].y]=<span class="hljs-number">1</span>,numn++;<span class="hljs-comment">//新点则计数器++</span><br>&#125;<br><span class="hljs-keyword">if</span>(numn==n)<span class="hljs-comment">//若n个点全在点集中，break</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="hljs-comment">for(int j=lin[i];j!=0;j=bian[j].next)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">cout&lt;&lt;&quot;_--&quot;&lt;&lt;bian[j].y&lt;&lt;&#x27;:&#x27;&lt;&lt;bian[j].v&lt;&lt;endl;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">cout&lt;&lt;endl;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="强连通分量-dfn-low"><a href="#强连通分量-dfn-low" class="headerlink" title="强连通分量(dfn-low)"></a>强连通分量(dfn-low)</h3><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> y,next;<br>&#125;e[<span class="hljs-number">100001</span>];<br><span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>,m,n,k1,top=<span class="hljs-number">0</span>,num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> lin[<span class="hljs-number">100001</span>],flag[<span class="hljs-number">100001</span>];<br><span class="hljs-keyword">int</span> q[<span class="hljs-number">100001</span>],dfn[<span class="hljs-number">100001</span>],low[<span class="hljs-number">100001</span>],fa[<span class="hljs-number">100001</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>e[++k].next=lin[x];<br>lin[x]=k;<br>e[k].y=y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>num++;<br>    dfn[x]=low[x]=num;<br>    q[++top]=x;<span class="hljs-comment">//点入栈顶</span><br>    flag[x]=<span class="hljs-number">1</span>;<span class="hljs-comment">//标记该点以入栈</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u=lin[x],v;u!=<span class="hljs-number">0</span>;u=e[u].next)<span class="hljs-comment">//dfs深度优先搜索</span><br>    &#123;<br>        v=e[u].y;<br>        <span class="hljs-keyword">if</span>(dfn[v]==<span class="hljs-number">0</span>)<span class="hljs-comment">//若该点并未标记dfn和low值，即从未进入栈</span><br>        &#123;<br>            tarjan(v);<span class="hljs-comment">//递归该点</span><br>            <span class="hljs-keyword">if</span>(low[v]&lt;low[x])low[x]=low[v];<span class="hljs-comment">//通过该点low值更新自身low值</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br><span class="hljs-keyword">if</span>(flag[v]!=<span class="hljs-number">0</span>&amp;&amp;dfn[v]&lt;low[x])<span class="hljs-comment">//若该点以标记并且在栈里则更新当前所在点low</span><br>low[x]=dfn[v];<span class="hljs-comment">//不过为啥要和dfn比，不应该是和low比吗？</span><br>    &#125;<br><span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;dfn[x]&lt;&lt;&#x27; &#x27;&lt;&lt;low[x]&lt;&lt;endl;</span><br>    <span class="hljs-keyword">if</span>(dfn[x]==low[x])<br>    &#123;<br>        k1++;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;The&quot;</span>&lt;&lt;k1&lt;&lt;<span class="hljs-string">&quot;th strongly connected component is:&quot;</span>;<br>        <span class="hljs-keyword">while</span>(q[top+<span class="hljs-number">1</span>]!=x)<br>        &#123;<br>flag[q[top]]=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;q[top]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            top--;<br>        &#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,a1,a2;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a1&gt;&gt;a2;<br>        add(a1,a2);<br>    &#125;<br>k1=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dfn[i]==<span class="hljs-number">0</span>)<br>tarjan(i);<br>    &#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;There are &quot;</span>&lt;&lt;k1&lt;&lt;<span class="hljs-string">&quot; strongly connected components in this Graph&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="求割点"><a href="#求割点" class="headerlink" title="求割点"></a>求割点</h3><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> y,next,id;<br>&#125;e[<span class="hljs-number">50000</span>],e1[<span class="hljs-number">50000</span>];<br><span class="hljs-keyword">int</span> lin[<span class="hljs-number">50000</span>],lin1[<span class="hljs-number">50000</span>],k=<span class="hljs-number">0</span>,dfn[<span class="hljs-number">50000</span>],low[<span class="hljs-number">50000</span>],flag[<span class="hljs-number">50000</span>];<br><span class="hljs-keyword">int</span> n,m,tt;<br><span class="hljs-keyword">int</span> q[<span class="hljs-number">50000</span>],top=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy)</span></span><br><span class="hljs-function"></span>&#123;<br>e[++k].next=lin[xx];<br>lin[xx]=k;<br>e[k].y=yy;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>low[x]=dfn[x]=++tt;<br><span class="hljs-keyword">int</span> son=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lin[x];i!=<span class="hljs-number">0</span>;i=e[i].next)<br>&#123;<br><span class="hljs-keyword">if</span>(e[i].y==fa)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(dfn[e[i].y]==<span class="hljs-number">0</span>)<br>&#123;<br>tarjan(e[i].y,x);<br><span class="hljs-keyword">if</span>(low[e[i].y]&gt;=dfn[x])<br>son++;<br>&#125;<br>low[x]=<span class="hljs-built_in">min</span>(low[x],low[e[i].y]);<br>&#125;<br><span class="hljs-keyword">if</span>(son&gt;<span class="hljs-number">1</span>||(son==<span class="hljs-number">1</span>&amp;&amp;fa!=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y;i&lt;=m;i++)<br>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>insert(x,y);<br>insert(y,x);<br>&#125;<br>k=<span class="hljs-number">0</span>;<br>tarjan(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><h4 id="Edmond-Karp求最大流"><a href="#Edmond-Karp求最大流" class="headerlink" title="Edmond_Karp求最大流"></a>Edmond_Karp求最大流</h4><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> u,v,c;<br><span class="hljs-keyword">int</span> next;<br>&#125;edge[<span class="hljs-number">4000005</span>];<br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">1</span>;<span class="hljs-comment">//边数</span><br><span class="hljs-keyword">int</span> head[<span class="hljs-number">40005</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v,<span class="hljs-keyword">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[cnt].u=u; edge[cnt].v=v; edge[cnt].c=c; <span class="hljs-comment">//正向边初始化为容量</span><br>edge[cnt].next=head[u]; head[u]=cnt++;<br><br>edge[cnt].u=v; edge[cnt].v=u; edge[cnt].c=<span class="hljs-number">0</span>; <span class="hljs-comment">//反向边容量初始化为0</span><br>edge[cnt].next=head[v]; head[v]=cnt++;<br>&#125;<br><span class="hljs-keyword">bool</span> visit[<span class="hljs-number">5005</span>]; <span class="hljs-comment">// 记录结点i是否已访问</span><br><span class="hljs-keyword">int</span> pre[<span class="hljs-number">5005</span>]; <span class="hljs-comment">//记录路径</span><br><span class="hljs-keyword">int</span> n,m,start,<span class="hljs-built_in">end</span>; <span class="hljs-comment">//源点，汇点</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span><span class="hljs-comment">//寻找从源点到汇点的增广路，若找到返回true</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt;q;<br>    <span class="hljs-built_in">memset</span>(pre,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(pre));<br>    <span class="hljs-built_in">memset</span>(visit,<span class="hljs-literal">false</span>,<span class="hljs-keyword">sizeof</span>(visit));<br>pre[start]=<span class="hljs-number">-1</span>;<br>    visit[start]=<span class="hljs-literal">true</span>;<br>    q.push(start);<br>    <span class="hljs-keyword">while</span>(q.empty()!=<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">int</span> u=q.front();<br>        q.pop();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head[u];i!=<span class="hljs-number">-1</span>;i=edge[i].next)<br>        &#123;<br>            <span class="hljs-keyword">int</span> v=edge[i].v;<br>            <span class="hljs-keyword">if</span>(edge[i].c&gt;<span class="hljs-number">0</span>&amp;&amp;visit[v]!=<span class="hljs-literal">true</span>)<br>            &#123;<br>                pre[v]=i;<br>                visit[v]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(v==<span class="hljs-built_in">end</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//存在增广路</span><br>                q.push(v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Edmond_Karp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> delta;<br>    <span class="hljs-keyword">while</span>(bfs())      <span class="hljs-comment">//反复在源点到汇点间寻找增广路</span><br>&#123;<br>delta=<span class="hljs-number">10000000000LL</span>;<br><span class="hljs-keyword">int</span> i=pre[<span class="hljs-built_in">end</span>];<br>        <span class="hljs-keyword">while</span>(i!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            delta=<span class="hljs-built_in">min</span>(delta,edge[i].c);   <span class="hljs-comment">//路径上最小的容量为流量增量</span><br>            i=pre[edge[i].u];<br>        &#125;<br>        i=pre[<span class="hljs-built_in">end</span>];<br>        <span class="hljs-keyword">while</span>(i!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-comment">// 路径上各边容量相应减少，反向边容量相应增加，总流量增加</span><br>            edge[i].c-=delta;   <span class="hljs-comment">//增广路上的边减去使用的容量</span><br>            edge[i+<span class="hljs-number">1</span>].c+=delta;  <span class="hljs-comment">//同时相应的反向边增加残余容量</span><br>            i=pre[edge[i].u];<br>        &#125;<br>        sum+=delta;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(head,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(head));<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-keyword">int</span> a,b,c;<br><span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>addedge(a,b,c);<br>&#125;<br>start=<span class="hljs-number">1</span>,<span class="hljs-built_in">end</span>=n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,Edmond_Karp());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h4 id="Dinic求最大流"><a href="#Dinic求最大流" class="headerlink" title="Dinic求最大流"></a>Dinic求最大流</h4><pre><code>Compared with the Edmond_Karp , the time complexity is better, because the depth arrays is used to reduce the meaningless path selection, and the cur arrays can also be used to optimize    </code></pre><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> y,flow,Next;<br>&#125;e[Maxn*<span class="hljs-number">2</span>];<span class="hljs-comment">//edge</span><br><span class="hljs-keyword">int</span> m,n,start,<span class="hljs-built_in">end</span>,Link[Maxn],depth[Maxn],que[Maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c=getchar();<br>    <span class="hljs-keyword">while</span> (c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>) c=getchar();<br>    <span class="hljs-keyword">while</span> (c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>    &#123;<br>        x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        c=getchar();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy,<span class="hljs-keyword">int</span> ff)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[num].Next=Link[xx];<br>    Link[xx]=num;<br>    e[num].y=yy;<br>    e[num].flow=ff;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();start=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">end</span>=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,xx,yy,ff;i&lt;=m;i++)<br>    &#123;<br>        xx=<span class="hljs-built_in">read</span>();yy=<span class="hljs-built_in">read</span>();ff=<span class="hljs-built_in">read</span>();<br>        insert(i*<span class="hljs-number">2</span>,xx,yy,ff);<span class="hljs-comment">//original edge</span><br>        insert(i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,yy,xx,<span class="hljs-number">0</span>);<span class="hljs-comment">//opposite edge</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> head=<span class="hljs-number">1</span>,tail=<span class="hljs-number">1</span>,xx,yy;<br>    <span class="hljs-built_in">memset</span>(depth,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(depth));<br>    depth[start]=<span class="hljs-number">1</span>;que[<span class="hljs-number">1</span>]=start;<br>    <span class="hljs-keyword">for</span>(;head&lt;=tail;head++)<br>    &#123;<br>        xx=que[head];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=Link[xx];i;i=e[i].Next)<br>            <span class="hljs-keyword">if</span>(e[i].flow&amp;&amp;!depth[yy=e[i].y])<br>            &#123;<br>                depth[yy]=depth[xx]+<span class="hljs-number">1</span>;<br>                que[++tail]=yy;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth[<span class="hljs-built_in">end</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> Nowflow)</span><span class="hljs-comment">//Use DFS to search the flow which we can add.</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(xx==<span class="hljs-built_in">end</span>) <span class="hljs-keyword">return</span> Nowflow;<br>    <span class="hljs-keyword">int</span> yy,Addflow,ataf=<span class="hljs-number">0</span>;<span class="hljs-comment">//ataf=able to add flow;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=Link[xx];i&amp;&amp;ataf&lt; Nowflow;i=e[i].Next)<br>        <span class="hljs-keyword">if</span> (e[i].flow&amp;&amp;depth[yy=e[i].y]==depth[xx]+<span class="hljs-number">1</span>)<span class="hljs-comment">//To make sure we can add this flow.&amp;&amp;It must be in more depth.</span><br>        &#123;<br>            Addflow=dfs(yy,<span class="hljs-built_in">min</span>(Nowflow-ataf,e[i].flow));<br>            e[i].flow-=Addflow;<br>            e[i^<span class="hljs-number">1</span>].flow+=Addflow;<br>            ataf+=Addflow;<br>        &#125;<br>    <span class="hljs-keyword">if</span>(ataf==<span class="hljs-number">0</span>) depth[xx]=<span class="hljs-number">0</span>;<span class="hljs-comment">//If we cannot add flow on this point,we will never use it.</span><br>    <span class="hljs-keyword">return</span> ataf;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;bfs();)<span class="hljs-comment">//Every times,we use bfs to find if we can add some flow</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x;(x=dfs(start,INF));)ans+=x;<span class="hljs-comment">//When we find that it is passible, use dfs to add the flow.</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span><br>    init();<br>    Dinic();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h4 id="当前弧优化的Dinic"><a href="#当前弧优化的Dinic" class="headerlink" title="当前弧优化的Dinic"></a>当前弧优化的Dinic</h4><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">7</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> y,flow,Next;<br>&#125;e[Maxn*<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> m,n,start,<span class="hljs-built_in">end</span>,Link[Maxn],depth[Maxn],que[Maxn],cur[Maxn];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">char</span> c=getchar();<br>    <span class="hljs-keyword">while</span> (c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>) c=getchar();<br>    <span class="hljs-keyword">while</span> (c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>    &#123;<br>        x=x*<span class="hljs-number">10</span>+c-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        c=getchar();<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy,<span class="hljs-keyword">int</span> ff)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[num].Next=Link[xx];<br>    Link[xx]=num;<br>    e[num].y=yy;<br>    e[num].flow=ff;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();start=<span class="hljs-built_in">read</span>();<span class="hljs-built_in">end</span>=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,xx,yy,ff;i&lt;=m;i++)<br>    &#123;<br>        xx=<span class="hljs-built_in">read</span>();yy=<span class="hljs-built_in">read</span>();ff=<span class="hljs-built_in">read</span>();<br>        insert(i*<span class="hljs-number">2</span>,xx,yy,ff);<br>        insert(i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,yy,xx,<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> head=<span class="hljs-number">1</span>,tail=<span class="hljs-number">1</span>,xx,yy;<br>    <span class="hljs-built_in">memset</span>(depth,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(depth));<br>    depth[start]=<span class="hljs-number">1</span>;que[<span class="hljs-number">1</span>]=start;<br>    <span class="hljs-keyword">for</span>(;head&lt;=tail;head++)<br>    &#123;<br>        xx=que[head];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=Link[xx];i;i=e[i].Next)<br>            <span class="hljs-keyword">if</span>(e[i].flow&amp;&amp;!depth[yy=e[i].y])<br>            &#123;<br>                depth[yy]=depth[xx]+<span class="hljs-number">1</span>;<br>                que[++tail]=yy;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> depth[<span class="hljs-built_in">end</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> Nowflow)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(xx==<span class="hljs-built_in">end</span>) <span class="hljs-keyword">return</span> Nowflow;<br>    <span class="hljs-keyword">int</span> yy,Addflow,ataf=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur[xx];i&amp;&amp;ataf&lt; Nowflow;i=e[i].Next)<br>    &#123;<br>        cur[xx]=i;<span class="hljs-comment">//Mark the last pass point and search directly from it next time。</span><br>        <span class="hljs-keyword">if</span> (e[i].flow&amp;&amp;depth[yy=e[i].y]==depth[xx]+<span class="hljs-number">1</span>)<br>        &#123;<br>            Addflow=dfs(yy,<span class="hljs-built_in">min</span>(Nowflow-ataf,e[i].flow));<br>            e[i].flow-=Addflow;<br>            e[i^<span class="hljs-number">1</span>].flow+=Addflow;<br>            ataf+=Addflow;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ataf==<span class="hljs-number">0</span>) depth[xx]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> ataf;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;bfs();)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(cur,Link,<span class="hljs-keyword">sizeof</span>(Link));<span class="hljs-comment">//Change the cur arrayy every times.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x;(x=dfs(start,INF));)<br>            ans+=x;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span><br>    init();<br>    Dinic();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h4 id="最小费用最大流-EK-SPFA"><a href="#最小费用最大流-EK-SPFA" class="headerlink" title="最小费用最大流(EK+SPFA)"></a>最小费用最大流(EK+SPFA)</h4><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">10010</span>,maxm=<span class="hljs-number">100010</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> vis[maxn],dis[maxn],maxflow=<span class="hljs-number">0</span>,mincost=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> n,m,s,t;<br><span class="hljs-keyword">int</span> pre[maxm];<span class="hljs-comment">//pre[] is an arrey record the last point of the path which is possible.</span><br><span class="hljs-keyword">int</span> last[maxm];<span class="hljs-comment">//last[] is an arrey record the edge to the last point of the path.</span><br><span class="hljs-keyword">int</span> STNF[maxn];<span class="hljs-comment">//STNF[] is the flow which from start point to the point right now.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> y,next,flow,v;<br>&#125;e[maxm &lt;&lt; <span class="hljs-number">1</span>];<br><span class="hljs-keyword">int</span> Link[maxn],edgenum; <br><span class="hljs-keyword">int</span> q[maxm&lt;&lt; <span class="hljs-number">1</span>],head,tail;<br><span class="hljs-comment">//Attation!the size of the que is not direct,so we need to define it in a large size.</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy,<span class="hljs-keyword">int</span> ff,<span class="hljs-keyword">int</span> vv)</span></span><br><span class="hljs-function"></span>&#123;<br>e[++edgenum].next=Link[xx];<br>e[edgenum].y=yy;<br>e[edgenum].flow=ff;<br>e[edgenum].v=vv;<br>Link[xx]=edgenum;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(Link,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span>(Link)); edgenum=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;t);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,xx,yy,vv,ff;i&lt;=m;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;xx,&amp;yy,&amp;ff,&amp;vv);<br>insert(xx,yy,ff,vv);<br>        insert(yy,xx,<span class="hljs-number">0</span>,-vv);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s,<span class="hljs-keyword">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(dis,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span>(dis));<br><span class="hljs-built_in">memset</span>(STNF,<span class="hljs-number">0x7f</span>,<span class="hljs-keyword">sizeof</span>(STNF));<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(vis));<br>    head=<span class="hljs-number">0</span>;tail=<span class="hljs-number">0</span>;<br>q[++tail]=s; vis[s]=<span class="hljs-number">1</span>; dis[s]=<span class="hljs-number">0</span>; pre[t]=<span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">while</span>(head&lt;tail)<br>&#123;<br><span class="hljs-keyword">int</span> now=q[++head];<br>vis[now]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=Link[now];i!=<span class="hljs-number">-1</span>;i=e[i].next)<br>&#123;<br><span class="hljs-keyword">if</span> (e[i].flow&gt;<span class="hljs-number">0</span> &amp;&amp; dis[e[i].y]&gt;dis[now]+e[i].v) <br>&#123;<br>dis[e[i].y]=dis[now]+e[i].v;<br>pre[e[i].y]=now;last[e[i].y]=i;<span class="hljs-comment">//recording the path.</span><br>STNF[e[i].y]=<span class="hljs-built_in">min</span>(STNF[now],e[i].flow);<span class="hljs-comment">//renew the flow at this point.</span><br><span class="hljs-keyword">if</span>(!vis[e[i].y])<br>&#123;<br>vis[e[i].y]=<span class="hljs-number">1</span>;<br>q[++tail]=e[i].y;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> pre[t]!=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MCMF</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(spfa(s,t))<br>&#123;<br>        <span class="hljs-comment">//for(int i=1;i&lt;=n;i++)cout&lt;&lt;dis[i]&lt;&lt;&#x27; &#x27;;cout&lt;&lt;endl;</span><br><span class="hljs-keyword">int</span> now=t;<br>maxflow+=STNF[t];<br>mincost+=STNF[t]*dis[t];<br>        <span class="hljs-comment">//cout&lt;&lt;STNF[t]&lt;&lt;&#x27; &#x27;&lt;&lt;dis[t]&lt;&lt;endl;</span><br><span class="hljs-keyword">while</span>(now!=s)<br>&#123;<br>            <span class="hljs-comment">//cout&lt;&lt;now&lt;&lt;&#x27;-&#x27;;</span><br>e[last[now]].flow-=STNF[t];<br>e[last[now]^<span class="hljs-number">1</span>].flow+=STNF[t];<br>            now=pre[now];<br>&#125;<span class="hljs-comment">//cout&lt;&lt;endl;</span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,maxflow,mincost);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span><br>    <span class="hljs-comment">//int kl= clock();</span><br>    Init();<br>MCMF();<br>    <span class="hljs-comment">//cout&lt;&lt;clock()-kl&lt;&lt;endl;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="Kruskal重构树"><a href="#Kruskal重构树" class="headerlink" title="Kruskal重构树"></a>Kruskal重构树</h3><p>通常用来求路径上极值问题</p><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">3e4</span>+<span class="hljs-number">5</span>,M=<span class="hljs-number">6e4</span>+<span class="hljs-number">5</span>,logN=<span class="hljs-number">15</span>+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> n,m,q,kl,fa[N],Link[N],val[N],yy[M],Next[M],f[N][logN],dep[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> u,v,w;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> ss &amp;rhs) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">return</span> w&lt;rhs.w;<br>    &#125;<br>&#125;e[M];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span>&#123;yy[++kl]=v,Next[kl]=Link[u],Link[u]=kl;&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> fa[x]==x?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    sort(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">int</span> lim=n+n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=lim;++i)fa[i]=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> idx=n,i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br>    &#123;<br>      <span class="hljs-keyword">int</span> fu=<span class="hljs-built_in">find</span>(e[i].u),fv=<span class="hljs-built_in">find</span>(e[i].v);<br>      <span class="hljs-keyword">if</span>(fu==fv) <span class="hljs-keyword">continue</span>;<br>      fa[fu]=fa[fv]=++idx,val[idx]=e[i].w;<br>      add(idx,fu),add(idx,fv);<br>      <span class="hljs-keyword">if</span>(idx==lim<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    dep[u]=dep[fa]+<span class="hljs-number">1</span>,f[u][<span class="hljs-number">0</span>]=fa;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;i)&lt;=dep[u];++i)f[u][i]=f[f[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=Link[u];i;i=Next[i])<span class="hljs-keyword">if</span>(yy[i]!=fa)dfs(yy[i],u);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(dep[u]&gt;dep[v]) u^=v^=u^=v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">15</span>;~i;--i)<span class="hljs-keyword">if</span>(dep[f[v][i]]&gt;=dep[u]) v=f[v][i];<br>    <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">15</span>;~i;--i)<span class="hljs-keyword">if</span>(f[u][i]^f[v][i]) u=f[u][i],v=f[v][i];<br>    <span class="hljs-keyword">return</span> f[u][<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);<br>    kruskal();<span class="hljs-comment">//建生成树</span><br>    dfs(<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//预处理递增</span><br>    <span class="hljs-keyword">while</span>(q--)<br>    &#123;<br>        <span class="hljs-keyword">int</span> u,v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,val[lca(u,v)]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></details><h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> X=<span class="hljs-number">0</span>,w=<span class="hljs-number">1</span>; <span class="hljs-keyword">char</span> c=getchar();<br>    <span class="hljs-keyword">while</span> (c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123; <span class="hljs-keyword">if</span> (c==<span class="hljs-string">&#x27;-&#x27;</span>) w=<span class="hljs-number">-1</span>; c=getchar(); &#125;<br>    <span class="hljs-keyword">while</span> (c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) X=(X&lt;&lt;<span class="hljs-number">3</span>)+(X&lt;&lt;<span class="hljs-number">1</span>)+c-<span class="hljs-string">&#x27;0&#x27;</span>,c=getchar();<br>    <span class="hljs-keyword">return</span> X*w;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> x,y,v,next;<br>&#125;e[<span class="hljs-number">500010</span>];<br><span class="hljs-keyword">int</span> n,m,s;<br><span class="hljs-keyword">int</span> Link[<span class="hljs-number">100010</span>],k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> dis[<span class="hljs-number">100010</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy,<span class="hljs-keyword">int</span> vv)</span></span><br><span class="hljs-function"></span>&#123;<br>e[++k].x=xx;e[k].y=yy;e[k].v=vv;<br>e[k].next=Link[xx];<br>Link[xx]=k;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> u,d;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> node&amp; rhs) <span class="hljs-keyword">const</span>&#123;<span class="hljs-keyword">return</span> d&gt;rhs.d;&#125;<br>&#125;;<br><span class="hljs-built_in">priority_queue</span>&lt;node&gt;Q; <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) dis[i]=<span class="hljs-number">100000000000ll</span>;<br>dis[st]=<span class="hljs-number">0</span>;<br>node minpoint;<br>minpoint.u=st;minpoint.d=<span class="hljs-number">0</span>;<br>    Q.push(minpoint);<br><span class="hljs-keyword">while</span>(Q.<span class="hljs-built_in">size</span>())<br>&#123;<br>        minpoint=Q.top();Q.pop();<br>        <span class="hljs-keyword">int</span> u=minpoint.u,d=minpoint.d;<br><span class="hljs-keyword">if</span> (dis[u]!=d) <span class="hljs-keyword">continue</span> ;<br><span class="hljs-comment">//cout&lt;&lt;u&lt;&lt;&#x27; &#x27;&lt;&lt;d&lt;&lt;endl;</span><br>        <span class="hljs-comment">//if (d!=dis[u]) continue;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=Link[u];j;j=e[j].next)<span class="hljs-comment">//用最近的点来更新其他点的最近距离</span><br>&#123;<span class="hljs-comment">//保证了前一步找最近的点时找到的就是该点的最短路</span><br><span class="hljs-keyword">if</span>(dis[e[j].y]&gt;d+e[j].v)<br>&#123;<br>dis[e[j].y]=d+e[j].v;<br>                Q.push((node)&#123;e[j].y,dis[e[j].y]&#125;);<br>&#125;<br>&#125;<br>        <span class="hljs-comment">//minpoint=Q.top();Q.pop();</span><br>        <span class="hljs-comment">//u=minpoint.u,d=minpoint.d;</span><br><span class="hljs-comment">//cout&lt;&lt;u&lt;&lt;&#x27; &#x27;&lt;&lt;d&lt;&lt;endl;</span><br>&#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br><span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span><br><span class="hljs-comment">//int jk=clock();</span><br>n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();s=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,xx,yy,vv;i&lt;=m;i++)<br>&#123;<br>xx=<span class="hljs-built_in">read</span>();yy=<span class="hljs-built_in">read</span>();vv=<span class="hljs-built_in">read</span>();<br>insert(xx,yy,vv);<br>&#125;<br><span class="hljs-comment">/*for(int i=1;i&lt;=n;i++)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">cout&lt;&lt;i&lt;&lt;&#x27;:&#x27;&lt;&lt;endl;</span><br><span class="hljs-comment">for(int j=Link[i];j;j=e[j].next)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">cout&lt;&lt;&quot;  -&quot;&lt;&lt;e[j].y&lt;&lt;&#x27;:&#x27;&lt;&lt;e[j].v&lt;&lt;endl;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;*/</span><br>dj(s);<br><span class="hljs-comment">//cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,dis[i]);<br><span class="hljs-comment">//cout&lt;&lt;clock()-jk&lt;&lt;endl;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">dj的原理在于从起始点(点一)到目标点(点二)的最短路径上，</span><br><span class="hljs-comment">每一点(点三)都是最短的路径。由反证法得知，若该路径不是最短的路径，</span><br><span class="hljs-comment">呢么必有从起始点(点一)到中间某一点(点三)的另一条路径是起始点(点一)到目标点(点二)的最短路径的组成部分</span><br><span class="hljs-comment">故从起始点到目标点的最短路径可由(起始点到中间点的最短路和中间点到目标点路径长度求和后最小值)求得</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></details><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h3><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">char</span> s1[<span class="hljs-number">1000001</span>],s2[<span class="hljs-number">1000001</span>];<br><span class="hljs-keyword">int</span> Next[<span class="hljs-number">1000001</span>],ii=<span class="hljs-number">0</span>,jj=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> Next1[<span class="hljs-number">1000001</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FindNext</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    jj=<span class="hljs-number">0</span>;<span class="hljs-comment">//jj在Next数组建立时的含义为S1前缀子串中前缀与后缀相同的长度</span><br>    <span class="hljs-keyword">for</span>(ii=<span class="hljs-number">1</span>;ii&lt;n;ii++)<span class="hljs-comment">//遍历s1的下标，从1也就是第二位开始</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(;jj!=<span class="hljs-number">0</span>&amp;&amp;s1[ii]!=s1[jj];)jj=Next[jj]; <span class="hljs-comment">//s1[jj]为为S1前缀子串中已匹配前缀后的一个字母</span><br>        <span class="hljs-keyword">if</span>(s1[ii]==s1[jj])jj++;<span class="hljs-comment">//同上，若相同则jj即长度++;</span><br>        Next[ii+<span class="hljs-number">1</span>]=jj;<span class="hljs-comment">//Next[ii+1]指的是s1的第ii位(下标从0开始，下标是ii对应的就是第ii+1位)前缀子串中前缀与后缀相同的长度</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Find_string</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>jj=<span class="hljs-number">0</span>;  <span class="hljs-comment">//jj在两字符串匹配时的含义是已经匹配的长度，未匹配时长度为0</span><br><span class="hljs-keyword">for</span>(ii=<span class="hljs-number">0</span>;ii&lt;m;ii++)<br>&#123;<br>        <span class="hljs-keyword">for</span>(;(jj&gt;<span class="hljs-number">0</span>)&amp;&amp;(s1[jj]!=s2[ii]);)jj=Next[jj];<span class="hljs-comment">//s1[jj]为为S1前缀子串中 已匹配前缀 后的第一个字母</span><br><span class="hljs-keyword">if</span>(s1[jj]==s2[ii])jj++;<span class="hljs-comment">//若以匹配前缀后字母相同则长度++</span><br><span class="hljs-keyword">if</span>(jj==n) <span class="hljs-comment">//找到匹配，当然可以继续找下一个匹配</span><br>&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;ii-jj+<span class="hljs-number">2</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<span class="hljs-comment">//注意，ii为下标，即从零开始，故找到的s2中的一个s1字串的起始位置是ii-jj+2</span><br>jj=Next[jj];<span class="hljs-comment">//最后的j:=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配</span><br>&#125;<br>    &#125;   <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span><br><span class="hljs-built_in">memset</span>(Next,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(Next));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>,s2,s1);<span class="hljs-comment">//注意，本代码中字符数组下标均为从0开始</span><br>    n=<span class="hljs-built_in">strlen</span>(s1);<br>    m=<span class="hljs-built_in">strlen</span>(s2);<br>    FindNext();<br>    Find_string();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">cout</span>&lt;&lt;Next[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//输出Next数组</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="tiretree"><a href="#tiretree" class="headerlink" title="tiretree"></a>tiretree</h3><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> ch;         <span class="hljs-comment">//本节点的值</span><br>    <span class="hljs-keyword">bool</span> endflag; <span class="hljs-comment">//是否是某个单词的最后一个字符</span><br>    <span class="hljs-keyword">int</span> link[<span class="hljs-number">26</span>]; <span class="hljs-comment">//26个分叉</span><br>&#125;tree[<span class="hljs-number">600100</span>];<br><span class="hljs-keyword">int</span> len=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> node,<span class="hljs-built_in">string</span> s)</span>  <span class="hljs-comment">//k是s的第k个字符，node为当前节点。</span></span><br><span class="hljs-function"></span>&#123;      <br>    <span class="hljs-keyword">int</span>  chindex=s[k]-<span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">//字符的编号</span><br>    <span class="hljs-keyword">if</span> (tree[node].link[chindex]==<span class="hljs-number">0</span>)   <span class="hljs-comment">//新开节点</span><br>&#123;<br>tree[node].link[chindex]=++len;    <br>tree[len].ch=s[k]; <br>tree[len].endflag=<span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">int</span> nexnode=tree[node].link[chindex];  <span class="hljs-comment">//下一个节点的下标</span><br>    <span class="hljs-keyword">if</span> (k==(<span class="hljs-keyword">int</span>)s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>    &#123;<br>        tree[nexnode].endflag=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    add(k+<span class="hljs-number">1</span>,nexnode,s);    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> node,<span class="hljs-built_in">string</span> s)</span></span><br><span class="hljs-function"><span class="hljs-comment">//k是要查找字符串s的第k个元素</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> chindex=s[k]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (tree[node].link[chindex]==<span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">int</span> nextnode=tree[node].link[chindex];<br>    <span class="hljs-keyword">if</span>(k==(s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)) <span class="hljs-comment">//如果k是最后一个字符</span><br>       <span class="hljs-keyword">if</span>(tree[nextnode].endflag)  <br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span>                                    <br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(k+<span class="hljs-number">1</span>,nextnode,s);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">string</span> s1,s2;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;s1;<br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,s1);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;s2;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,s2)==<span class="hljs-literal">true</span>)<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;True&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;False&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt; </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span> ch;         <span class="hljs-comment">//本节点的值</span><br>    <span class="hljs-keyword">int</span> endflag; <span class="hljs-comment">//是否是某个单词的最后一个字符</span><br>    <span class="hljs-keyword">int</span> link[<span class="hljs-number">26</span>]; <span class="hljs-comment">//26个分叉</span><br>    <span class="hljs-keyword">int</span> fa;          <span class="hljs-comment">//记录节点的父亲</span><br>&#125;tree[<span class="hljs-number">1000010</span>];<br><span class="hljs-keyword">int</span> len=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>,s1size,s2size,panduan=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> s1[<span class="hljs-number">1000010</span>],s2[<span class="hljs-number">1000010</span>];<br><span class="hljs-keyword">int</span> Fail[<span class="hljs-number">10000010</span>];<span class="hljs-comment">//记录第i个点匹配失败后跳到的节点</span><br><span class="hljs-keyword">int</span> q[<span class="hljs-number">1000010</span>],head,tail;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k,<span class="hljs-keyword">int</span> node)</span>  <span class="hljs-comment">//k是s的第k个字符，node为当前节点（是字符串下标为k的字母节点的父节点）。</span></span><br><span class="hljs-function"></span>&#123;      <br>    <span class="hljs-keyword">int</span>  chindex=s1[k]-<span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">//字符的编号</span><br>    <span class="hljs-keyword">if</span> (tree[node].link[chindex]==<span class="hljs-number">0</span>)   <span class="hljs-comment">//新开节点</span><br>&#123;<br>tree[node].link[chindex]=++len;    <br>tree[len].ch=s1[k]; <br>tree[len].endflag=<span class="hljs-number">0</span>;<br>tree[len].fa=node;<br>&#125;<br>    <span class="hljs-keyword">if</span> (k==s1size<span class="hljs-number">-1</span>)<span class="hljs-comment">//若已经将s1添加完，使其最后一个字母节点endflag++；</span><br>    &#123;<br>        tree[tree[node].link[chindex]].endflag++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;   <br>    add(k+<span class="hljs-number">1</span>,tree[node].link[chindex]);    <span class="hljs-comment">//跳到下一个节点</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeFail</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span><span class="hljs-comment">//y用BFS进行Fail指针的建立，因为Fail指针永远向上，故用BFS可确保建立Fail时指向的节点已经完整的建立了Fail路径</span></span><br><span class="hljs-function"></span>&#123;    <br>    head=tail=<span class="hljs-number">1</span>;<br>    q[tail]=node;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=head,Nowch,FF;i&lt;=tail;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">26</span>;j++)<span class="hljs-keyword">if</span>(tree[q[i]].link[j]!=<span class="hljs-number">0</span>)q[++tail]=tree[q[i]].link[j];<span class="hljs-comment">//将存在的子节点都加入队列</span><br>        Nowch=tree[q[i]].ch-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(FF=Fail[tree[q[i]].fa];tree[FF].link[Nowch]==<span class="hljs-number">0</span>&amp;&amp;FF!=<span class="hljs-number">0</span>;FF=Fail[FF]);<span class="hljs-comment">//循环，每次跳到父亲的Fail指针指向的节点，判断节点是否有该字符的子节点。持续知道找到这么个节点或是到达根节点</span><br>        <span class="hljs-keyword">if</span>(tree[q[i]].fa==<span class="hljs-number">0</span>)Fail[q[i]]=<span class="hljs-number">0</span>;<span class="hljs-comment">//若FF为0节点即第一层节点，呢么Fail指针直指0节点</span><br>        <span class="hljs-keyword">else</span> Fail[q[i]]=tree[FF].link[Nowch];<span class="hljs-comment">//将该点的失败指针指向父节点Fail最终停下来的子节点，即最终找到的节点</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span><span class="hljs-comment">//打表，请自行忽略</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span>&lt;&lt; node&lt;&lt;<span class="hljs-string">&quot;  是否end  &quot;</span>&lt;&lt;tree[node].endflag&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)<br>        <span class="hljs-keyword">if</span>(tree[node].link[i]!=<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;   &quot;</span>&lt;&lt;(<span class="hljs-keyword">char</span>)(i+<span class="hljs-string">&#x27;a&#x27;</span>)&lt;&lt;<span class="hljs-string">&#x27;:&#x27;</span>&lt;&lt;tree[node].link[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)<br>        <span class="hljs-keyword">if</span>(tree[node].link[i]!=<span class="hljs-number">0</span>)<br>            dfs(tree[node].link[i]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(Fail,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(Fail));<br>    <span class="hljs-built_in">memset</span>(tree,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(tree));<br>    <span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    <span class="hljs-comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);eeeeee</span><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s1);<br>        s1size=<span class="hljs-built_in">strlen</span>(s1);<br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br>    makeFail(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//dfs(0);</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s2);<br>    s2size=<span class="hljs-built_in">strlen</span>(s2);<br>   <br><span class="hljs-comment">//find(0,0);</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>,node=<span class="hljs-number">0</span>,chnode,chindex;k&lt;s2size;k++)<span class="hljs-comment">//查找，k为s2的下标，node为当前节点，chnode为当前节点的与s2此时下标所表示字符相同的子节点，相当于s2中的字符实际上匹配的是子节点而不是node</span><br>    &#123;<br>        chindex=s2[k]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        chnode=tree[node].link[chindex];<br>        <span class="hljs-keyword">for</span>(;chnode==<span class="hljs-number">0</span>&amp;&amp;node!=<span class="hljs-number">0</span>;node=Fail[node],chnode=tree[node].link[chindex]);<span class="hljs-comment">//子节点为0表示当前的node并没有相对应的子节点，故需通过Fail指针进入下一节点。node为0时表明已经到达根节点无法再通过Fail指针跳跃，chnode不为0表示当前节点有一子节点和s2的当前字符匹配，这两种情况退出Fail跳跃</span><br>        <span class="hljs-keyword">if</span>(tree[chnode].endflag!=<span class="hljs-number">0</span>)sum+=tree[chnode].endflag,tree[chnode].endflag=<span class="hljs-number">0</span>;<span class="hljs-comment">//当chnode为终止节点时计数器增加，Fail跳跃循环的第一种退出循环的方式chnode的endflag必为0故不会妨碍</span><br>        node=chnode;<span class="hljs-comment">//通过Fail跳跃此时的chnode必与s2此时下标所表示字符相同或者为0(为0即重新开始下一个字符)，由当前节点进入chnode，进行下一次操作</span><br>        <span class="hljs-comment">//cout&lt;&lt;node&lt;&lt;&#x27; &#x27;&lt;&lt;chindex&lt;&lt;&#x27; &#x27;&lt;&lt;chnode&lt;&lt;&#x27; &#x27;&lt;&lt;tree[chnode].ch&lt;&lt;&#x27;-&#x27;&lt;&lt;tree[chnode].endflag&lt;&lt;&quot;   dsf&quot;&lt;&lt;sum&lt;&lt;endl;</span><br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br></code></pre></td></tr></table></figure></details><h3 id="后缀树"><a href="#后缀树" class="headerlink" title="后缀树"></a>后缀树</h3><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">string</span> s1;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> note;<br><span class="hljs-keyword">int</span> ch1;<br><span class="hljs-keyword">int</span> lengh;<br>&#125;active;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tt</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> ch[<span class="hljs-number">30</span>];<br><span class="hljs-keyword">int</span> <span class="hljs-built_in">begin</span>;<br><span class="hljs-keyword">int</span> <span class="hljs-built_in">end</span>;<br><span class="hljs-keyword">int</span> lianjie;<br>&#125;tree[<span class="hljs-number">500010</span>];<br><span class="hljs-keyword">int</span> kl=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> last=<span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fenlie</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(active.lengh==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>tree[tree[active.note].ch[active.ch1]].ch[s1[active.lengh+tree[tree[active.note].ch[active.ch1]].<span class="hljs-built_in">begin</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]=++kl;<br>tree[tree[active.note].ch[active.ch1]].<span class="hljs-built_in">end</span>=active.lengh+tree[tree[active.note].ch[active.ch1]].<span class="hljs-built_in">begin</span><span class="hljs-number">-1</span>;<br>tree[kl].<span class="hljs-built_in">begin</span>=active.lengh+tree[tree[active.note].ch[active.ch1]].<span class="hljs-built_in">begin</span>;<br>tree[kl].<span class="hljs-built_in">end</span>=<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//先将原边分为两条</span><br>tree[tree[active.note].ch[active.ch1]].ch[s1[k]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>]=++kl;<br>tree[kl].<span class="hljs-built_in">begin</span>=k;<br>tree[kl].<span class="hljs-built_in">end</span>=<span class="hljs-number">-1</span>;<br><span class="hljs-comment">//创建新加入点的新边</span><br><span class="hljs-keyword">if</span>(active.note==<span class="hljs-number">0</span>)<br>&#123;<br>active.lengh--;<br><span class="hljs-keyword">if</span>(active.lengh==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> jk1=s1[tree[tree[active.note].ch[active.ch1]].<span class="hljs-built_in">begin</span>+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//下一个点的字符</span><br>tree[tree[active.note].ch[active.ch1]].lianjie=tree[active.note].ch[jk1];<span class="hljs-comment">//后缀链接</span><br>active.ch1=jk1;<br>fenlie(k);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>active.note=tree[active.note].lianjie;<br>fenlie(k);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">built</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> jk=s1[k]-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//要插入的点</span><br><span class="hljs-keyword">if</span>(active.lengh==<span class="hljs-number">0</span>)<span class="hljs-comment">//没有活动点时</span><br>&#123;<br><span class="hljs-keyword">if</span>(tree[active.note].ch[jk]==<span class="hljs-number">0</span>)<span class="hljs-comment">//没有记录就添新边</span><br>&#123;<br>tree[active.note].ch[jk]=++kl;<br>tree[kl].<span class="hljs-built_in">begin</span>=k;<br>tree[kl].<span class="hljs-built_in">end</span>=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//有记录加入活动点</span><br>&#123;<br>active.ch1=jk;<br>active.lengh++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//tree[active.note].ch[active.ch1]是活动节点的编号</span><br><span class="hljs-keyword">int</span> yu=k-tree[tree[active.note].ch[active.ch1]].<span class="hljs-built_in">begin</span>;<span class="hljs-comment">//yu是这个点现在所记录的长度</span><br><span class="hljs-keyword">int</span> yu1=tree[tree[active.note].ch[active.ch1]].<span class="hljs-built_in">begin</span>+active.lengh;<span class="hljs-comment">//yu1是这个点的第lengh位</span><br><span class="hljs-keyword">if</span>(s1[yu1]==s1[k])<br>&#123;<br>active.lengh++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>last=<span class="hljs-number">-1</span>;<br>fenlie(k);<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(tree,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(tree));<br>active.note=active.ch1=active.lengh=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">cin</span>&gt;&gt;s1;<br>built(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h3><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MAXN = <span class="hljs-number">100005</span>;<br><span class="hljs-keyword">char</span> ch[MAXN], All[MAXN];<br><span class="hljs-keyword">int</span> SA[MAXN], rank[MAXN], Height[MAXN], tax[MAXN], tp[MAXN], a[MAXN], n, m; <br><span class="hljs-keyword">char</span> str[MAXN];<br><span class="hljs-comment">//rank[i] 第i个后缀的排名; SA[i] 排名为i的后缀位置; Height[i] 排名为i的后缀与排名为(i-1)的后缀的LCP</span><br><span class="hljs-comment">//tax[i] 计数排序辅助数组; tp[i] rank的辅助数组(计数排序中的第二关键字),与SA意义一样。</span><br><span class="hljs-comment">//a为原串</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RSort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//rank第一关键字,tp第二关键字。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)tax[i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)tax[rank[tp[i]]]++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)tax[i]+=tax[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)SA[tax[rank[tp[i]]]--]=tp[i]; <span class="hljs-comment">//确保满足第一关键字的同时，再满足第二关键字的要求</span><br>&#125; <span class="hljs-comment">//计数排序,把新的二元组排序。</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *f, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> w)</span> </span>&#123;<span class="hljs-keyword">return</span> f[x]==f[y]&amp;&amp;f[x+w]==f[y+w];&#125; <br><span class="hljs-comment">//通过二元组两个下标的比较，确定两个子串是否相同</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Suffix</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//SA</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)rank[i]=a[i],tp[i]=i;<br>    m=<span class="hljs-number">127</span>,RSort(); <span class="hljs-comment">//一开始是以单个字符为单位，所以(m = 127)</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w=<span class="hljs-number">1</span>,p=<span class="hljs-number">1</span>,i;p&lt;n;w+=w,m=p)<span class="hljs-comment">//把子串长度翻倍,更新rank</span><br>&#123;<br>        <span class="hljs-comment">//w 当前一个子串的长度; m 当前离散后的排名种类数</span><br>        <span class="hljs-comment">//当前的tp(第二关键字)可直接由上一次的SA的得到</span><br>        <span class="hljs-keyword">for</span>(p=<span class="hljs-number">0</span>,i=n-w+<span class="hljs-number">1</span>;i&lt;=n;i++)tp[++p]=i; <span class="hljs-comment">//长度越界,第二关键字为0</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span>(SA[i]&gt;w)<br>tp[++p]=SA[i]-w;<br>        <span class="hljs-comment">//更新SA值,并用tp暂时存下上一轮的rank(用于cmp比较)</span><br>        RSort(); <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>&#123;<br><span class="hljs-keyword">int</span> t=rank[i];<br>rank[i]=tp[i];<br>tp[i]=t;<br>&#125;<br>rank[SA[<span class="hljs-number">1</span>]]=<span class="hljs-number">1</span>;<br>p=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//用已经完成的SA来更新与它互逆的rank,并离散rank</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;=n;i++)rank[SA[i]]=cmp(tp,SA[i],SA[i<span class="hljs-number">-1</span>],w)?p:++p;<br>    &#125;<br>    <span class="hljs-comment">//离散：把相等的字符串的rank设为相同。</span><br>    <span class="hljs-comment">//LCP</span><br>    <span class="hljs-keyword">int</span> j, k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;Height[rank[i++]]=k) <br>    &#123;<br><span class="hljs-comment">//for(k=(k!=0)?k-1:k,j=sa[rank[i]-1];a[i+k]==a[j+k];++k);</span><br>        <span class="hljs-keyword">for</span>(k=(k!=<span class="hljs-number">0</span>)?k<span class="hljs-number">-1</span>:k;;)<br>&#123;<br><span class="hljs-comment">/*if(k!=0)</span><br><span class="hljs-comment">k=k-1;</span><br><span class="hljs-comment">else</span><br><span class="hljs-comment">k=k;*/</span><br>j=SA[rank[i]<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">if</span>(a[i+k]==a[j+k])<br>++k;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>    <span class="hljs-comment">//这个知道原理后就比较好理解程序</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    n=<span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)a[i+<span class="hljs-number">1</span>]=str[i];<br>    Suffix();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br><span class="hljs-built_in">cout</span>&lt;&lt;Height[i]&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="后缀自动机-咕"><a href="#后缀自动机-咕" class="headerlink" title="后缀自动机(咕)"></a>后缀自动机(咕)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">啊这，怎么这个也咕了啊<br></code></pre></td></tr></table></figure><h3 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h3><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">2323237</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">2323238</span>][<span class="hljs-number">9</span>];<span class="hljs-comment">//114MB</span><br><span class="hljs-built_in">string</span> s11[<span class="hljs-number">10001</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> sum=<span class="hljs-number">0</span>,kl=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;s11[t].<span class="hljs-built_in">size</span>();j++)<br>&#123;<br><span class="hljs-keyword">int</span> yu=(<span class="hljs-keyword">int</span>)(s11[t][j]-<span class="hljs-string">&#x27;1&#x27;</span>+<span class="hljs-number">1</span>);<br>sum+=yu*kl;<br>kl*=<span class="hljs-number">26</span>;<br>kl%=mod;<br>sum%=mod;<br>&#125;<br><span class="hljs-comment">//cout&lt;&lt;sum&lt;&lt;&#x27; &#x27;&lt;&lt;t&lt;&lt;endl;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=a[sum][<span class="hljs-number">0</span>];i++)<br>&#123;<br><span class="hljs-keyword">if</span>(s11[a[sum][i]]==s11[t])<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>a[sum][++a[sum][<span class="hljs-number">0</span>]]=t;<br><span class="hljs-comment">//cout&lt;&lt;sum&lt;&lt;&#x27; &#x27;&lt;&lt;a[sum][0]&lt;&lt;&#x27; &#x27;&lt;&lt;t&lt;&lt;endl;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//freopen(&quot;a1.in&quot;,&quot;r&quot;,stdin);</span><br><span class="hljs-comment">//freopen(&quot;a1.out&quot;,&quot;w&quot;,stdout);</span><br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(a));<br><span class="hljs-keyword">int</span> n,sum=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;s11[i];<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)==<span class="hljs-number">0</span>)<br>sum++;<br>&#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p>数论的总结更在了<a href="https://linzeyin.github.io/2021/03/06/%E6%95%B0%E8%AE%BA/">这里</a></p><h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><p>计算几何的总结在<a href="https://linzeyin.github.io/2021/04/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0/">这里</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h3><h4 id="ST-DFS在线"><a href="#ST-DFS在线" class="headerlink" title="ST+DFS在线"></a>ST+DFS在线</h4><details><summary>代码</summary><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include&lt;iostream&gt;<br>#include&lt;cstdio&gt;<br>#include&lt;algorithm&gt;<br>#include&lt;cmath&gt;<br>#include&lt;cstring&gt;<br>#include&lt;cctype&gt;//这个库必须加<br>using namespace std;<br>char buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>],*fs,*ft;<br>inline char getc()&#123;return (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">15</span>,stdin),fs==ft))?<span class="hljs-number">0</span>:*fs++;&#125;<br>inline int read()&#123;<br>int x=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;  char ch=getc();<br>while(!isdigit(ch))  &#123;if(ch==<span class="hljs-string">&#x27;-&#x27;</span>)  f=<span class="hljs-number">-1</span>;  ch=getc();&#125;<br>while(isdigit(ch))  &#123;x=x*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>;  ch=getc();&#125;<br>return x*f;<br>&#125;<br>struct edge <br>&#123;<br>    int y,v,next;<br>&#125;e[<span class="hljs-number">1000010</span>];<br>int len=<span class="hljs-number">0</span>,lin[<span class="hljs-number">1000010</span>];<br>int a[<span class="hljs-number">1000110</span>],aa=<span class="hljs-number">0</span>,dp[<span class="hljs-number">1000100</span>],kkl[<span class="hljs-number">1000010</span>],r[<span class="hljs-number">1000010</span>],kl[<span class="hljs-number">19</span>],n,m,s,f[<span class="hljs-number">1000010</span>][<span class="hljs-number">19</span>],e1[<span class="hljs-number">1000010</span>][<span class="hljs-number">19</span>],lenk[<span class="hljs-number">1001000</span>];<br>inline void dfs(int k,int dd)<br>&#123;<br>    a[++aa]=k;<br>    dp[aa]=dd;<br>if(r[k]==<span class="hljs-number">0</span>)<br>r[k]=aa;<br>    for(int i=lin[k];i!=<span class="hljs-number">0</span>;i=e[i].next)<br>    &#123;<br>if(kkl[e[i].y]==<span class="hljs-number">0</span>)<br>&#123;<br>kkl[e[i].y]=<span class="hljs-number">1</span>;<br>dfs(e[i].y,dd+<span class="hljs-number">1</span>);<br>a[++aa]=k;<br>dp[aa]=dd;<br>&#125;<br>    &#125;<br>    return ;<br>&#125;<br>int main()<br>&#123;<br>    //freopen(<span class="hljs-string">&quot;a.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,stdin);<br>    //freopen(<span class="hljs-string">&quot;a.out&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,stdout);<br>    cin&gt;&gt;n&gt;&gt;m;<br>//int k=clock();<br>    for(int i=<span class="hljs-number">1</span>,x,y;i&lt;=n<span class="hljs-number">-1</span>;++i)<br>    &#123;<br>       x=read();<br>   y=read();<br>        &#123;<br>            e[++len].next=lin[x];<br>            lin[x]=len;<br>            e[len].y=y;<br>        &#125;<br>&#123;<br>            e[++len].next=lin[y];<br>            lin[y]=len;<br>            e[len].y=x;<br>        &#125;<br>    &#125;<br><br>kkl[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    //cout&lt;&lt;aa&lt;&lt;endl;<br>    <span class="hljs-comment">/*for(int i=1;i&lt;=aa;i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    cout&lt;&lt;endl;</span><br><span class="hljs-comment">    for(int i=1;i&lt;=aa;i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        cout&lt;&lt;dp[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    cout&lt;&lt;endl;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    for(int i=1;i&lt;=n;i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        cout&lt;&lt;r[i]&lt;&lt;&#x27; &#x27;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    cout&lt;&lt;endl;*/</span><br>    int kl1=<span class="hljs-number">0</span>;<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=aa;++i)<br>    &#123;<br>        f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]=min(dp[i<span class="hljs-number">-1</span>],dp[i]);<br>        if(dp[i<span class="hljs-number">-1</span>]&lt;=dp[i])<br>            e1[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]=i<span class="hljs-number">-1</span>;<br>        else<br>            e1[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]=i;<br>    &#125;<br>    f[aa][<span class="hljs-number">1</span>]=dp[aa];<br>e1[aa][<span class="hljs-number">1</span>]=aa;<br>    for(int yu=<span class="hljs-number">2</span>;yu&lt;=aa;yu&lt;&lt;=<span class="hljs-number">1</span>)<br>        kl[++kl1]=yu;<br>    for(int j=<span class="hljs-number">2</span>;j&lt;=kl1;++j)<br>        for(int i=<span class="hljs-number">1</span>;i&lt;=aa;++i)<br>        &#123;<br>            if(f[i][j<span class="hljs-number">-1</span>]&lt;=f[i+kl[j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>])<br>            &#123;<br>                e1[i][j]=e1[i][j<span class="hljs-number">-1</span>];<br>                f[i][j]=f[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>            else<br>            &#123;<br>                e1[i][j]=e1[i+kl[j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>                f[i][j]=f[i+kl[j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>                <br>            &#125;<br>        &#125;<br>    for(int i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>,z;i&lt;=aa;++i)<br>    &#123;<br>        if(i&gt;kl[j]&lt;&lt;<span class="hljs-number">1</span>)<br>            j++;<br>        lenk[i]=j;<br>    &#125;<br>    for(int i=<span class="hljs-number">1</span>,x,y,yu;i&lt;=m;++i)//输入区间<br>    &#123;<br>       x=read();<br>   y=read();<br>   if(x==y)<br>&#123;   cout&lt;&lt;x&lt;&lt;endl;<br>   continue;&#125;<br>        x=r[x];<br>        y=r[y];<br>        int yu1=max(x,y);<br>        x=min(x,y);<br>        y=yu1;<br>        int lenn=y-x+<span class="hljs-number">1</span>;<br>        if(f[x][lenk[lenn]]&lt;=f[y-kl[lenk[lenn]]+<span class="hljs-number">1</span>][lenk[lenn]])<br>            yu=e1[x][lenk[lenn]];<br>        else<br>            yu=e1[y-kl[lenk[lenn]]+<span class="hljs-number">1</span>][lenk[lenn]];<br>        //cout&lt;&lt;f[x][lenk[lenn]]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;lenk[lenn]&lt;&lt;endl;<br>        //cout&lt;&lt;f[y-kl[lenk[lenn]]][lenk[lenn]+<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;y-kl[lenk[lenn]]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;lenk[lenn]&lt;&lt;endl;<br>        cout&lt;&lt;a[yu]&lt;&lt;endl;<br>    &#125;<br>//cout&lt;&lt;clock()-k&lt;&lt;endl;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h4 id="倍增-离线"><a href="#倍增-离线" class="headerlink" title="倍增 离线"></a>倍增 离线</h4><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> y,next;<br>&#125;e[<span class="hljs-number">1000010</span>];<br><span class="hljs-keyword">int</span> lin[<span class="hljs-number">1000010</span>],kl,n,m,kkk[<span class="hljs-number">1000010</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy)</span></span><br><span class="hljs-function"></span>&#123;<br>e[++kl].next=lin[xx];<br>lin[xx]=kl;<br>e[kl].y=yy;<br>&#125;<br><span class="hljs-keyword">int</span> dep[<span class="hljs-number">1000010</span>],fa[<span class="hljs-number">1000010</span>];<br><span class="hljs-keyword">int</span> ff[<span class="hljs-number">1000010</span>][<span class="hljs-number">40</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> now,<span class="hljs-keyword">int</span> dd)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//cout&lt;&lt;fa[now]&lt;&lt;&#x27; &#x27;&lt;&lt;now&lt;&lt;endl;</span><br>dep[now]=dd;<br><span class="hljs-comment">//cout&lt;&lt;now&lt;&lt;&#x27;:&#x27;&lt;&lt;endl;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;(<span class="hljs-number">1</span>&lt;&lt;j)&lt;=dep[now];j++)<br>&#123;<br>ff[now][j]=ff[ff[now][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//cout&lt;&lt;&quot;     &quot;&lt;&lt;j&lt;&lt;&#x27;:&#x27;&lt;&lt;ff[now][j]&lt;&lt;endl;</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=lin[now];i!=<span class="hljs-number">0</span>;i=e[i].next)<br>&#123;<br><span class="hljs-keyword">if</span>(kkk[e[i].y]==<span class="hljs-number">0</span>)<br>&#123;<br>kkk[e[i].y]=<span class="hljs-number">1</span>;<br>ff[e[i].y][<span class="hljs-number">0</span>]=fa[e[i].y]=now;<br>dfs1(e[i].y,dd+<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">if</span>(dep[u]&lt;dep[v])swap(u,v);<br>    <span class="hljs-keyword">int</span> delta=dep[u]-dep[v];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">30</span>;x&gt;=<span class="hljs-number">0</span>;x--)  <br>        <span class="hljs-keyword">if</span>((<span class="hljs-number">1</span>&lt;&lt;x)&amp;delta)<br>            u=ff[u][x];  <br>    <span class="hljs-keyword">if</span>(u==v)<br><span class="hljs-keyword">return</span> u;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">30</span>;x&gt;=<span class="hljs-number">0</span>;x--)<br>        <span class="hljs-keyword">if</span>(ff[u][x]!=ff[v][x])<br>        &#123;  <br>            u=ff[u][x];  <br>            v=ff[v][x];<br>        &#125;  <br>    <span class="hljs-keyword">return</span> ff[u][<span class="hljs-number">0</span>];<br>&#125; <br><span class="hljs-keyword">int</span> root;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//freopen(&quot;subset.in&quot;,&quot;r&quot;,stdin);</span><br><span class="hljs-comment">//freopen(&quot;subset.out&quot;,&quot;w&quot;,stdout);</span><br><span class="hljs-comment">//    freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br><span class="hljs-comment">//freopen(&quot;add2.out&quot;,&quot;w&quot;,stdout);</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-keyword">int</span> xx,yy;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;xx,&amp;yy);<br>insert(xx,yy);<br>insert(yy,xx);<br>&#125;<br>kkk[root]=<span class="hljs-number">1</span>;<br>ff[root][<span class="hljs-number">0</span>]=fa[root]=root;<br><br>dfs1(root,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-keyword">int</span> xx,yy,vv;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;xx,&amp;yy);<br>vv=LCA(xx,yy);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,vv);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> fa[<span class="hljs-number">5000</span>],k,a1,a2;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> kk)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(fa[kk]==kk)<br><span class="hljs-keyword">return</span> kk;<br><span class="hljs-keyword">return</span> fa[kk]=<span class="hljs-built_in">find</span>(fa[kk]);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> faxx=<span class="hljs-built_in">find</span>(xx);<br><span class="hljs-keyword">int</span> fayy=<span class="hljs-built_in">find</span>(yy);<br>fa[faxx]=fayy;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>fa[i]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;k&gt;&gt;a1&gt;&gt;a2;<br><span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)<br>add(a1,a2);<br><span class="hljs-keyword">if</span>(k==<span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a1)==<span class="hljs-built_in">find</span>(a2))<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Nop&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="RMQ求区间最值"><a href="#RMQ求区间最值" class="headerlink" title="RMQ求区间最值"></a>RMQ求区间最值</h3><details><summary>代码</summary><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;//RMQ求区间最值</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> n,m,a[<span class="hljs-number">100020</span>];<br><span class="hljs-keyword">int</span> f[<span class="hljs-number">100020</span>][<span class="hljs-number">20</span>];<span class="hljs-comment">//f[i][j]表示从第i位开始往后2^j位的最值</span><br><span class="hljs-keyword">int</span> kl[<span class="hljs-number">20</span>];<span class="hljs-comment">//kl[i]指的是2^i</span><br><span class="hljs-keyword">int</span> kl1[<span class="hljs-number">100020</span>];<span class="hljs-comment">//kl1[i]表示i小于等于2的几次方</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">10</span>,<span class="hljs-keyword">sizeof</span>(a));<br><span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>f[i][<span class="hljs-number">0</span>]=a[i];<br>&#125;<br>kl[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>kl1[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)<br>&#123;<br>kl[i]=kl[i<span class="hljs-number">-1</span>]*<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(kl[i]&gt;=n)<br><span class="hljs-keyword">break</span>;<br>kl1[kl[i]]=kl1[kl[i<span class="hljs-number">-1</span>]]+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;kl[k]&lt;=n;k++)<span class="hljs-comment">//循环k保证存在2^k小于n</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//从第一位循环到第n位（其实可以优化下循环到n-kl[k])</span><br>f[i][k]=<span class="hljs-built_in">min</span>(f[i][k<span class="hljs-number">-1</span>],f[i+kl[k<span class="hljs-number">-1</span>]][k<span class="hljs-number">-1</span>]);<span class="hljs-comment">//递推式，第i位往后2^k个数的最值通过 &#123;第i位往后2^(k-1)个数的最值&#125; 和 &#123;第（i+2^(k-1)）位往后2^(k-1)个数的最值&#125;  求出</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(kl1[i]==<span class="hljs-number">0</span>)<br>kl1[i]=kl1[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//补完kl1</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,x,y,z;i&lt;=m;i++)<br>&#123;<br><span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;<br>z=<span class="hljs-built_in">max</span>(x,y);x=<span class="hljs-built_in">min</span>(x,y);y=z;<span class="hljs-comment">//令x为左区间，y为右区间</span><br><span class="hljs-keyword">int</span> lenn=y-x+<span class="hljs-number">1</span>;<span class="hljs-comment">//长度</span><br><span class="hljs-keyword">int</span> yu=<span class="hljs-built_in">min</span>(f[x][kl1[lenn/<span class="hljs-number">2</span>]+<span class="hljs-number">1</span>],f[y-lenn/<span class="hljs-number">2</span>][kl1[lenn/<span class="hljs-number">2</span>]+<span class="hljs-number">1</span>]);<span class="hljs-comment">//2^(kl1[lenn/2]+1)&lt;=lenn</span><br><span class="hljs-built_in">cout</span>&lt;&lt;yu&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></details><h3 id="快捷离散化"><a href="#快捷离散化" class="headerlink" title="快捷离散化"></a>快捷离散化</h3><details><summary>代码</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 100010</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> p[maxn], a[maxn],D,n;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);</span><br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>); <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">cin</span>&gt;&gt;p[i],a[i]=p[i];<br>    sort(p+<span class="hljs-number">1</span>,p+n+<span class="hljs-number">1</span>);D=unique(p+<span class="hljs-number">1</span>,p+n+<span class="hljs-number">1</span>)-p<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)a[i]=lower_bound(p+<span class="hljs-number">1</span>,p+D+<span class="hljs-number">1</span>,a[i])-p;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-comment">//a[i]为第i个数的名次,名次为去重过后的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></details><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈一谈博弈</title>
    <link href="/2021/02/26/%E8%B0%88%E4%B8%80%E8%B0%88%E5%8D%9A%E5%BC%88/"/>
    <url>/2021/02/26/%E8%B0%88%E4%B8%80%E8%B0%88%E5%8D%9A%E5%BC%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们所研究的博弈，实际上是一种组合游戏。这是一种双人之间进行的公平的完全信息博弈,并且一定可以在有限步数内结束。<br>所以在双方都采取最优策略的前提下,一个状态要么是必胜态要么是必败态,没有第三种情况.<br>而判定必胜态和必败态最原始的方法就是:</p><ul><li>必胜态可以转移到必败态.</li><li>必败态只能转移到必胜态.</li><li>终止状态的胜负需由规则而定,多数是无法操作者败.</li></ul><p>假如把每一个状态都当作无向图中的一个点，状态和状态之间的转移为点之间的边，<br>呢么可以将这个组合游戏看作是一个有向图游戏(状态转移图)<br>在此我们引入SG函数，SG[i]=mex(i的子状态)。理解上可以把SG当作一个状态(i)的总结。<br>mex(ai)运算返回不存在于a数组中最小的非负数。(例:max(0,1,2,4,6)=3)</p><blockquote><p>我在最开始学习的时候认为SG函数以及mex运算只是为了区别0(通常设为必败态)与非0。但实际上理解后发现，<br>SG的非零取值所代表的不同状态不同。<br>并且假如一个状态的SG为i，呢么从0~i-1的状态都能同过该状态一步达到。<br>因此假如有多个游戏(也就是多个的有向图)，我们通过异或可以得到总局面的SG值。</p></blockquote><p>为什么呢，首先我们知道，对手将一个游戏转到了某种状态，你可以在其他的游戏中转到相同的状态，<br>假如你每一次都能做到相同的操作。呢么就是必胜的。<br>异或操作可以判别多种状态之间的联系，假如一个游戏和另一个游戏拥有部分相同的可以转到状态，异或操作可以将其抵消。<br>好了，我们已经学到了博弈游戏可以通过SG函数来进行推演，也了解到了SG函数的递推方式。<br>已经可以做一些凭依于SG函数的暴力DP题目了。<br>但是博弈更多的，是复杂的情况，复杂的通过SG递推方式可以完成任务但是复杂度过高(所以可以将SG递推理解成博弈里的暴力(雾))<br>（当然也有可能是需要将原问题进行转化转化成便于进行SG递推的形式(比较难。<del>不对，是非常难</del>)<br>所以更多的情况下我们需要找规律(打表)， <strong>或者总结一些泛用的博弈游戏模型：</strong></p><h3 id="巴什博奕："><a href="#巴什博奕：" class="headerlink" title="巴什博奕："></a>巴什博奕：</h3><pre><code>有n个石子，每人可以随便拿1−m个石子，不能拿的人为败者，问谁会胜利</code></pre><p>设当前的石子数为n=k∗(m+1)+r：先手会首先拿走r个，接下来假设后手拿走x个，先手会拿走m+1−x个，这样博弈下去后手最终一定失败<br>设当前的石子数为n=k∗(m+1)：假设先手拿x个，后手一定会拿m+1−x个，这样下去先手一定失败</p><h3 id="nim游戏"><a href="#nim游戏" class="headerlink" title="nim游戏"></a>nim游戏</h3><pre><code>有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利</code></pre><p>当n堆石子的数量异或和等于0时，先手必胜，否则先手必败</p><h3 id="阶梯博弈"><a href="#阶梯博弈" class="headerlink" title="阶梯博弈"></a>阶梯博弈</h3><pre><code>N个阶梯，每个阶梯上都有一定量的石子，石子只能每次从上一个阶梯移到下一个阶梯</code></pre><p>阶梯Nim只考虑奇数位置进行Nim游戏，因为假如上一次操作是偶数移到奇数位置，呢我们下一次操作就可以将上一次操作移动的再次移动到下一个偶数位置。因此偶数位置上的石子数并不影响总体。</p><h3 id="平衡博弈"><a href="#平衡博弈" class="headerlink" title="平衡博弈"></a>平衡博弈</h3><pre><code>最开始有一堆石子，每人每次可以对于一堆石子拿走k(k不大于石子个数的一半)个并将这一堆剩下的石子分为一堆或是石子数任意的两堆。当某一堆石子个数为1时可以直接拿完，问谁会胜利</code></pre><p>当n=2或3时后手必胜，其他情况都是先手必胜。<br>显然，当n为偶数时先手可取出两个并将这堆石子分成相同的两堆。当n为奇数时先手可取出三个并将这堆石子分成相同的两堆。重点是达到的两堆相等的状态。</p><h3 id="Anti-Nim游戏"><a href="#Anti-Nim游戏" class="headerlink" title="Anti-Nim游戏"></a>Anti-Nim游戏</h3><pre><code>有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，拿走最后一个石子的人失败。问谁会胜利</code></pre><p>当每堆石子都只有一个，且游戏的SG值为0，或者至少一堆石子多于一个，且游戏的SG值不为0，先手必胜。否则先手必败。</p><h3 id="Multi-Nim游戏"><a href="#Multi-Nim游戏" class="headerlink" title="Multi-Nim游戏"></a>Multi-Nim游戏</h3><pre><code>1.有n堆石子，两个人每次从任意一堆石子中拿任意多个石子(不能不拿)或把一堆石子分为两堆都不为0的石子，没法拿的人失败。问谁会胜利</code></pre><p>通过SG函数操作可以模拟，但是观察后可发现性质：</p><blockquote><p>SG(x)=x−1 (x%4 == 0)<br>SG(x)=x   (x%4 == 1||2)<br>SG(x)=x+1 (x%4 == 3)</p></blockquote><pre><code>2.有n堆石子，两个人从任意一堆石子中拿任意多个石子(不能不拿)后，可以将取的那一堆的石子 分为多堆，也可以不分，没法拿的人失败。问谁会胜利</code></pre><p>同Nim取石子游戏结论，即若n堆石子的异或和为0，则先手必败；否则，先手必胜。</p><p>Multi-SG游戏规定，在符合拓扑原则的前提下，一个单一游戏的后继可以为多个单一游戏。仍然可以使用SG函数，后继为多个单一游戏的，这个后继的SG值为多个单一游戏SG的异或和</p><h3 id="斐波那契博弈"><a href="#斐波那契博弈" class="headerlink" title="斐波那契博弈"></a>斐波那契博弈</h3><pre><code>有一堆石子，先取者可以取走任意多个，但不能全取完，以后每人取的石子数不能超过上个人的两倍</code></pre><p>先手必败，当且仅当石子数为斐波那契数（神奇</p><h3 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h3><pre><code>有两堆石子，每次每个人可以从任意一堆石子中取任意多的石子或者从两堆石子中取同样多的石子，不能取的人输，分析谁会获得胜利</code></pre><p>假设两堆石子为(x,y)（其中x&lt;y）,那么先手必败，当且仅当(y−x)∗((√5+1)/2)=x ((√5+1)/2) 其实就是1.618，比较神奇<br>证明需要Betty定理，当时看的不太懂</p><h3 id="Every-SG游戏"><a href="#Every-SG游戏" class="headerlink" title="Every-SG游戏"></a>Every-SG游戏</h3><pre><code>给定一张无向图，上面有一些棋子，每人每次必须将可以移动的棋子进行移动，不能移动的人输</code></pre><p>题目中的要求实际是“不论前面输与否，只要最后一个棋子胜利，那么就算胜利”。这样的话，能赢得游戏必须赢<br>对于Every-SG游戏先手必胜当且仅当单一游戏中最大的step为奇数。<br>定理显然：最大的单一游戏步数如果是奇数的话那么肯定是先手取得进行最后一步，否则一定是对手取走最后一个棋子。</p><h3 id="树的删边游戏"><a href="#树的删边游戏" class="headerlink" title="树的删边游戏"></a>树的删边游戏</h3><pre><code>给出一个有 N个点的树，有一个点作为树的根节点。游戏者轮流从树中删去边，删去一条边后，不与根节点相连的部分将被移走。谁无法移动谁输。</code></pre><p>结论：叶子节点的SG值为0；中间节点的SG值为它的所有子节点的SG值加1后的异或和。</p><h3 id="无向图的删边游戏"><a href="#无向图的删边游戏" class="headerlink" title="无向图的删边游戏"></a>无向图的删边游戏</h3><pre><code>一个无相联通图，有一个点作为图的根。游戏者轮流从图中删去边，删去一条边后，不与根节点相连的部分将被移走。谁无路可走谁输。</code></pre><h5 id="Fusion-Principle定理："><a href="#Fusion-Principle定理：" class="headerlink" title="Fusion Principle定理："></a>Fusion Principle定理：</h5><p>我们可以对无向图做如下改动：将图中的任意一个偶环缩成一个新点，任意一个奇环缩成一个新点加一个新边；<br>所有连到原先环上的边全部改为与新点相连。这样的改动不会影响图的SG值。<br>定理显然。将图变换后就变为树的删边游戏了</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>博弈论</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2021/01/29/test/"/>
    <url>/2021/01/29/test/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <div id="aplayer-SfDCIcbq" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-SfDCIcbq"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "ノクターンとクラゲ",              author: "まじ娘",              url: "/music/まじ娘 - ノクターンとクラゲ.mp3",              pic: "/img/}$TO9$~}PDH@C[RL4X2GLA4.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script>        <div id="aplayer-ZvXnlRdi" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-ZvXnlRdi"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "爱",              author: "https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBbHpPaENqNWFzY1BnbWtxbmU5anhJUmpQNEE3P2U9cFE3QXNw.mp3",              url: "/img/}$TO9$~}PDH@C[RL4X2GLA4.png",              pic: "",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h1 id="This-is-the-test"><a href="#This-is-the-test" class="headerlink" title="This is the test"></a>This is the test</h1><h1 id="my-first-blog"><a href="#my-first-blog" class="headerlink" title="my first blog"></a>my first blog</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">代码框部分<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/xrblog/p/11585885.html">超链接</a>部分(指向的是帮助我搭好的blog)</p><p><img src="https://s2.ax1x.com/2019/01/21/kPlYAP.jpg" alt="添加的图片，也是感慨" title="千万别！"></p><iframe class="iframe_video" src="//player.bilibili.com/player.html?aid=286901759&bvid=BV1yf4y1Q7db&cid=230911902&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><a href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://linzeyin.github.io/2021/01/29/test/&amp;showcount=1&amp;desc=这是一个测试文件&amp;summary=这是测试文件的分享&amp;title=测试文件的标题&amp;pics=https://s2.ax1x.com/2019/01/21/kPlYAP.jpg&amp;style=203&amp;width=98&amp;height=22">分享测试</a></p><blockquote><p>测试完了，去水去了。<br><del>老懒癌了</del></p></blockquote><p><脚本 src = “ https://utteranc.es/client.js ” repo = “ [在此处输入回车] ” issue-term = “ pathname ”主题= “ github-light ” crossorigin = “匿名”异步> </>    </p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>testfile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ccpc 2016 C</title>
    <link href="/2020/11/26/ccpc2016C%20Hdu5963/"/>
    <url>/2020/11/26/ccpc2016C%20Hdu5963/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>B君在围观一群男生和一群女生玩游戏，具体来说游戏是这样的：</p><blockquote><p>给出一棵n个节点的树，这棵树的每条边有一个权值，这个权值只可能是0或1。 在一局游戏开始时，会确定一个节点作为根。接下来从女生开始，双方轮流进行 操作。<br>当一方操作时，他们需要先选择一个不为根的点，满足该点到其父亲的边权为1; 然后找出这个点到根节点的简单路径，将路径上所有边的权值翻转（即0变成1，1 变成0 )。<br>当一方无法操作时(即所有边的边权均为0)，另一方就获得了胜利。<br>如果在双方均采用最优策略的情况下，女生会获胜，则输出“Girls win!”，否则输 出“Boys win!”。</p></blockquote><p>为了让游戏更有趣味性，在每局之间可能会有修改边权的操作，而且每局游戏指 定的根节点也可能是不同的。<br>具体来说，修改边权和进行游戏的操作一共有m个，具体如下：</p><blockquote><p>“0 x”表示询问对于当前的树，如果以x为根节点开始游戏，哪方会获得胜利。<br>“1 x y z ”表示将x和y之间的边的边权修改为z。<br>B君当然知道怎么做啦！但是他想考考你。</p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>包含至多5组测试数据。<br>第一行有一个正整数，表示数据的组数。<br>接下来每组数据第一行，有二个空格隔开的正整数n,m，分别表示点的个数，操 作个数。保证 <strong><em>n,m&lt; 40000</em></strong>。<br>接下来n-1行，每行三个整数x,y,z，表示树的一条边。保证 <strong><em>1 &lt; x &lt; n , 1 &lt; y &lt; n, 0 &lt;= z &lt;= 1。</em></strong><br>接下来m行，每行一个操作，含义如前所述。保证一定只会出现前文中提到的两 种格式。<br>对于操作0，保证 <strong><em>1 &lt;= x &lt;= n ;</em></strong> 对于操作1，保证 <strong><em>1 &lt;= x &lt;= n, 1 &lt;= y &lt;= n, 0 &lt;= z &lt;= 1</em></strong>，保证树上存在一条边连接x和y。</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>对于每组数据的每一个询问操作，输出一行“Boys win!”或者“Girls win!”。</p><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre><code>22 31 2 00 11 2 1 10 24 111 2 12 3 13 4 00 10 20 30 41 2 1 00 10 20 31 3 4 10 30 4</code></pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><pre><code>Boys win!Girls win!Girls win!Boys win!Girls win!Boys win!Boys win!Girls win!Girls win!Boys win!Girls win! </code></pre><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>昨天刚刚简单了解了博弈论，虽然看出来了可是却不知道怎么处理，想着将没一条支链的01串怎么抑或成NIM的样子，但实际上完全想偏了<br>正解应该是：对于每个询问的root，我们看它的儿子，如果有一个儿子到root的权值为1，那么先手可以把它翻转，<br>那么后手如果在子树里选，那么这个边肯定要重新被翻转为1，那么先手就一直处于不败。综合考虑所有的root的儿子，<br>也就是看看权值为1的边有多少个，如果有奇数个那么就说明先手必胜，否则后手必胜。<br>可能有着用sg函数的解法或证明，但是连这个都想不到的林泽音就别扯证明了<br><strong>开拓思路，找到子问题，找到必败点，之后向上延申</strong>，这是这一道题目教给我的</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>博弈论</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
      <tag>博弈</tag>
      
      <tag>ccpc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算基础</title>
    <link href="/2020/07/19/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2020/07/19/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>概述：<br>从现代计算机中所有的数据二进制的形式存储在设备中。即0、1两种状态，计算机对 二进制数据 进行的运算都是叫位运算，即将符号位共同参与运算的运算。</p><blockquote><p>比如<br>int a = 35;<br>int b = 47;<br>int c = a + b;<br>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加：<br>35:  0 0 1 0 0 0 1 1<br>47:  0 0 1 0 1 1 1 1<br>————————————————————<br>82:  0 1 0 1 0 0 1 0<br>位运算符直接对二进制的每一位进行操作（所以应该大概好像要快呢么一点点），同时也可以大大简便一些复杂的数位操作。</p></blockquote></blockquote><hr><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p><strong>与        两个位都为1时，结果才为1</strong> </p><blockquote><p>比如：0&amp;0=0  0&amp;1=0  1&amp;0=0  1&amp;1=1</p></blockquote><p>用途<br>(1)lowbit(n)   用于计算n的二进制表示中最低位1出现的位置：   <code>int lowbit(int n)&#123;return n&amp;(-n);&#125;</code><br>(2)计算n的二进制表示中又几个1：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> numOfOne(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)<br>&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>=<span class="hljs-number">0</span>;<br>    for(<span class="hljs-built_in">count</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">n</span>!=<span class="hljs-number">0</span>;<span class="hljs-built_in">n</span>=<span class="hljs-built_in">n</span>&amp;(<span class="hljs-built_in">n</span>-<span class="hljs-number">1</span>))<span class="hljs-built_in">count</span>++;<br>    return <span class="hljs-built_in">count</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>(当然，也有另一种方式： </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> numOfOne(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)<br>&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>=<span class="hljs-number">0</span>;<br>    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">32</span>;i++)<br>    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">n</span>&gt;&gt;i&amp;<span class="hljs-number">1</span>) <br>    <span class="hljs-built_in">count</span>++;<br>    return <span class="hljs-built_in">count</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>(3)可以用来截取n的最低几位(本质上可以求任何位数，重点是常数的查找)</p><blockquote><p>如:    n&amp;0177  (截取最低7位） n&amp;077（截取最低六位）</p></blockquote><hr><h3 id=""><a href="#" class="headerlink" title="|"></a>|</h3><p><strong>或        两个位都为0时，结果才为0    比如：0|0=0  0|1=1  1|0=1  1|1=1</strong><br>    用途   （1） 将n的二进制中的某几位置1  如： n=n | 017  （将低4位置1）<br>            (2)  取n的二进制位0的个数（高位补0)<br>                <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> numOfZero(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)<br>&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>=<span class="hljs-number">0</span>;<br>    for(;<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>;<span class="hljs-built_in">count</span>++,<span class="hljs-built_in">n</span>=<span class="hljs-built_in">n</span>|(<span class="hljs-built_in">n</span>+<span class="hljs-number">1</span>));<br>    return <span class="hljs-built_in">count</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>                (当然，也有另一种方式：<br>                <figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">int</span> numOfZero(<span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span>)<br>&#123;<br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">count</span>=<span class="hljs-number">0</span>;<br>    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">32</span>;i++)<br>        <span class="hljs-built_in">if</span>(!(<span class="hljs-built_in">n</span>&gt;&gt;i&amp;<span class="hljs-number">1</span>))<br>            <span class="hljs-built_in">count</span>++;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><hr><h3 id="-1"><a href="#-1" class="headerlink" title="^"></a>^</h3><p><strong>异或    两个位相同为0，相异为1      比如：0^0=0  0^1=1  1^0=1  1^1=0</strong></p><blockquote><p>性质:<br>1、交换律   <code>a^b=b^a</code><br>2、结合律 <code>(a^b)^c=a^(b^c)</code><br>3、对于任何数x，都有 <code>x^x=0，x^0=x</code><br>4、自反性: <code>a^b^b=a^0=a;</code></p></blockquote><p>用途<br>    1）翻转指定位    比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。<br>    2）与0相异或值不变    例如：1010 1110 ^ 0000 0000 = 1010 1110<br>    3)将两个数翻转  <code>void Swap(int &amp;a, int &amp;b)&#123;a ^= b;b ^= a;a ^= b;&#125;</code></p><hr><h3 id="-2"><a href="#-2" class="headerlink" title="~"></a>~</h3><p><strong>取反    0变1，1变0</strong><br>    用途   生成与系统无关的常数（好吧这其实感觉没多大用但还是说一下？</p><blockquote><p>如：n=n&amp;(~077)       将n的最低六位置0  (077二进制表示为111111）</p></blockquote><p>符号：<code>&lt;&lt;</code>    左移    各二进位全部左移若干位，高位丢弃，低位补0,相当于乘上了二</p><p>符号：<code>&gt;&gt;</code>    右移    各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</p><h3 id="bitset拓展"><a href="#bitset拓展" class="headerlink" title="bitset拓展"></a>bitset拓展</h3><p>头文件： <code>#include&lt;bitset&gt;</code><br>bitset是一种储存空间极小的东西。定义时就可以定义该数所占用的空间。<br>比如 <code>bitset&lt;45&gt;bit;</code>就是定义一个45位的bitsat类型。占用空间为45bit，它即能表示一个数，也能表示一个45位的2进制数。<br>可以用string类型赋初值： <code>bitset&lt;45&gt;bit (string(&quot;10111&quot;));</code><br>也可以用整形赋初值：<code>bitset&lt;45&gt;bit (23);</code><br>bitset的一些常用函数<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">bit</span>.<span class="hljs-built_in">size</span>()       返回大小（位数）<br><span class="hljs-built_in">bit</span>.count()     返回<span class="hljs-number">1</span>的个数<br><span class="hljs-built_in">bit</span>.any()       返回是否有<span class="hljs-number">1</span><br><span class="hljs-built_in">bit</span>.none()      返回是否没有<span class="hljs-number">1</span><br><span class="hljs-built_in">bit</span>.<span class="hljs-built_in">set</span>()       全都变成<span class="hljs-number">1</span><br><span class="hljs-built_in">bit</span>.<span class="hljs-built_in">set</span>(p)      将第p + <span class="hljs-number">1</span>位变成<span class="hljs-number">1</span>（<span class="hljs-built_in">bitset</span>是从第<span class="hljs-number">0</span>位开始的！） <br><span class="hljs-built_in">bit</span>.<span class="hljs-built_in">set</span>(p, x)   将第p + <span class="hljs-number">1</span>位变成x<br><span class="hljs-built_in">bit</span>.reset()     全都变成<span class="hljs-number">0</span><br><span class="hljs-built_in">bit</span>.reset(p)    将第p + <span class="hljs-number">1</span>位变成<span class="hljs-number">0</span><br><span class="hljs-built_in">bit</span>.flip()      全都取反<br><span class="hljs-built_in">bit</span>.flip(p)     将第p + <span class="hljs-number">1</span>位取反<br><span class="hljs-built_in">bit</span>.to_ulong()  返回它转换为<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>的结果，如果超出范围则报错<br><span class="hljs-built_in">bit</span>.to_ullong() 返回它转换为<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>的结果，如果超出范围则报错<br><span class="hljs-built_in">bit</span>.to_string() 返回它转换为<span class="hljs-built_in">string</span>的结果<br></code></pre></td></tr></table></figure></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>位运算</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>acm</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树型DP入门 最大利润</title>
    <link href="/2017/07/26/%E6%A0%91%E5%BD%92_%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"/>
    <url>/2017/07/26/%E6%A0%91%E5%BD%92_%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>政府邀请了你在火车站开饭店，但不允许同时在两个相连接的火车站开。任意两个火车站有且只有一条路径，每个火车站最多有50个和它相连接的火车站。<br>告诉你每个火车站的利润，问你可以获得的最大利润为多少。</p></blockquote><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><p>第一行输入整数N(&lt;=100000)，表示有N个火车站，分别用1，2。。。，N来编号。接下来N行，每行一个整数表示每个站点的利润，接下来N-1行描述火车站网络，每行两个整数，表示相连接的两个站点。 </p><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><p>输出一个整数表示可以获得的最大利润。</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>6<br>10<br>20<br>25<br>40<br>30<br>30<br>4 5<br>1 3<br>3 4<br>2 3<br>6 4</p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>90</p></blockquote><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>由于任意两个火车站有且只有一条路径，所以我们可以把其看做一棵树，每一个节点的状态是由其父亲节点决定，如果其父亲有饭店，呢就有一种选择，反之，就有两种选择；</p><p>我们可以开两个数组：F[i]与G[i]，分别表示第i个节点有饭店与无饭店所得的最优值，由此列出状态转移方程：<br>$ F[X]=\sum<em>{i=1}^n G[y_i] $<br>$ G[i]= \sum</em>{i=1}^n max(F[y_i],G[y_i])  (y_i是X的儿子) $</p><p>实现时用DFS去实现，每个点只需求一次，所以时间复杂度为O(N)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ss</span>&#123;</span><br><span class="hljs-keyword">int</span> y,next;<br>&#125;e[<span class="hljs-number">200001</span>];<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> Link[<span class="hljs-number">100001</span>],tot=<span class="hljs-number">0</span>,a[<span class="hljs-number">100001</span>],b[<span class="hljs-number">100001</span>]=&#123;&#125;,F[<span class="hljs-number">100001</span>]=&#123;&#125;,G[<span class="hljs-number">100001</span>]=&#123;&#125;;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> xx,<span class="hljs-keyword">int</span> yy)</span></span><br><span class="hljs-function"></span>&#123;<br>e[++tot].next=Link[xx];e[tot].y=yy;Link[xx]=tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> x,y;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>insert(x,y);<br>insert(y,x);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> child,<span class="hljs-keyword">int</span> father)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=Link[child];i!=<span class="hljs-number">0</span>;i=e[i].next)<br>&#123;<br><span class="hljs-keyword">if</span>(e[i].y!=father)<br>&#123;<br>dfs(e[i].y,child);<br>F[child]+=G[e[i].y];<br>G[child]+=<span class="hljs-built_in">max</span>(F[e[i].y],G[e[i].y]);<br>&#125;<br>&#125;<br>F[child]+=a[child];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-built_in">memset</span>(e,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(e));<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">cin</span>&gt;&gt;a[i];<br>init();<br>dfs(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">max</span>(F[<span class="hljs-number">1</span>],G[<span class="hljs-number">1</span>])&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>高中</tag>
      
      <tag>树型DP</tag>
      
      <tag>树上操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论题目 加等运算</title>
    <link href="/2017/07/15/%E6%95%B0%E8%AE%BA_%E5%8A%A0%E7%AD%89%E8%BF%90%E7%AE%97/"/>
    <url>/2017/07/15/%E6%95%B0%E8%AE%BA_%E5%8A%A0%E7%AD%89%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>现在给你两个变量 x和y。x和y的初值都是1.<br>你每次可以选择 x=x+y;运行一次，也可以选择 y=x+y运行一次。<br>给定一个整数N，问你最少经过几次加等运算，可以让x变量里存着整数N，y变量的值可以随意。每次操作以赋值号左边的变量命名。<br>当然，操作步骤可能有很多种方法，你必须输出字典序最小的方案。<br>比如3.你可以执行一次 y=x+y; 再执行一次 x=x+y; 这样输出方案是 YX.<br>你也可以执行两次 x=x+y; 这样输出方案是XX.<br>当然字典序最小的是 XX</p></blockquote><h3 id="输入格式-Input-Format"><a href="#输入格式-Input-Format" class="headerlink" title="输入格式 Input Format"></a>输入格式 Input Format</h3><p>一个整数N。表示加法要得到的结果。<br>20%数据保证，N&lt;=100<br>50%的数据保证，N&lt;=10000<br>100%的数据保证，2&lt;=N&lt;=1000000</p><h3 id="输出格式-Output-Format"><a href="#输出格式-Output-Format" class="headerlink" title="输出格式 Output Format"></a>输出格式 Output Format</h3><p>一个字符串，表示字典序最小的输出方案。</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote><p>10</p></blockquote><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote><p>XXYYX</p></blockquote><hr><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>设最后x=n，y=t，<br>呢么前n/t步操作肯定是X操作，<br>前n/t步之前的状态就是x=n%t , y=t,<br>我们已知最初x=1 y=1;<br>且X,Y操作也就是辗转相除的过程。</p><p>枚举y的值然后模拟辗转相除记录过程即可。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">string</span> s1,s2;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>&amp;&amp;a==<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(b&lt;<span class="hljs-number">1</span>||a&lt;<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(a&gt;=b)<br>&#123;<br>s1+=<span class="hljs-string">&#x27;X&#x27;</span>;<br><span class="hljs-keyword">return</span> gcd(a-b,b);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>s1+=<span class="hljs-string">&#x27;Y&#x27;</span>;<br><span class="hljs-keyword">return</span> gcd(a,b-a);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>s2+=<span class="hljs-string">&quot;YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY&quot;</span>;<br><span class="hljs-keyword">int</span> x,y,n,k;<br><span class="hljs-built_in">cin</span>&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br>x=n%i;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n/i;j++)<br>s1+=<span class="hljs-string">&#x27;X&#x27;</span>;<br>y=i;<br><span class="hljs-keyword">if</span>(gcd(x,y)==<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&lt;s2.<span class="hljs-built_in">size</span>())<br>&#123;<br>s2.<span class="hljs-built_in">clear</span>();<br>s2+=s1;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()==s2.<span class="hljs-built_in">size</span>())<br>&#123;<br>k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=s1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<br>&#123;<br><span class="hljs-keyword">if</span>(s1[j]==<span class="hljs-string">&#x27;X&#x27;</span>&amp;&amp;s2[j]==<span class="hljs-string">&#x27;Y&#x27;</span>)<br>&#123;<br>k=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(s1[j]==<span class="hljs-string">&#x27;Y&#x27;</span>&amp;&amp;s2[j]==<span class="hljs-string">&#x27;X&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;endl;</span><br>s2.<span class="hljs-built_in">clear</span>();<br>s2+=s1;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//cout&lt;&lt;s1&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;endl;</span><br>&#125;<br>s1.<span class="hljs-built_in">clear</span>();<br><span class="hljs-comment">//cout&lt;&lt;i&lt;&lt;endl;</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br><span class="hljs-built_in">cout</span>&lt;&lt;s2[i];<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
      <category>题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
      <tag>高中</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
