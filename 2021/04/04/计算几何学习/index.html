

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  

  <link rel="stylesheet" href="https://api.beixibaobao.com/css/bilibili-player/bofangqi.css">
 

  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="计算几何研究的对象是二维平面上的图形，将图形转换成函数然后用数学方法解析。">
  
  <meta name="author" content="emmm. . .Lzy?">
  <meta name="keywords" content="">
  
  <title>计算几何学习(待完善) - Lin</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/iconfont_train/iconfont.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>




<body>
<!--彩带1.点击自动替换彩带-->
  
    <!-- <script src="https://g.joyinshare.com/hc/ribbon.min.js" type="text/javascript"></script> -->
    <script type="text/javascript" src="/js/ribbon.js"></script>
  

  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Lin</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                文章
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/">
                    <i class="iconfont icon-archive-fill"></i>
                    归档
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" target="_blank" rel="noopener" href="https://linzeyin.github.io/2021/03/05/%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%8E%86%E7%A8%8B(%E8%AE%B0%E5%BD%95%E5%90%91)/">
                    <i class="iconfont icon-note"></i>
                    博客日志
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/album/">
                <i class="iconfont icon-images"></i>
                相册
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://travellings.link">
                <i class="iconfont icon-train"></i>
                开往
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/update/">
                <i class="iconfont icon-exp-fill"></i>
                施工
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/asdfvcxbrthrtz.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="计算几何学习(待完善)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-04 15:47" pubdate>
        2021年4月4日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      79
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算几何学习(待完善)</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年9月18日 上午
                
              </p>
            
            <div class="markdown-body">
              <p>今日补完了昆明站赛站，自告奋勇接下了两题结果卡在了计算几何上，以为自己有着模板就直接上了，结果一直卡在段错误，因此决定这周进行计算几何专题的专门练习。<br>其实这些内容在寒假也学了一些，当时主要是入了计算机图形学的坑，玩OpenGL的时候顺便补了点计几。当时也找到了很多的blog进行学习，并且学习了大佬的代码风格(因为感觉这样写好棒).这里的内容主要还是把平常的几何知识封装以下，所以除了一些思维上的新东西应该都只有板子。</p>
<hr>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="建点"><a href="#建点" class="headerlink" title="建点"></a>建点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LD double</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Vector Point</span><br><span class="hljs-keyword">const</span> LD eps=<span class="hljs-number">1e-8</span>;<span class="hljs-comment">//精度差</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dcmp</span><span class="hljs-params">(LD a)</span></span>&#123;<span class="hljs-keyword">return</span> a&lt;-eps?<span class="hljs-number">-1</span>:(a&gt;eps?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);&#125;<span class="hljs-comment">//处理精度</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> LD <span class="hljs-title">ABS</span><span class="hljs-params">(LD a)</span></span>&#123;<span class="hljs-keyword">return</span> a*dcmp(a);&#125;<span class="hljs-comment">//取绝对值</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span>&#123;</span><span class="hljs-comment">//名字是点，但实际上向量也是一样的用法</span><br>    LD x,y;Point(LD X=<span class="hljs-number">0</span>,LD Y=<span class="hljs-number">0</span>)&#123;x=X,y=Y;&#125;<span class="hljs-comment">//为点赋初值</span><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">in</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf%lf&quot;</span>,&amp;x,&amp;y);&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">out</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf %.2lf\n&quot;</span>,x,y);&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><h4 id="模长"><a href="#模长" class="headerlink" title="模长"></a>模长</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline LD <span class="hljs-constructor">Len(Vector <span class="hljs-params">a</span>)</span>&#123;return sqrt(<span class="hljs-constructor">Dot(<span class="hljs-params">a</span>,<span class="hljs-params">a</span>)</span>);&#125;<br></code></pre></td></tr></table></figure>
<h4 id="点积-amp-amp-叉积"><a href="#点积-amp-amp-叉积" class="headerlink" title="点积&amp;&amp;叉积"></a>点积&amp;&amp;叉积</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">inline LD Dot(Vector <span class="hljs-selector-tag">a</span>,Vector <span class="hljs-selector-tag">b</span>)&#123;return <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.x</span>*<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.x</span>+<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.y</span>*<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.y</span>;&#125;//点积<br>inline LD Cro(Vector <span class="hljs-selector-tag">a</span>,Vector <span class="hljs-selector-tag">b</span>)&#123;return <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.x</span>*<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.y-a</span><span class="hljs-selector-class">.y</span>*<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.x</span>;&#125;//叉积<br></code></pre></td></tr></table></figure>
<h4 id="求法线"><a href="#求法线" class="headerlink" title="求法线"></a>求法线</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Vector <span class="hljs-constructor">Normal_line(Vector <span class="hljs-params">a</span>)</span> &#123;double len=<span class="hljs-constructor">Len(<span class="hljs-params">a</span>)</span>;return <span class="hljs-constructor">Vector(-<span class="hljs-params">a</span>.<span class="hljs-params">y</span><span class="hljs-operator">/</span><span class="hljs-params">len</span>,<span class="hljs-params">a</span>.<span class="hljs-params">x</span><span class="hljs-operator">/</span><span class="hljs-params">len</span>)</span>;&#125;<span class="hljs-comment">//求向量A的单位法线</span><br></code></pre></td></tr></table></figure>
<h4 id="求夹角"><a href="#求夹角" class="headerlink" title="求夹角"></a>求夹角</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">inline LD Angle(Vector <span class="hljs-selector-tag">a</span>,Vector <span class="hljs-selector-tag">b</span>) &#123;return acos(Dot(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>)/len(<span class="hljs-selector-tag">a</span>)/len(<span class="hljs-selector-tag">b</span>));&#125;<br></code></pre></td></tr></table></figure>
<h3 id="位置变换"><a href="#位置变换" class="headerlink" title="位置变换"></a>位置变换</h3><h4 id="向量位移重载运算符直接加减-amp-amp-数乘"><a href="#向量位移重载运算符直接加减-amp-amp-数乘" class="headerlink" title="向量位移重载运算符直接加减&amp;&amp;数乘"></a>向量位移重载运算符直接加减&amp;&amp;数乘</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Vector operator+(Vector a,Vector b)&#123;return <span class="hljs-constructor">Vector(<span class="hljs-params">a</span>.<span class="hljs-params">x</span>+<span class="hljs-params">b</span>.<span class="hljs-params">x</span>,<span class="hljs-params">a</span>.<span class="hljs-params">y</span>+<span class="hljs-params">b</span>.<span class="hljs-params">y</span>)</span>;&#125;<br>inline Vector operator-(Vector a,Vector b)&#123;return <span class="hljs-constructor">Vector(<span class="hljs-params">a</span>.<span class="hljs-params">x</span>-<span class="hljs-params">b</span>.<span class="hljs-params">x</span>,<span class="hljs-params">a</span>.<span class="hljs-params">y</span>-<span class="hljs-params">b</span>.<span class="hljs-params">y</span>)</span>;&#125;<br>inline Vector operator*(Vector a,LD b)&#123;return <span class="hljs-constructor">Vector(<span class="hljs-params">a</span>.<span class="hljs-params">x</span><span class="hljs-operator">*</span><span class="hljs-params">b</span>,<span class="hljs-params">a</span>.<span class="hljs-params">y</span><span class="hljs-operator">*</span><span class="hljs-params">b</span>)</span>;&#125;<br></code></pre></td></tr></table></figure>
<h4 id="点-amp-amp-向量旋转"><a href="#点-amp-amp-向量旋转" class="headerlink" title="点&amp;&amp;向量旋转"></a>点&amp;&amp;向量旋转</h4><p>将向量顺时针旋转$\theta$角度(点的话是绕原点旋转)，相当于乘上了个旋转矩阵。<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sas">inline Point turn_P(Point a,LD theta)&#123;//点A\向量A顺时针旋转theta(弧度)<br>    LD <span class="hljs-meta">x</span>=a.<span class="hljs-meta">x</span><span class="hljs-meta">*cos(</span>theta)+a.y<span class="hljs-meta">*sin(</span>theta);<br>    LD y=-a.<span class="hljs-meta">x</span><span class="hljs-meta">*sin(</span>theta)+a.y<span class="hljs-meta">*cos(</span>theta);<br>    <span class="hljs-meta">return</span><span class="hljs-meta"> Point(</span><span class="hljs-meta">x</span>,y);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="点绕点旋转"><a href="#点绕点旋转" class="headerlink" title="点绕点旋转"></a>点绕点旋转</h4><p>点绕点旋转，实际上可以看作是先平移坐标系把中心点平移到原点的位置，然后点绕原点旋转后再平移回去<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sas">inline Point turn_PP(Point a,Point b,LD theta)&#123;//将点A绕点B顺时针旋转theta(弧度)<br>    LD <span class="hljs-meta">x</span>=(a.<span class="hljs-meta">x</span>-b.<span class="hljs-meta">x</span>)<span class="hljs-meta">*cos(</span>theta)+(a.y-b.y)<span class="hljs-meta">*sin(</span>theta)+b.<span class="hljs-meta">x</span>;<br>    LD y=-(a.<span class="hljs-meta">x</span>-b.<span class="hljs-meta">x</span>)<span class="hljs-meta">*sin(</span>theta)+(a.y-b.y)<span class="hljs-meta">*cos(</span>theta)+b.y;<br>    <span class="hljs-meta">return</span><span class="hljs-meta"> Point(</span><span class="hljs-meta">x</span>,y);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="点与线"><a href="#点与线" class="headerlink" title="点与线"></a>点与线</h3><h4 id="判断点是否在线段上"><a href="#判断点是否在线段上" class="headerlink" title="判断点是否在线段上"></a>判断点是否在线段上</h4><p>点若在线段上，呢么其与线段上两端点的夹角为180度，其叉积为0，点积不大于0<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> pan<span class="hljs-constructor">_PL(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//判断点P是否在线段AB上</span><br>    <span class="hljs-keyword">if</span>(a==b)return <span class="hljs-literal">false</span>;<span class="hljs-comment">//AB重合，线段不存在</span><br>    return !dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>,<span class="hljs-params">b</span>-<span class="hljs-params">a</span>)</span>)&amp;&amp;dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>,<span class="hljs-params">p</span>-<span class="hljs-params">b</span>)</span>)&lt;=<span class="hljs-number">0</span>;<span class="hljs-comment">//注意，根据icpc2021昆明i题发现，由于求交点时本身就会产生精度误差，使用叉积来判断向量平行不再放宽精度则会放大此误差，因此假如已经确定点在线段所在的直线上后可以根据需要去除第一个条件 </span><br>    <span class="hljs-comment">//return dcmp(Dot(p-a,p-b))&lt;=0; </span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="判断点是否在直线上"><a href="#判断点是否在直线上" class="headerlink" title="判断点是否在直线上"></a>判断点是否在直线上</h4><p>点若在直线上，呢么就只剩下与直线上任意两其他点的叉积为0，无点积约束<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> pan<span class="hljs-constructor">_PL_(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//判断点P是否在线段AB上</span><br>    return !dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>,<span class="hljs-params">b</span>-<span class="hljs-params">a</span>)</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="点到线段AB距离"><a href="#点到线段AB距离" class="headerlink" title="点到线段AB距离"></a>点到线段AB距离</h4><p>假如点与线段的垂线不在线段上，返回与最近的端点之间的距离。若是在线段上，呢么用与两端点围成三角形的面积除以底边长来算，运用了两向量叉积的数值等于两向量组成的平行四边形的面积的性质。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> operator==(Point a,Point b)&#123;return !dcmp(a.x-b.x)&amp;&amp;!dcmp(a.y-b.y);&#125;<span class="hljs-comment">//判断点的相等</span><br>inline LD dis<span class="hljs-constructor">_PL(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//点P到线段AB距离</span><br>    <span class="hljs-keyword">if</span>(a==b)return <span class="hljs-constructor">Len(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>)</span>;<span class="hljs-comment">//AB重合</span><br>    Vector x=p-a,y=p-b,z=b-a;<br>    <span class="hljs-keyword">if</span>(dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">x</span>,<span class="hljs-params">z</span>)</span>)&lt;<span class="hljs-number">0</span>)return <span class="hljs-constructor">Len(<span class="hljs-params">x</span>)</span>;<span class="hljs-comment">//P距离A更近</span><br>    <span class="hljs-keyword">if</span>(dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">y</span>,<span class="hljs-params">z</span>)</span>)&gt;<span class="hljs-number">0</span>)return <span class="hljs-constructor">Len(<span class="hljs-params">y</span>)</span>;<span class="hljs-comment">//P距离B更近</span><br>    return <span class="hljs-constructor">Abs(Cro(<span class="hljs-params">x</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Len(<span class="hljs-params">z</span>)</span>);<span class="hljs-comment">//面积除以底边长</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="点到直线AB距离"><a href="#点到直线AB距离" class="headerlink" title="点到直线AB距离"></a>点到直线AB距离</h4><p>到直线的距离就不用判断端点了<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> operator==(Point a,Point b)&#123;return !dcmp(a.x-b.x)&amp;&amp;!dcmp(a.y-b.y);&#125;<span class="hljs-comment">//判断点的相等</span><br>inline LD dis<span class="hljs-constructor">_PL_(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//点P到线段AB距离</span><br>    <span class="hljs-keyword">if</span>(a==b)return <span class="hljs-constructor">Len(<span class="hljs-params">p</span>-<span class="hljs-params">a</span>)</span>;<span class="hljs-comment">//AB重合</span><br>    Vector x=p-a,y=p-b,z=b-a;<br>    return <span class="hljs-constructor">Abs(Cro(<span class="hljs-params">x</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Len(<span class="hljs-params">z</span>)</span>);<span class="hljs-comment">//面积除以底边长</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="返回点到直线AB的垂足"><a href="#返回点到直线AB的垂足" class="headerlink" title="返回点到直线AB的垂足"></a>返回点到直线AB的垂足</h4><p>求出垂足到a，a到b的长度的比例，然后加到a点上即可。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Point <span class="hljs-constructor">Foot_PL(Point <span class="hljs-params">p</span>,Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>)</span>&#123;<span class="hljs-comment">//点P到直线AB的垂足</span><br>    Vector x=p-a,y=p-b,z=b-a;<br>    LD len1=<span class="hljs-constructor">Dot(<span class="hljs-params">x</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Len(<span class="hljs-params">z</span>)</span>,len2=-<span class="hljs-number">1.0</span>*<span class="hljs-constructor">Dot(<span class="hljs-params">y</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Len(<span class="hljs-params">z</span>)</span>;<span class="hljs-comment">//分别计算AP,BP在AB,BA上的投影</span><br>    return a+z*(len1/(len1+len2));<span class="hljs-comment">//点A加上向量AF</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="返回点P关于AB的对称点"><a href="#返回点P关于AB的对称点" class="headerlink" title="返回点P关于AB的对称点"></a>返回点P关于AB的对称点</h4><p>将点p到垂足的距离延长一倍即可<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">inline Point Symmetry_PL(Point <span class="hljs-selector-tag">p</span>,Point <span class="hljs-selector-tag">a</span>,Point <span class="hljs-selector-tag">b</span>)&#123;//点<span class="hljs-selector-tag">P</span>关于直线AB的对称点<br>    return <span class="hljs-selector-tag">p</span>+(Foot_PL(<span class="hljs-selector-tag">p</span>,<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>)-<span class="hljs-selector-tag">p</span>)*<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="线与线"><a href="#线与线" class="headerlink" title="线与线"></a>线与线</h3><h4 id="求两直线交点"><a href="#求两直线交点" class="headerlink" title="求两直线交点"></a>求两直线交点</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Point cross<span class="hljs-constructor">_LL(Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>,Point <span class="hljs-params">c</span>,Point <span class="hljs-params">d</span>)</span>&#123;<span class="hljs-comment">//两直线AB,CD的交点</span><br>    Vector x=b-a,y=d-c,z=a-c;<br>    return a+x*(<span class="hljs-constructor">Cro(<span class="hljs-params">y</span>,<span class="hljs-params">z</span>)</span>/<span class="hljs-constructor">Cro(<span class="hljs-params">x</span>,<span class="hljs-params">y</span>)</span>);<span class="hljs-comment">//点A加上向量AF</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="判断直线AB与线段CD是否相交"><a href="#判断直线AB与线段CD是否相交" class="headerlink" title="判断直线AB与线段CD是否相交"></a>判断直线AB与线段CD是否相交</h4><p>实际上就是看直线与线段所在的直线交点是否在线段上<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> pan<span class="hljs-constructor">_cross_L_L(Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>,Point <span class="hljs-params">c</span>,Point <span class="hljs-params">d</span>)</span>&#123;<span class="hljs-comment">//判断直线AB与线段CD是否相交</span><br>    return pan<span class="hljs-constructor">_PL(<span class="hljs-params">cross_LL</span>(<span class="hljs-params">a</span>,<span class="hljs-params">b</span>,<span class="hljs-params">c</span>,<span class="hljs-params">d</span>)</span>,c,d);<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="判断两线段是否相交"><a href="#判断两线段是否相交" class="headerlink" title="判断两线段是否相交"></a>判断两线段是否相交</h4><p>若是端点在另一条直线上直接返回true，不在的话根据叉积的性质来判定，一个线段两端点端点和另一个线段的两端点组成的向量叉积假如符号相同的话就代表在同一侧.<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> pan<span class="hljs-constructor">_cross_LL(Point <span class="hljs-params">a</span>,Point <span class="hljs-params">b</span>,Point <span class="hljs-params">c</span>,Point <span class="hljs-params">d</span>)</span>&#123;<span class="hljs-comment">//判断两线段AB,CD是否相交</span><br>    <span class="hljs-keyword">if</span>(pan<span class="hljs-constructor">_PL(<span class="hljs-params">a</span>,<span class="hljs-params">c</span>,<span class="hljs-params">d</span>)</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span>pan<span class="hljs-constructor">_PL(<span class="hljs-params">b</span>,<span class="hljs-params">c</span>,<span class="hljs-params">d</span>)</span><span class="hljs-operator">||</span>pan<span class="hljs-constructor">_PL(<span class="hljs-params">c</span>,<span class="hljs-params">a</span>,<span class="hljs-params">b</span>)</span><span class="hljs-operator">||</span>pan<span class="hljs-constructor">_PL(<span class="hljs-params">d</span>,<span class="hljs-params">a</span>,<span class="hljs-params">b</span>)</span>)return <span class="hljs-literal">true</span>;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">LD</span> c1=<span class="hljs-constructor">Cro(<span class="hljs-params">b</span>-<span class="hljs-params">a</span>,<span class="hljs-params">c</span>-<span class="hljs-params">a</span>)</span>,c2=<span class="hljs-constructor">Cro(<span class="hljs-params">b</span>-<span class="hljs-params">a</span>,<span class="hljs-params">d</span>-<span class="hljs-params">a</span>)</span>;</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">LD</span> d1=<span class="hljs-constructor">Cro(<span class="hljs-params">d</span>-<span class="hljs-params">c</span>,<span class="hljs-params">a</span>-<span class="hljs-params">c</span>)</span>,d2=<span class="hljs-constructor">Cro(<span class="hljs-params">d</span>-<span class="hljs-params">c</span>,<span class="hljs-params">b</span>-<span class="hljs-params">c</span>)</span>;</span><br><span class="hljs-pattern-match">    return dcmp(c1)<span class="hljs-operator">*</span>dcmp(c2)&lt;0<span class="hljs-operator">&amp;&amp;</span>dcmp(d1)<span class="hljs-operator">*</span>dcmp(d2)&lt;0;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure></p>
<h3 id="点与多边形"><a href="#点与多边形" class="headerlink" title="点与多边形"></a>点与多边形</h3><h4 id="判断点是否在任意多边形内"><a href="#判断点是否在任意多边形内" class="headerlink" title="判断点是否在任意多边形内"></a>判断点是否在任意多边形内</h4><p>使用射线法，时间复杂度为O(n)。<br>射线法（Ray casting algorithm）是一种判断点是否在多边形内部的一种简单方法。即从该点做一条射线，计算它跟多边形边界的交点个数，如果交点个数为奇数，那么点在多边形内部，否则点在多边形外部。<br>附上<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_86186c970102ybwn.html">简单易懂的证明以及细节</a><br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">PIP</span><span class="hljs-params">(Point *P,<span class="hljs-keyword">int</span> n,Point a)</span></span>&#123;<span class="hljs-comment">//射线法判断点A是否在任意多边形P[]以内</span><br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;LD tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">int</span> j=i&lt;n?i+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(pan_PL(a,P[i],P[j]))<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//点在多边形上</span><br>        <span class="hljs-keyword">if</span>(a.y&gt;=<span class="hljs-built_in">min</span>(P[i].y,P[j].y)&amp;&amp;a.y&lt;<span class="hljs-built_in">max</span>(P[i].y,P[j].y))<span class="hljs-comment">//纵坐标在该线段两端点之间</span><br>            tmp=P[i].x+(a.y-P[i].y)/(P[j].y-P[i].y)*(P[j].x-P[i].x),cnt+=dcmp(tmp-a.x)&gt;<span class="hljs-number">0</span>;<span class="hljs-comment">//交点在A右方</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt&amp;<span class="hljs-number">1</span>;<span class="hljs-comment">//返回2表明在多边形边上，返回1代表在多边形内，返回0代表在多边形外</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="判断点是否在凸多边形内"><a href="#判断点是否在凸多边形内" class="headerlink" title="判断点是否在凸多边形内"></a>判断点是否在凸多边形内</h4><p>使用二分法，时间复杂度为O(logn)<br>首先选择多边形其中一个点为起点，连接其它点作射线，将整个凸多边形分为多个小三角形。然后在射线围成的区域里判断点到底是在左半边还是右半边，最后确定的区域肯定会在一个三角形内。之后判断这个点是否在这个三角形内即可。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">int</span> judge(Point a,Point L,Point R)&#123;<span class="hljs-comment">//判断AL是否在AR右边</span><br>    return dcmp(<span class="hljs-constructor">Cro(L-<span class="hljs-params">a</span>,R-<span class="hljs-params">a</span>)</span>)&gt;<span class="hljs-number">0</span>;<span class="hljs-comment">//必须严格以内</span><br>&#125;<br>inline <span class="hljs-built_in">int</span> <span class="hljs-constructor">PIP_(Point <span class="hljs-operator">*</span>P,Re <span class="hljs-params">n</span>,Point <span class="hljs-params">a</span>)</span>&#123;<span class="hljs-comment">//二分法判断点A是否在凸多边形P以内</span><br>    <span class="hljs-comment">//点按逆时针给出</span><br>    <span class="hljs-keyword">if</span>(judge(P<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>,a,P<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>)<span class="hljs-pattern-match"><span class="hljs-operator">||</span>judge(<span class="hljs-constructor">P</span>[1],<span class="hljs-constructor">P</span>[n],a))return 0;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>在<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_2</span>]或<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_n</span>]外</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span>(pan<span class="hljs-constructor">_PL(<span class="hljs-params">a</span>,P[1],P[2])</span><span class="hljs-operator">||</span>pan<span class="hljs-constructor">_PL(<span class="hljs-params">a</span>,P[1],P[<span class="hljs-params">n</span>])</span>)return 2;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>在<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_2</span>]或<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_n</span>]上</span><br><span class="hljs-pattern-match">    <span class="hljs-constructor">Re</span> l=2,r=n-1;</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>二分找到一个位置pos使得<span class="hljs-constructor">P</span>[1]<span class="hljs-constructor">_A</span>在<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_pos</span>],<span class="hljs-constructor">P</span>[1<span class="hljs-constructor">_(<span class="hljs-params">pos</span>+1)</span>]之间</span><br><span class="hljs-pattern-match">        <span class="hljs-constructor">Re</span> mid=l+r+1&gt;&gt;1;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span>(judge(<span class="hljs-constructor">P</span>[1],<span class="hljs-constructor">P</span>[mid],a))l=mid;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">else</span> r=mid-1;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span>(judge(<span class="hljs-constructor">P</span>[l],a,<span class="hljs-constructor">P</span>[l+1]))return 0;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>在<span class="hljs-constructor">P</span>[pos<span class="hljs-constructor">_(<span class="hljs-params">pos</span>+1)</span>]外</span><br><span class="hljs-pattern-match">    <span class="hljs-keyword">if</span>(pan<span class="hljs-constructor">_PL(<span class="hljs-params">a</span>,P[<span class="hljs-params">l</span>],P[<span class="hljs-params">l</span>+1])</span>)return 2;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>在<span class="hljs-constructor">P</span>[pos<span class="hljs-constructor">_(<span class="hljs-params">pos</span>+1)</span>]上</span><br><span class="hljs-pattern-match">    return 1;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure></p>
<h3 id="线与多边形"><a href="#线与多边形" class="headerlink" title="线与多边形"></a>线与多边形</h3><h4 id="判断线段是否在任意多边形内"><a href="#判断线段是否在任意多边形内" class="headerlink" title="判断线段是否在任意多边形内"></a>判断线段是否在任意多边形内</h4><p>用射线法判断两端点是否在多边形内，之后再判断线段和多边形的其他线段是否有交点。</p>
<h4 id="判断线段是否在任意多边形内-1"><a href="#判断线段是否在任意多边形内-1" class="headerlink" title="判断线段是否在任意多边形内"></a>判断线段是否在任意多边形内</h4><p>只需要判断两端点都在多边形内即可，不过再返回都为2时(及线段两端点都在多边形上)，需要进行特判看是否线段在多边形上。</p>
<h3 id="多边形相关"><a href="#多边形相关" class="headerlink" title="多边形相关"></a>多边形相关</h3><h4 id="判断任意两个多边形是否相离"><a href="#判断任意两个多边形是否相离" class="headerlink" title="判断任意两个多边形是否相离"></a>判断任意两个多边形是否相离</h4><p>属于不同多边形的任意两边都不相交 且一个多边形上的任意点都不被另一个多边形所包含。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">int</span> judge<span class="hljs-constructor">_PP(Point <span class="hljs-operator">*</span>A,<span class="hljs-params">int</span> <span class="hljs-params">n</span>,Point <span class="hljs-operator">*</span>B,<span class="hljs-params">int</span> <span class="hljs-params">m</span>)</span>&#123;<span class="hljs-comment">//【判断多边形A与多边形B是否相离】 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i1=<span class="hljs-number">1</span>;i1&lt;=n;++i1)&#123;<br>        <span class="hljs-built_in">int</span> j1=i1&lt;n?i1+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i2=<span class="hljs-number">1</span>;i2&lt;=m;++i2)&#123;<br>            <span class="hljs-built_in">int</span> j2=i2&lt;m?i2+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(pan<span class="hljs-constructor">_cross_LL(A[<span class="hljs-params">i1</span>],A[<span class="hljs-params">j1</span>],B[<span class="hljs-params">i2</span>],B[<span class="hljs-params">j2</span>])</span>)return <span class="hljs-number">0</span>;<span class="hljs-comment">//两线段相交</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-constructor">PIP(B,<span class="hljs-params">m</span>,A[<span class="hljs-params">i1</span>])</span><span class="hljs-pattern-match"><span class="hljs-operator">||</span><span class="hljs-constructor">PIP(A,<span class="hljs-params">n</span>,B[<span class="hljs-params">i2</span>])</span>)return 0;<span class="hljs-operator">/</span><span class="hljs-operator">/</span>点包含在内</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">    &#125;</span><br><span class="hljs-pattern-match">    return 1;</span><br><span class="hljs-pattern-match">&#125;</span><br></code></pre></td></tr></table></figure></p>
<h4 id="求任意多边形面积"><a href="#求任意多边形面积" class="headerlink" title="求任意多边形面积"></a>求任意多边形面积</h4><p>使用鞋带定理(Shoelace formula) ，用来求任意多边形面积,这里是<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110025234">证明</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> LD <span class="hljs-title">P_Area</span><span class="hljs-params">(Point *P,Re n)</span></span>&#123;<span class="hljs-comment">//鞋带定理求任意多边形P的面积</span><br>    LD S=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)S+=Cro(P[i],P[i&lt;n?i+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">return</span> S/<span class="hljs-number">2.0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="求圆的面积并"><a href="#求圆的面积并" class="headerlink" title="求圆的面积并"></a>求圆的面积并</h4><p>首先得学习一下<a target="_blank" rel="noopener" href="https://blog.csdn.net/xyz32768/article/details/81392369">自适应辛普森法</a>，这是一种用二次函数来逼近曲线的一种方法(有点像泰勒，怪)，不过肯定是有精度误差的，因此需要将积分区域减少以减少误差。</p>
<h5 id="自适应辛普森法"><a href="#自适应辛普森法" class="headerlink" title="自适应辛普森法"></a>自适应辛普森法</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">inline LD f(LD x)<br>&#123;<br>    /*函数表达式*/<br>&#125;<br>inline LD simpson(LD l,LD <span class="hljs-built_in">r</span>)<br>&#123;<br>    LD mid=(l+<span class="hljs-built_in">r</span>)/<span class="hljs-number">2.0</span>;<br>    <span class="hljs-keyword">return</span> (f(l)+<span class="hljs-number">4.0</span>*f(mid)+f(<span class="hljs-built_in">r</span>))*(<span class="hljs-built_in">r</span><span class="hljs-literal">-l</span>)/<span class="hljs-number">6.0</span>;<br>&#125; <br>inline LD solve(LD l,LD <span class="hljs-built_in">r</span>,LD eps)<br>&#123;<br>    LD mid=(l+<span class="hljs-built_in">r</span>)/<span class="hljs-number">2.0</span>;<br>    LD s=simpson(l,<span class="hljs-built_in">r</span>),<span class="hljs-built_in">sl</span>=simpson(l,mid),sr=simpson(mid,<span class="hljs-built_in">r</span>);<br>    <span class="hljs-keyword">if</span>(dcmp(<span class="hljs-built_in">sl</span>+sr<span class="hljs-literal">-s</span>)) <span class="hljs-keyword">return</span> (<span class="hljs-built_in">sl</span>+sr+(<span class="hljs-built_in">sl</span>+sr<span class="hljs-literal">-s</span>));//注意，这里对精度要求较高，可能需要更改dcmp的精度范围<br>    <span class="hljs-keyword">return</span> solve(l,mid,eps/<span class="hljs-number">2.0</span>)+solve(mid,<span class="hljs-built_in">r</span>,eps/<span class="hljs-number">2.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>(哇，博客园一直在审核，好多东西都搜不到，待更。)</p>
<h5 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h5><p>扫描线好像求⚪的面积并很难搞，只不过和自适应辛普森差不多都是求面积的所以先放到一块，交给你了！后来的林泽音。(　ﾟ 3ﾟ)</p>
<h4 id="三角形面积并"><a href="#三角形面积并" class="headerlink" title="三角形面积并"></a>三角形面积并</h4><p>跟⚪的面积并大概差不多？只不过都是直线应该用扫描线更好一点？(・ω・)</p>
<h3 id="圆相关"><a href="#圆相关" class="headerlink" title="圆相关"></a>圆相关</h3><h4 id="给点求圆"><a href="#给点求圆" class="headerlink" title="给点求圆"></a>给点求圆</h4><p>拥有初中学历的人都知道，三点才能确定一个圆。<br>好像可以暴力带入公式啥的，不过太麻烦了就先旷过。<br>拥有初中学历的人还知道，圆的圆心在任意两条不平行弦的垂直平分线的交点上。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">struct</span> <span class="hljs-built_in">Circle</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Point</span> <span class="hljs-built_in">O</span><span class="hljs-operator">;</span><span class="hljs-variable">LD</span> <span class="hljs-variable">r</span><span class="hljs-operator">;</span><span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">LD</span> <span class="hljs-variable">R</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">O</span><span class="hljs-operator">=</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">r</span><span class="hljs-operator">=</span><span class="hljs-variable">R</span><span class="hljs-operator">;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">;</span><br><span class="hljs-variable">inline</span> <span class="hljs-built_in">Circle</span> <span class="hljs-variable">getcircle</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">A</span><span class="hljs-operator">,</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">B</span><span class="hljs-operator">,</span><span class="hljs-built_in">Point</span> <span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-operator">//</span>三点确定一圆向量垂心法<br>    <span class="hljs-built_in">Point</span> <span class="hljs-variable">P1</span><span class="hljs-operator">=</span><span class="hljs-punctuation">(</span><span class="hljs-variable">A</span><span class="hljs-operator">+</span><span class="hljs-variable">B</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-number">0.5</span><span class="hljs-operator">,</span><span class="hljs-variable">P2</span><span class="hljs-operator">=</span><span class="hljs-punctuation">(</span><span class="hljs-variable">A</span><span class="hljs-operator">+</span><span class="hljs-built_in">C</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-number">0.5</span><span class="hljs-operator">;</span><br>    <span class="hljs-built_in">Point</span> <span class="hljs-built_in">O</span><span class="hljs-operator">=</span><span class="hljs-type">cross_LL</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P1</span><span class="hljs-operator">,</span><span class="hljs-variable">P1</span><span class="hljs-operator">+</span><span class="hljs-built_in">Normal</span><span class="hljs-punctuation">(</span><span class="hljs-variable">B</span><span class="hljs-operator">-</span><span class="hljs-variable">A</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span><span class="hljs-variable">P2</span><span class="hljs-operator">,</span><span class="hljs-variable">P2</span><span class="hljs-operator">+</span><span class="hljs-built_in">Normal</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-operator">-</span><span class="hljs-variable">A</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>    <span class="hljs-variable">return</span> <span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">O</span><span class="hljs-operator">,</span><span class="hljs-variable">Len</span><span class="hljs-punctuation">(</span><span class="hljs-variable">A</span><span class="hljs-operator">-</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p>
<h4 id="最小覆盖圆算法"><a href="#最小覆盖圆算法" class="headerlink" title="最小覆盖圆算法"></a>最小覆盖圆算法</h4><p>使用随机增量法，把点全部打乱然后用同样的方法添加<br>用随机化降低不完全枚举造成有影响后果的概率以达到降低复杂度的目的. . .印象中上一个这个干的算法好像是Pollard_Rho因数分解。<br>具体说明在<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/boshi/solution-p1742">这里</a><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">struct</span> <span class="hljs-built_in">Circle</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Point</span> <span class="hljs-built_in">O</span><span class="hljs-operator">;</span><span class="hljs-variable">LD</span> <span class="hljs-variable">r</span><span class="hljs-operator">;</span><span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">LD</span> <span class="hljs-variable">R</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">O</span><span class="hljs-operator">=</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">r</span><span class="hljs-operator">=</span><span class="hljs-variable">R</span><span class="hljs-operator">;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">;</span><br><span class="hljs-variable">inline</span> <span class="hljs-variable">int</span> <span class="hljs-variable">PIC</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Circle</span> <span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-built_in">Point</span> <span class="hljs-variable">a</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">return</span> <span class="hljs-variable">dcmp</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Len</span><span class="hljs-punctuation">(</span><span class="hljs-variable">a</span><span class="hljs-operator">-</span><span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">)</span><span class="hljs-operator">-</span><span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-variable">r</span><span class="hljs-punctuation">)</span><span class="hljs-operator">&lt;=</span><span class="hljs-number">0</span><span class="hljs-operator">;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">//</span>判断点<span class="hljs-variable">A</span>是否在圆<span class="hljs-built_in">C</span>内<br><span class="hljs-variable">inline</span> <span class="hljs-variable">void</span> <span class="hljs-built_in">Random</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-operator">*</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-built_in">Re</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Re</span> <span class="hljs-variable">i</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">;</span><span class="hljs-variable">i</span><span class="hljs-operator">&lt;=</span><span class="hljs-variable">n</span><span class="hljs-operator">;++</span><span class="hljs-variable">i</span><span class="hljs-punctuation">)</span><span class="hljs-variable">swap</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">rand</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">%</span><span class="hljs-variable">n</span><span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-operator">//</span>随机一个排列<br><span class="hljs-variable">inline</span> <span class="hljs-built_in">Circle</span> <span class="hljs-variable">MinCover</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">Point</span> <span class="hljs-operator">*</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-built_in">Re</span> <span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><span class="hljs-operator">//</span>求点集<span class="hljs-variable">P</span>的最小覆盖圆<br>    <span class="hljs-built_in">Random</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-operator">,</span><span class="hljs-variable">n</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><span class="hljs-built_in">Circle</span> <span class="hljs-built_in">C</span><span class="hljs-operator">=</span><span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>    <span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-variable">int</span> <span class="hljs-variable">i</span><span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-operator">;</span><span class="hljs-variable">i</span><span class="hljs-operator">&lt;=</span><span class="hljs-variable">n</span><span class="hljs-operator">;++</span><span class="hljs-variable">i</span><span class="hljs-punctuation">)</span><span class="hljs-variable">if</span><span class="hljs-punctuation">(</span><span class="hljs-operator">!</span><span class="hljs-variable">PIC</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-built_in">C</span><span class="hljs-operator">=</span><span class="hljs-built_in">Circle</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>        <span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-variable">int</span> <span class="hljs-variable">j</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">;</span><span class="hljs-variable">j</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">i</span><span class="hljs-operator">;++</span><span class="hljs-variable">j</span><span class="hljs-punctuation">)</span><span class="hljs-variable">if</span><span class="hljs-punctuation">(</span><span class="hljs-operator">!</span><span class="hljs-variable">PIC</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-built_in">O</span><span class="hljs-operator">=</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-operator">+</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">*</span><span class="hljs-number">0.5</span><span class="hljs-operator">,</span><span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-variable">r</span><span class="hljs-operator">=</span><span class="hljs-variable">Len</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span><span class="hljs-operator">-</span><span class="hljs-built_in">C</span><span class="hljs-operator">.</span><span class="hljs-built_in">O</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>            <span class="hljs-variable">for</span><span class="hljs-punctuation">(</span><span class="hljs-variable">int</span> <span class="hljs-variable">k</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">;</span><span class="hljs-variable">k</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">j</span><span class="hljs-operator">;++</span><span class="hljs-variable">k</span><span class="hljs-punctuation">)</span><span class="hljs-variable">if</span><span class="hljs-punctuation">(</span><span class="hljs-operator">!</span><span class="hljs-variable">PIC</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">C</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">k</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">C</span><span class="hljs-operator">=</span><span class="hljs-variable">getcircle</span><span class="hljs-punctuation">(</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">i</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">j</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span><span class="hljs-variable">P</span><span class="hljs-punctuation">[</span><span class="hljs-variable">k</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-variable">return</span> <span class="hljs-built_in">C</span><span class="hljs-operator">;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p>
<h3 id="凸包相关"><a href="#凸包相关" class="headerlink" title="凸包相关"></a>凸包相关</h3><h4 id="给点集求凸包"><a href="#给点集求凸包" class="headerlink" title="给点集求凸包"></a>给点集求凸包</h4><p>我学习的博客上说是Graham扫描法，但是他实际上给的是Andrew算法的代码…<br>感觉Andrew要比Graham要简单，就只介绍下Andrew吧。<br>首先先按按照x优先的顺序排序（坐标从小到大），之后易知第一个点和最后一个点肯定是在凸包上。求凸包时需要扫描一遍所有点，遇到比栈顶向量右边的就替换栈顶向量，左边的直接入栈。 扫描到头会发现. . .这种算法只会算出一半的凸包，呢就反过来再来一遍，也就是第一遍算下凸包，第二遍算上凸包。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> cmp1(Vector a,Vector b)&#123;return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;;<span class="hljs-comment">//按坐标排序</span><br>inline <span class="hljs-built_in">int</span> <span class="hljs-constructor">ConvexHull(Point <span class="hljs-operator">*</span>P,<span class="hljs-params">int</span> <span class="hljs-params">n</span>,Point <span class="hljs-operator">*</span><span class="hljs-params">cp</span>)</span>&#123;<span class="hljs-comment">//cp存的是凸包元素</span><br>    sort(P+<span class="hljs-number">1</span>,P+n+<span class="hljs-number">1</span>,cmp1);<br>    <span class="hljs-built_in">int</span> t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">while</span>(t&gt;<span class="hljs-number">1</span>&amp;&amp;dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>-1],P[<span class="hljs-params">i</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>-1])</span>)&lt;=<span class="hljs-number">0</span>)--t;<span class="hljs-comment">//假如P[i]此时在栈顶两点组成直线的的右边，呢么此时栈顶两点就必不可能是凸包上的点。</span><br>        cp<span class="hljs-literal">[<span class="hljs-operator">++</span><span class="hljs-identifier">t</span>]</span>=P<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    &#125;<br>    <span class="hljs-built_in">int</span> St=t;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=n-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;--i)&#123;<br>        <span class="hljs-keyword">while</span>(t&gt;St&amp;&amp;dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>-1],P[<span class="hljs-params">i</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">t</span>-1])</span>)&lt;=<span class="hljs-number">0</span>)--t;<br>        cp<span class="hljs-literal">[<span class="hljs-operator">++</span><span class="hljs-identifier">t</span>]</span>=P<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    &#125;<br>    return --t;<span class="hljs-comment">//要减一</span><br>&#125;<br></code></pre></td></tr></table></figure></p>
<h4 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h4><p>旋转卡壳，本质是用凸包上的直线做平行线去找到对踵点，然后由于凸包的壕多性质都可以用对踵点来获得，所以可以用这个算法求很多东西：凸包直径(两点距离最长)，凸包的宽(两点距离最短)，凸包间的最大/小距离，凸多边形最小面积外接矩形，凸多边形最小周长外接矩形<br>比较细的讲解可以学习自<a target="_blank" rel="noopener" href="https://blog.csdn.net/pi9nc/article/details/11715227">这篇博文</a></p>
<h5 id="求凸包直径-宽"><a href="#求凸包直径-宽" class="headerlink" title="求凸包直径/宽"></a>求凸包直径/宽</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">double maxAns=<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[2]-<span class="hljs-params">cp</span>[1])</span>,minAns=<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[2]-<span class="hljs-params">cp</span>[1])</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">3</span>;i&lt;=cnt;++i)&#123;<br>    <span class="hljs-keyword">while</span>(dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>],<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>])</span>-<span class="hljs-constructor">Cro(<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>],<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>+1]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>])</span>)&lt;<span class="hljs-number">0</span>)j=j&lt;cnt?j+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<span class="hljs-comment">//找到对踵点。注意是&lt;0，如果写&lt;=0的话可能会被两个点的数据卡掉</span><br>    maxAns=max(maxAns,max(<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>])</span>,<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>+1])</span>));<span class="hljs-comment">//求凸包直径</span><br>    minAns=min(minAns,min(<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>])</span>,<span class="hljs-constructor">Len(<span class="hljs-params">cp</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">cp</span>[<span class="hljs-params">i</span>+1])</span>));<span class="hljs-comment">//求凸包的宽</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="求面积最小矩形覆盖"><a href="#求面积最小矩形覆盖" class="headerlink" title="求面积最小矩形覆盖"></a>求面积最小矩形覆盖</h5><p>主要思路和基本的旋转卡壳差不多，但是要同时旋转三个点，以及定了矩形框架后用交线来<br>打好的<a target="_blank" rel="noopener" href="https://paste.ubuntu.com/p/tVfRkNW5BB/">代码</a>本来是交给<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3187">luogu</a>的. . .但是一直40pts还不给看数据，怀疑是莫得spj的问题但是有spj的BZOJ也早就凉了，所以到现在还莫得过，所以先把锅推给莫得spj，自己先用着代码。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">double minArea=<span class="hljs-number">10000000.0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">2</span>,z=<span class="hljs-number">2</span>,k=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;<br>		<span class="hljs-keyword">while</span>(dcmp(<span class="hljs-constructor">Cro(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>-<span class="hljs-constructor">Cro(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>)&gt;<span class="hljs-number">0</span>)j=j&lt;n?j+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">while</span>(dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>-<span class="hljs-constructor">Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>)&gt;<span class="hljs-number">0</span>)z=z&lt;n?z+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<span class="hljs-comment">//找到宽</span><br>		k=(i==<span class="hljs-number">1</span>)?j:k;<br>		<span class="hljs-keyword">while</span>(dcmp(<span class="hljs-constructor">Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>-<span class="hljs-constructor">Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>)&gt;<span class="hljs-number">0</span>)k=k&lt;n?k+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<span class="hljs-comment">//找到宽</span><br>        LD dis=<span class="hljs-constructor">Len(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>,kuan,gao;<br>        LD l=<span class="hljs-constructor">Abs(Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>/dis);<br>		LD r=<span class="hljs-constructor">Abs(Dot(<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1])</span>/dis);<br>        LD h=<span class="hljs-constructor">Abs(Cro(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>]-<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>])</span>/dis);<br>		gao=<span class="hljs-constructor">Abs(<span class="hljs-params">h</span>)</span>;kuan=<span class="hljs-constructor">Abs(<span class="hljs-params">r</span>+<span class="hljs-params">l</span>-<span class="hljs-params">dis</span>)</span>;<br>		<span class="hljs-keyword">if</span>(gao*kuan&lt;minArea)<br>        &#123;<br>			<span class="hljs-comment">//cout&lt;&lt;gao&lt;&lt;&#x27; &#x27;&lt;&lt;kuan&lt;&lt;&#x27; &#x27;&lt;&lt;minArea&lt;&lt;endl;</span><br>            minArea=gao*kuan;<br>            Square<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>=cross<span class="hljs-constructor">_LL(<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>]+<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>]+Normal_line(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>);<br>            Square<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>=cross<span class="hljs-constructor">_LL(<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">j</span>]+<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>]+Normal_line(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>);<br>            Square<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>=cross<span class="hljs-constructor">_LL(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">k</span>]+Normal_line(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>);<br>            Square<span class="hljs-literal">[<span class="hljs-number">4</span>]</span>=cross<span class="hljs-constructor">_LL(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>],<span class="hljs-params">tu</span>[<span class="hljs-params">z</span>]+Normal_line(<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>+1]-<span class="hljs-params">tu</span>[<span class="hljs-params">i</span>])</span>);<br>            <span class="hljs-comment">//保证逆时针的存点</span><br>        &#125;<br>	&#125;<br>	printf(<span class="hljs-string">&quot;%.5lf\n&quot;</span>,minArea);<br></code></pre></td></tr></table></figure></p>
<h5 id="求周长最小矩形覆盖"><a href="#求周长最小矩形覆盖" class="headerlink" title="求周长最小矩形覆盖"></a>求周长最小矩形覆盖</h5><p>面积最小都算出来了，周长最小也是很简单的，就是每次判断一下l+r的大小就行。<br>代码几乎还是上面的就不搞了</p>
<h4 id="求半平面交"><a href="#求半平面交" class="headerlink" title="求半平面交"></a>求半平面交</h4><p>半平面是指一条直线会把一个平面分成两个部分，其中任意一个部分都是一个半平面，通一般情况下我们需要的是直线左边的半平面。<br>半平面交就是若干半平面的交集，多边形各边的半平面交就是多边形的核（一个可以看到多边形的任何一个角落的区域）<br>具体写法在<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenxiaoran666/p/HalfPlaneIntersection.html">这里</a><br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">struct <span class="hljs-type">Line</span>&#123;<br>    <span class="hljs-type">Point</span> a,b;LD k;Line(<span class="hljs-type">Point</span> A=<span class="hljs-type">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-type">Point</span> B=<span class="hljs-type">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))&#123;a=A,b=B,k=atan2(b.y-a.y,b.x-a.x);&#125;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(const <span class="hljs-type">Line</span> &amp;O)const&#123;<span class="hljs-keyword">return</span> dcmp(k-O.k)?dcmp(k-O.k)&lt;<span class="hljs-number">0</span>:judge(O.a,O.b,a);&#125;//<br>&#125;L[N],Q[N];<br><span class="hljs-keyword">inline</span> <span class="hljs-type">Point</span> <span class="hljs-keyword">cross</span>(<span class="hljs-type">Line</span> L1,<span class="hljs-type">Line</span> L2)&#123;<span class="hljs-keyword">return</span> cross_LL(L1.a,L1.b,L2.a,L2.b);&#125;//获取直线L1,L2的交点 <br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> judge(<span class="hljs-type">Line</span> L,<span class="hljs-type">Point</span> a)&#123;<span class="hljs-keyword">return</span> dcmp(Cro(a-L.a,L.b-L.a))&gt;<span class="hljs-number">0</span>;&#125;//判断点a是否在直线L的右边<br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> halfcut(<span class="hljs-type">Line</span> *L,Re n,<span class="hljs-type">Point</span> *P)&#123;//【半平面交】 <br>    sort(L+<span class="hljs-number">1</span>,L+n+<span class="hljs-number">1</span>);Re m=n;n=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(Re i=<span class="hljs-number">1</span>;i&lt;=m;++i)<span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>||dcmp(L[i].k-L[i<span class="hljs-number">-1</span>].k))L[++n]=L[i];<br>    Re h=<span class="hljs-number">1</span>,t=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(Re i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-keyword">while</span>(h&lt;t&amp;&amp;judge(L[i],<span class="hljs-keyword">cross</span>(Q[t],Q[t<span class="hljs-number">-1</span>])))<span class="hljs-comment">--t;//当队尾两个直线交点不是在直线L[i]上或者左边时就出队</span><br>        <span class="hljs-keyword">while</span>(h&lt;t&amp;&amp;judge(L[i],<span class="hljs-keyword">cross</span>(Q[h],Q[h+<span class="hljs-number">1</span>])))++h;//当队头两个直线交点不是在直线L[i]上或者左边时就出队<br>        Q[++t]=L[i];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(h&lt;t&amp;&amp;judge(Q[h],<span class="hljs-keyword">cross</span>(Q[t],Q[t<span class="hljs-number">-1</span>])))<span class="hljs-comment">--t;</span><br>    <span class="hljs-keyword">while</span>(h&lt;t&amp;&amp;judge(Q[t],<span class="hljs-keyword">cross</span>(Q[h],Q[h+<span class="hljs-number">1</span>])))++h;<br>    n=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(Re i=h;i&lt;=t;++i)P[++n]=<span class="hljs-keyword">cross</span>(Q[i],Q[i&lt;t?i+<span class="hljs-number">1</span>:h]);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<h3 id="球"><a href="#球" class="headerlink" title="球"></a>球</h3><h4 id="球缺"><a href="#球缺" class="headerlink" title="球缺"></a>球缺</h4><p>球被平面截下的一部分叫做球缺。截面叫做球缺的底面，垂直于截面的直径被截后，剩下的线段长叫做球缺的高(H)。<br>球缺曲面部分的面积（球冠面积）：<script type="math/tex">S=2\pi RH</script><br>球缺体积公式:<script type="math/tex">V=\frac{\pi}{3}(3R-H)H^2</script></p>
<h4 id="球的体积并"><a href="#球的体积并" class="headerlink" title="球的体积并"></a>球的体积并</h4><p>就是两个球的体积和减去两球被截面所截的球缺体积</p>
<h3 id="好玩的东西"><a href="#好玩的东西" class="headerlink" title="好玩的东西"></a>好玩的东西</h3><h4 id="求平面最近点对"><a href="#求平面最近点对" class="headerlink" title="求平面最近点对"></a>求平面最近点对</h4><p>平面上有n个二维坐标点，求最近的点对。<br>朴素想法肯定是n方比较，但是神奇的分治保证了可以递归处理问题，使得复杂度达到O(nlognlogn)</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> inf = <span class="hljs-number">1e20</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100005</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">double</span> x, y;<br>&#125;<span class="hljs-built_in">point</span>[maxn];<br><span class="hljs-keyword">int</span> n, mpt[maxn];<br><span class="hljs-comment">//以x为基准排序</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmpxy</span><span class="hljs-params">(Point a,Point b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.x!=b.x)<span class="hljs-keyword">return</span> a.x &lt; b.x;<br>    <span class="hljs-keyword">return</span> a.y&lt;b.y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmpy</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">point</span>[a].y &lt; <span class="hljs-built_in">point</span>[b].y;&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> a &lt; b ? a : b;&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((<span class="hljs-built_in">point</span>[i].x-<span class="hljs-built_in">point</span>[j].x)*(<span class="hljs-built_in">point</span>[i].x-<span class="hljs-built_in">point</span>[j].x)+(<span class="hljs-built_in">point</span>[i].y-<span class="hljs-built_in">point</span>[j].y)*(<span class="hljs-built_in">point</span>[i].y-<span class="hljs-built_in">point</span>[j].y));&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Closest_Pair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">double</span> d=inf;<br>    <span class="hljs-keyword">if</span>(left == right)<span class="hljs-keyword">return</span> d;<br>    <span class="hljs-keyword">if</span>(left+<span class="hljs-number">1</span>==right)<span class="hljs-keyword">return</span> dis(left, right);<br>    <span class="hljs-keyword">int</span> mid=(left+right)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">double</span> d1=Closest_Pair(left,mid);<br>    <span class="hljs-keyword">double</span> d2=Closest_Pair(mid+<span class="hljs-number">1</span>,right);<br>    d = <span class="hljs-built_in">min</span>(d1, d2);<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//分离出宽度为d的区间</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left;i&lt;=right;i++)<br>      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(<span class="hljs-built_in">point</span>[mid].x-<span class="hljs-built_in">point</span>[i].x)&lt;=d)<br>        mpt[k++] = i;<br>    sort(mpt, mpt + k, cmpy);<br>    <span class="hljs-comment">//线性扫描</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;k&amp;&amp;<span class="hljs-built_in">point</span>[mpt[j]].y-<span class="hljs-built_in">point</span>[mpt[i]].y&lt;d;j++)<br>          d=<span class="hljs-built_in">min</span>(d,dis(mpt[i],mpt[j]));<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n)<br>  &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf %lf&quot;</span>,&amp;<span class="hljs-built_in">point</span>[i].x,&amp;<span class="hljs-built_in">point</span>[i].y);<br>    sort(<span class="hljs-built_in">point</span>, <span class="hljs-built_in">point</span> + n, cmpxy);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, Closest_Pair(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/">计算几何</a>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/%E6%80%BB%E7%BB%93/">总结</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/acm/">acm</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%8A%80%E5%B7%A7/">技巧</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/">计算几何</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/11/DP%20%E5%88%B7%E9%A2%98%E6%9F%B1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">DP刷题柱</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/03/30/%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%80%89%E6%8B%94-%E7%BA%BF%E6%AE%B5%E6%A0%91%E8%BE%85%E5%8A%A9%E5%BB%BA%E5%9B%BE/">
                        <span class="hidden-mobile">天梯赛选拔-线段树辅助建图</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('vcomments', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "J4xBsWcJgxKh3H9CftQAYn80-gzGzoHsz",
          app_key: "5yzQO665EGlMYIao6dGQ64Ub",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: true,
          recordIP: false,
          serverURLs: "",
        });
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the
    <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments powered by Valine.</a>
  </noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

    
    <!--点击特效-->
  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



  {% include '_third-party/comments/index.swig' %}
  <script type="text/javascript" src="/js/clicksocialvalue.js"></script>
  <script type="text/javascript" src="/js/clicklove.js"></script>
  
  
</body>
</html>
